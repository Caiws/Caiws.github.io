"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[5362],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>p});var n=a(7294);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var l=n.createContext({}),h=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},c=function(e){var t=h(e.components);return n.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=h(a),p=o,m=d["".concat(l,".").concat(p)]||d[p]||u[p]||r;return a?n.createElement(m,i(i({ref:t},c),{},{components:a})):n.createElement(m,i({ref:t},c))}));function p(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=a.length,i=new Array(r);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var h=2;h<r;h++)i[h]=a[h];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},5074:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>h});var n=a(7462),o=(a(7294),a(3905));const r={},i=void 0,s={unversionedId:"Books/EffectiveJava3/Chapter-11/Chapter-11-Item-78-Synchronize-access-to-shared-mutable-data",id:"Books/EffectiveJava3/Chapter-11/Chapter-11-Item-78-Synchronize-access-to-shared-mutable-data",title:"Chapter-11-Item-78-Synchronize-access-to-shared-mutable-data",description:"Chapter 11. Concurrency\uff08\u5e76\u53d1\uff09",source:"@site/docs/Books/EffectiveJava3/Chapter-11/Chapter-11-Item-78-Synchronize-access-to-shared-mutable-data.md",sourceDirName:"Books/EffectiveJava3/Chapter-11",slug:"/Books/EffectiveJava3/Chapter-11/Chapter-11-Item-78-Synchronize-access-to-shared-mutable-data",permalink:"/docs/Books/EffectiveJava3/Chapter-11/Chapter-11-Item-78-Synchronize-access-to-shared-mutable-data",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Books/EffectiveJava3/Chapter-11/Chapter-11-Item-78-Synchronize-access-to-shared-mutable-data.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Chapter-11-Introduction",permalink:"/docs/Books/EffectiveJava3/Chapter-11/Chapter-11-Introduction"},next:{title:"Chapter-11-Item-79-Avoid-excessive-synchronization",permalink:"/docs/Books/EffectiveJava3/Chapter-11/Chapter-11-Item-79-Avoid-excessive-synchronization"}},l={},h=[{value:"Chapter 11. Concurrency\uff08\u5e76\u53d1\uff09",id:"chapter-11-concurrency\u5e76\u53d1",level:2},{value:"Item 78: Synchronize access to shared mutable data\uff08\u5bf9\u5171\u4eab\u53ef\u53d8\u6570\u636e\u7684\u540c\u6b65\u8bbf\u95ee\uff09",id:"item-78-synchronize-access-to-shared-mutable-data\u5bf9\u5171\u4eab\u53ef\u53d8\u6570\u636e\u7684\u540c\u6b65\u8bbf\u95ee",level:3}],c={toc:h};function u(e){let{components:t,...a}=e;return(0,o.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"chapter-11-concurrency\u5e76\u53d1"},"Chapter 11. Concurrency\uff08\u5e76\u53d1\uff09"),(0,o.kt)("h3",{id:"item-78-synchronize-access-to-shared-mutable-data\u5bf9\u5171\u4eab\u53ef\u53d8\u6570\u636e\u7684\u540c\u6b65\u8bbf\u95ee"},"Item 78: Synchronize access to shared mutable data\uff08\u5bf9\u5171\u4eab\u53ef\u53d8\u6570\u636e\u7684\u540c\u6b65\u8bbf\u95ee\uff09"),(0,o.kt)("p",null,"The synchronized keyword ensures that only a single thread can execute a method or block at one time. Many programmers think of synchronization solely as a means of mutual exclusion, to prevent an object from being seen in an inconsistent state by one thread while it\u2019s being modified by another. In this view, an object is created in a consistent state (Item 17) and locked by the methods that access it. These methods observe the state and optionally cause a state transition, transforming the object from one consistent state to another. Proper use of synchronization guarantees that no method will ever observe the object in an inconsistent state."),(0,o.kt)("p",null,"synchronized \u5173\u952e\u5b57\u786e\u4fdd\u4e00\u6b21\u53ea\u6709\u4e00\u4e2a\u7ebf\u7a0b\u53ef\u4ee5\u6267\u884c\u4e00\u4e2a\u65b9\u6cd5\u6216\u5757\u3002\u8bb8\u591a\u7a0b\u5e8f\u5458\u8ba4\u4e3a\u540c\u6b65\u53ea\u662f\u4e00\u79cd\u4e92\u65a5\u7684\u65b9\u6cd5\uff0c\u662f\u4e3a\u9632\u6b62\u4e00\u4e2a\u7ebf\u7a0b\u5728\u53e6\u4e00\u4e2a\u7ebf\u7a0b\u4fee\u6539\u5bf9\u8c61\u65f6\u4f7f\u5bf9\u8c61\u5904\u4e8e\u4e0d\u4e00\u81f4\u7684\u72b6\u6001\u3002\u8fd9\u6837\u770b\u6765\uff0c\u5bf9\u8c61\u4ee5\u4e00\u81f4\u7684\u72b6\u6001\u521b\u5efa\uff08",(0,o.kt)("a",{parentName:"p",href:"./Chapter-4-Item-17-Minimize-mutability"},"Item-17"),"\uff09\uff0c\u5e76\u7531\u8bbf\u95ee\u5b83\u7684\u65b9\u6cd5\u9501\u5b9a\u3002\u8fd9\u4e9b\u65b9\u6cd5\u53ef\u4ee5\u5bdf\u89c9\u5f53\u524d\u72b6\u6001\uff0c\u5e76\u5f15\u8d77\u72b6\u6001\u8f6c\u6362\uff0c\u5c06\u5bf9\u8c61\u4ece\u4e00\u81f4\u7684\u72b6\u6001\u8f6c\u6362\u4e3a\u53e6\u4e00\u4e2a\u4e00\u81f4\u7684\u72b6\u6001\u3002\u6b63\u786e\u4f7f\u7528\u540c\u6b65\u53ef\u4ee5\u4fdd\u8bc1\u6ca1\u6709\u65b9\u6cd5\u4f1a\u8ba9\u5bf9\u8c61\u5904\u4e8e\u4e0d\u4e00\u81f4\u72b6\u6001\u3002"),(0,o.kt)("p",null,"This view is correct, but it\u2019s only half the story. Without synchronization, one thread\u2019s changes might not be visible to other threads. Not only does synchronization prevent threads from observing an object in an inconsistent state, but it ensures that each thread entering a synchronized method or block sees the effects of all previous modifications that were guarded by the same lock."),(0,o.kt)("p",null,"\u8fd9\u79cd\u89c2\u70b9\u662f\u6b63\u786e\u7684\uff0c\u4f46\u5b83\u53ea\u662f\u51b0\u5c71\u4e00\u89d2\u3002\u6ca1\u6709\u540c\u6b65\uff0c\u4e00\u4e2a\u7ebf\u7a0b\u6240\u505a\u7684\u7684\u66f4\u6539\u53ef\u80fd\u5bf9\u5176\u4ed6\u7ebf\u7a0b\u4e0d\u53ef\u89c1\u3002\u540c\u6b65\u4e0d\u4ec5\u963b\u6b62\u7ebf\u7a0b\u5bdf\u89c9\u5230\u5904\u4e8e\u4e0d\u4e00\u81f4\u72b6\u6001\u7684\u5bf9\u8c61\uff0c\u800c\u4e14\u786e\u4fdd\u6bcf\u4e2a\u8fdb\u5165\u540c\u6b65\u65b9\u6cd5\u6216\u5757\u7684\u7ebf\u7a0b\u90fd\u80fd\u5bdf\u89c9\u7531\u540c\u4e00\u628a\u9501\u4fdd\u62a4\u7684\u6240\u6709\u5df2\u4fee\u6539\u7684\u6548\u679c\u3002"),(0,o.kt)("p",null,"The language specification guarantees that reading or writing a variable is atomic unless the variable is of type long or double ","[JLS, 17.4, 17.7]",". In other words, reading a variable other than a long or double is guaranteed to return a value that was stored into that variable by some thread, even if multiple threads modify the variable concurrently and without synchronization."),(0,o.kt)("p",null,"\u8bed\u8a00\u89c4\u8303\u4fdd\u8bc1\u8bfb\u53d6\u6216\u5199\u5165\u53d8\u91cf\u662f\u539f\u5b50\u6027\u7684\uff0c\u9664\u975e\u53d8\u91cf\u7684\u7c7b\u578b\u662f long \u6216 double ","[JLS, 17.4, 17.7]","\u3002\u6362\u53e5\u8bdd\u8bf4\uff0c\u8bfb\u53d6 long \u6216 double \u4e4b\u5916\u7684\u53d8\u91cf\u5c06\u4fdd\u8bc1\u8fd4\u56de\u67d0\u4e2a\u7ebf\u7a0b\u5b58\u50a8\u5728\u8be5\u53d8\u91cf\u4e2d\u7684\u503c\uff0c\u5373\u4f7f\u591a\u4e2a\u7ebf\u7a0b\u540c\u65f6\u4fee\u6539\u8be5\u53d8\u91cf\uff0c\u5e76\u4e14\u6ca1\u6709\u540c\u6b65\u65f6\u4e5f\u662f\u5982\u6b64\u3002"),(0,o.kt)("p",null,"You may hear it said that to improve performance, you should dispense with synchronization when reading or writing atomic data. This advice is dangerously wrong. While the language specification guarantees that a thread will not see an arbitrary value when reading a field, it does not guarantee that a value written by one thread will be visible to another. ",(0,o.kt)("strong",{parentName:"p"},"Synchronization is required for reliable communication between threads as well as for mutual exclusion.")," This is due to a part of the language specification known as the memory model, which specifies when and how changes made by one thread become visible to others ","[JLS, 17.4; Goetz06, 16]","."),(0,o.kt)("p",null,"\u4f60\u53ef\u80fd\u542c\u8bf4\u8fc7\uff0c\u4e3a\u4e86\u63d0\u9ad8\u6027\u80fd\uff0c\u5728\u8bfb\u53d6\u6216\u5199\u5165\u5177\u6709\u539f\u5b50\u6027\u7684\u6570\u636e\u65f6\u5e94\u8be5\u907f\u514d\u540c\u6b65\u3002\u8fd9\u79cd\u5efa\u8bae\u5927\u9519\u7279\u9519\u3002\u867d\u7136\u8bed\u8a00\u89c4\u8303\u4fdd\u8bc1\u7ebf\u7a0b\u5728\u8bfb\u53d6\u5b57\u6bb5\u65f6\u4e0d\u4f1a\u89c9\u5bdf\u4efb\u610f\u503c\uff0c\u4f46\u5b83\u4e0d\u4fdd\u8bc1\u7531\u4e00\u4e2a\u7ebf\u7a0b\u7f16\u5199\u7684\u503c\u5bf9\u53e6\u4e00\u4e2a\u7ebf\u7a0b\u53ef\u89c1\u3002",(0,o.kt)("strong",{parentName:"p"},"\u7ebf\u7a0b\u4e4b\u95f4\u80fd\u53ef\u9760\u901a\u4fe1\u4ee5\u53ca\u5b9e\u65bd\u4e92\u65a5\uff0c\u540c\u6b65\u662f\u6240\u5fc5\u9700\u7684\u3002")," \u8fd9\u662f\u7531\u4e8e\u8bed\u8a00\u89c4\u8303\u4e2d\uff0c\u79f0\u4e3a\u5185\u5b58\u6a21\u578b\u7684\u90e8\u5206\u6307\u5b9a\u4e86\u4e00\u4e2a\u7ebf\u7a0b\u6240\u505a\u7684\u66f4\u6539\u4f55\u65f6\u4ee5\u53ca\u5982\u4f55\u5bf9\u5176\u4ed6\u7ebf\u7a0b\u53ef\u89c1 ","[JLS, 17.4; Goetz06, 16]","\u3002"),(0,o.kt)("p",null,"The consequences of failing to synchronize access to shared mutable data can be dire even if the data is atomically readable and writable. Consider the task of stopping one thread from another. The libraries provide the Thread.stop method, but this method was deprecated long ago because it is inherently unsafe \u2014its use can result in data corruption. ",(0,o.kt)("strong",{parentName:"p"},"Do not use Thread.stop.")," A recommended way to stop one thread from another is to have the first thread poll a boolean field that is initially false but can be set to true by the second thread to indicate that the first thread is to stop itself. Because reading and writing a boolean field is atomic, some programmers dispense with synchronization when accessing the field:"),(0,o.kt)("p",null,"\u5373\u4f7f\u6570\u636e\u662f\u539f\u5b50\u53ef\u8bfb\u548c\u53ef\u5199\u7684\uff0c\u65e0\u6cd5\u540c\u6b65\u8bbf\u95ee\u5171\u4eab\u53ef\u53d8\u6570\u636e\u7684\u540e\u679c\u4e5f\u53ef\u80fd\u662f\u53ef\u6015\u7684\u3002\u8003\u8651\u4ece\u4e00\u4e2a\u7ebf\u7a0b\u4e2d\u4f7f\u53e6\u4e00\u4e2a\u7ebf\u7a0b\u505c\u6b62\u7684\u4efb\u52a1\u3002\u5e93\u63d0\u4f9b\u4e86 ",(0,o.kt)("inlineCode",{parentName:"p"},"Thread.stop")," \u65b9\u6cd5\uff0c\u4f46\u662f\u8fd9\u4e2a\u65b9\u6cd5\u5f88\u4e45\u4ee5\u524d\u5c31\u88ab\u5f03\u7528\u4e86\uff0c\u56e0\u4e3a\u5b83\u672c\u8d28\u4e0a\u662f\u4e0d\u5b89\u5168\u7684\uff0c\u5b83\u7684\u4f7f\u7528\u53ef\u80fd\u5bfc\u81f4\u6570\u636e\u635f\u574f\u3002",(0,o.kt)("strong",{parentName:"p"},"\u4e0d\u8981\u4f7f\u7528 ",(0,o.kt)("inlineCode",{parentName:"strong"},"Thread.stop"),"\u3002")," \u4e00\u4e2a\u5efa\u8bae\u7684\u65b9\u6cd5\u662f\u8ba9\u7b2c\u4e00\u4e2a\u7ebf\u7a0b\u8f6e\u8be2\u4e00\u4e2a boolean \u5b57\u6bb5\uff0c\u8be5\u5b57\u6bb5\u6700\u521d\u4e3a false\uff0c\u4f46\u7b2c\u4e8c\u4e2a\u7ebf\u7a0b\u53ef\u4ee5\u5c06\u5176\u8bbe\u7f6e\u4e3a true\uff0c\u4ee5\u6307\u793a\u7b2c\u4e00\u4e2a\u7ebf\u7a0b\u8981\u505c\u6b62\u5b83\u81ea\u5df1\u3002\u7531\u4e8e\u8bfb\u5199\u5e03\u5c14\u5b57\u6bb5\u662f\u539f\u5b50\u6027\u7684\uff0c\u4e00\u4e9b\u7a0b\u5e8f\u5458\u5728\u8bbf\u95ee\u8be5\u5b57\u6bb5\u65f6\u4e0d\u9700\u8981\u540c\u6b65\uff1a"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"// Broken! - How long would you expect this program to run?\npublic class StopThread {\n    private static boolean stopRequested;\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread backgroundThread = new Thread(() -> {\n        int i = 0;\n        while (!stopRequested)\n            i++;\n        });\n\n    backgroundThread.start();\n    TimeUnit.SECONDS.sleep(1);\n    stopRequested = true;\n    }\n}\n")),(0,o.kt)("p",null,"You might expect this program to run for about a second, after which the main thread sets stopRequested to true, causing the background thread\u2019s loop to terminate. On my machine, however, the program never terminates: the background thread loops forever!"),(0,o.kt)("p",null,"\u4f60\u53ef\u80fd\u8ba4\u4e3a\u8fd9\u4e2a\u7a0b\u5e8f\u8fd0\u884c\u5927\u7ea6\u4e00\u79d2\u949f\uff0c\u4e4b\u540e\u4e3b\u7ebf\u7a0b\u5c06 stopRequested \u8bbe\u7f6e\u4e3a true\uff0c\u4ece\u800c\u5bfc\u81f4\u540e\u53f0\u7ebf\u7a0b\u7684\u5faa\u73af\u7ec8\u6b62\u3002\u7136\u800c\uff0c\u5728\u6211\u7684\u673a\u5668\u4e0a\uff0c\u7a0b\u5e8f\u6c38\u8fdc\u4e0d\u4f1a\u7ec8\u6b62\uff1a\u540e\u53f0\u7ebf\u7a0b\u6c38\u8fdc\u5faa\u73af\uff01"),(0,o.kt)("p",null,"The problem is that in the absence of synchronization, there is no guarantee as to when, if ever, the background thread will see the change in the value of stopRequested made by the main thread. In the absence of synchronization, it\u2019s quite acceptable for the virtual machine to transform this code:"),(0,o.kt)("p",null,"\u95ee\u9898\u5728\u4e8e\u5728\u7f3a\u4e4f\u540c\u6b65\u7684\u60c5\u51b5\u4e0b\uff0c\u65e0\u6cd5\u4fdd\u8bc1\u540e\u53f0\u7ebf\u7a0b\u4f55\u65f6\uff08\u5982\u679c\u6709\u7684\u8bdd\uff09\u770b\u5230\u4e3b\u7ebf\u7a0b\u6240\u505a\u7684 stopRequested \u503c\u7684\u66f4\u6539\u3002\u5728\u7f3a\u4e4f\u540c\u6b65\u7684\u60c5\u51b5\u4e0b\uff0c\u865a\u62df\u673a\u53ef\u4ee5\u5f88\u597d\u5730\u8f6c\u6362\u8fd9\u6bb5\u4ee3\u7801\uff1a"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"while (!stopRequested)\n    i++;\ninto this code:\nif (!stopRequested)\n    while (true)\n        i++;\n")),(0,o.kt)("p",null,"This optimization is known as hoisting, and it is precisely what the OpenJDK Server VM does. The result is a liveness failure: the program fails to make progress. One way to fix the problem is to synchronize access to the stopRequested field. This program terminates in about one second, as expected:"),(0,o.kt)("p",null,"\u8fd9\u79cd\u4f18\u5316\u79f0\u4e3a\u63d0\u5347\uff0c\u8fd9\u6b63\u662f OpenJDK \u670d\u52a1\u5668 VM \u6240\u505a\u7684\u3002\u7ed3\u679c\u662f\u6d3b\u6027\u5931\u8d25\uff1a\u7a0b\u5e8f\u65e0\u6cd5\u53d6\u5f97\u8fdb\u5c55\u3002\u89e3\u51b3\u6b64\u95ee\u9898\u7684\u4e00\u79cd\u65b9\u6cd5\u662f\u540c\u6b65\u5bf9 stopRequested \u5b57\u6bb5\u7684\u8bbf\u95ee\u3002\u7a0b\u5e8f\u5728\u5927\u7ea6\u4e00\u79d2\u5185\u7ed3\u675f\uff0c\u6b63\u5982\u9884\u671f\uff1a"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"// Properly synchronized cooperative thread termination\npublic class StopThread {\n    private static boolean stopRequested;\n\n    private static synchronized void requestStop() {\n        stopRequested = true;\n    }\n\n    private static synchronized boolean stopRequested() {\n        return stopRequested;\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread backgroundThread = new Thread(() -> {\n            int i = 0;\n            while (!stopRequested())\n            i++;\n        });\n\n        backgroundThread.start();\n        TimeUnit.SECONDS.sleep(1);\n        requestStop();\n    }\n}\n")),(0,o.kt)("p",null,"Note that both the write method (requestStop) and the read method (stop-Requested) are synchronized. It is not sufficient to synchronize only the write method! ",(0,o.kt)("strong",{parentName:"p"},"Synchronization is not guaranteed to work unless both read and write operations are synchronized.")," Occasionally a program that synchronizes only writes (or reads) may appear to work on some machines, but in this case, appearances are deceiving."),(0,o.kt)("p",null,"\u6ce8\u610f\uff0c\u5199\u65b9\u6cd5\uff08requestStop\uff09\u548c\u8bfb\u65b9\u6cd5\uff08stopRequested\uff09\u90fd\u662f\u540c\u6b65\u7684\u3002\u4ec5\u540c\u6b65\u5199\u65b9\u6cd5\u662f\u4e0d\u591f\u7684\uff01",(0,o.kt)("strong",{parentName:"p"},"\u9664\u975e\u8bfb\u548c\u5199\u64cd\u4f5c\u90fd\u540c\u6b65\uff0c\u5426\u5219\u4e0d\u80fd\u4fdd\u8bc1\u540c\u6b65\u5de5\u4f5c\u3002")," \u6709\u65f6\uff0c\u53ea\u540c\u6b65\u5199\uff08\u6216\u8bfb\uff09\u7684\u7a0b\u5e8f\u53ef\u80fd\u5728\u67d0\u4e9b\u673a\u5668\u4e0a\u663e\u793a\u6709\u6548\uff0c\u4f46\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u4e0d\u80fd\u8fd9\u4e48\u505a\u3002"),(0,o.kt)("p",null,"The actions of the synchronized methods in StopThread would be atomic even without synchronization. In other words, the synchronization on these methods is used solely for its communication effects, not for mutual exclusion. While the cost of synchronizing on each iteration of the loop is small, there is a correct alternative that is less verbose and whose performance is likely to be better. The locking in the second version of StopThread can be omitted if stopRequested is declared volatile. While the volatile modifier performs no mutual exclusion, it guarantees that any thread that reads the field will see the most recently written value:"),(0,o.kt)("p",null,"\u5373\u4f7f\u6ca1\u6709\u540c\u6b65\uff0cStopThread \u4e2d\u540c\u6b65\u65b9\u6cd5\u7684\u64cd\u4f5c\u4e5f\u662f\u539f\u5b50\u6027\u7684\u3002\u6362\u53e5\u8bdd\u8bf4\uff0c\u8fd9\u4e9b\u65b9\u6cd5\u7684\u540c\u6b65\u4ec5\u7528\u4e8e\u5176\u901a\u4fe1\u6548\u679c\uff0c\u800c\u4e0d\u662f\u4e92\u65a5\u3002\u867d\u7136\u5728\u5faa\u73af\u7684\u6bcf\u4e2a\u8fed\u4ee3\u4e0a\u540c\u6b65\u7684\u6210\u672c\u5f88\u5c0f\uff0c\u4f46\u662f\u6709\u4e00\u79cd\u6b63\u786e\u7684\u66ff\u4ee3\u65b9\u6cd5\uff0c\u5b83\u4e0d\u90a3\u4e48\u5197\u957f\uff0c\u800c\u4e14\u6027\u80fd\u53ef\u80fd\u66f4\u597d\u3002\u5982\u679c stopRequested \u58f0\u660e\u4e3a volatile\uff0c\u5219\u53ef\u4ee5\u7701\u7565 StopThread \u7684\u7b2c\u4e8c\u4e2a\u7248\u672c\u4e2d\u7684\u9501\u3002\u867d\u7136 volatile \u4fee\u9970\u7b26\u4e0d\u6267\u884c\u4e92\u65a5\uff0c\u4f46\u5b83\u4fdd\u8bc1\u4efb\u4f55\u8bfb\u53d6\u5b57\u6bb5\u7684\u7ebf\u7a0b\u90fd\u4f1a\u770b\u5230\u6700\u8fd1\u5199\u5165\u7684\u503c\uff1a"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"// Cooperative thread termination with a volatile field\npublic class StopThread {\n    private static volatile boolean stopRequested;\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread backgroundThread = new Thread(() -> {\n        int i = 0;\n        while (!stopRequested)\n            i++;\n    });\n\n    backgroundThread.start();\n    TimeUnit.SECONDS.sleep(1);\n    stopRequested = true;\n    }\n}\n")),(0,o.kt)("p",null,"You do have to be careful when using volatile. Consider the following method, which is supposed to generate serial numbers:"),(0,o.kt)("p",null,"\u5728\u4f7f\u7528 volatile \u65f6\u4e00\u5b9a\u8981\u5c0f\u5fc3\u3002\u8003\u8651\u4e0b\u9762\u7684\u65b9\u6cd5\uff0c\u5b83\u5e94\u8be5\u751f\u6210\u5e8f\u5217\u53f7\uff1a"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"// Broken - requires synchronization!\nprivate static volatile int nextSerialNumber = 0;\n\npublic static int generateSerialNumber() {\n    return nextSerialNumber++;\n}\n")),(0,o.kt)("p",null,"The intent of the method is to guarantee that every invocation returns a unique value (so long as there are no more than 2",(0,o.kt)("sup",null,"32")," invocations). The method\u2019s state consists of a single atomically accessible field, nextSerialNumber, and all possible values of this field are legal. Therefore, no synchronization is necessary to protect its invariants. Still, the method won\u2019t work properly without synchronization."),(0,o.kt)("p",null,"\u8be5\u65b9\u6cd5\u7684\u76ee\u7684\u662f\u786e\u4fdd\u6bcf\u6b21\u8c03\u7528\u8fd4\u56de\u4e00\u4e2a\u552f\u4e00\u7684\u503c\uff08\u53ea\u8981\u4e0d\u8d85\u8fc7 2",(0,o.kt)("sup",null,"32")," \u6b21\u8c03\u7528\uff09\u3002\u65b9\u6cd5\u7684\u72b6\u6001\u7531\u4e00\u4e2a\u539f\u5b50\u53ef\u8bbf\u95ee\u7684\u5b57\u6bb5 nextSerialNumber \u7ec4\u6210\uff0c\u8be5\u5b57\u6bb5\u7684\u6240\u6709\u53ef\u80fd\u503c\u90fd\u662f\u5408\u6cd5\u7684\u3002\u56e0\u6b64\uff0c\u4e0d\u9700\u8981\u540c\u6b65\u6765\u4fdd\u62a4\u5b83\u7684\u4e0d\u53d8\u6027\u3002\u4e0d\u8fc7\uff0c\u5982\u679c\u6ca1\u6709\u540c\u6b65\uff0c\u8be5\u65b9\u6cd5\u5c06\u65e0\u6cd5\u6b63\u5e38\u5de5\u4f5c\u3002"),(0,o.kt)("p",null,"The problem is that the increment operator (++) is not atomic. It performs two operations on the nextSerialNumber field: first it reads the value, and then it writes back a new value, equal to the old value plus one. If a second thread reads the field between the time a thread reads the old value and writes back a new one, the second thread will see the same value as the first and return the same serial number. This is a safety failure: the program computes the wrong results."),(0,o.kt)("p",null,"\u95ee\u9898\u5728\u4e8e\u589e\u91cf\u8fd0\u7b97\u7b26 ",(0,o.kt)("inlineCode",{parentName:"p"},"(++)")," \u4e0d\u662f\u539f\u5b50\u6027\u7684\u3002\u5b83\u5bf9 nextSerialNumber \u5b57\u6bb5\u6267\u884c\u4e24\u4e2a\u64cd\u4f5c\uff1a\u9996\u5148\u8bfb\u53d6\u503c\uff0c\u7136\u540e\u8fd4\u56de\u4e00\u4e2a\u65b0\u503c\uff0c\u65e7\u503c\u518d\u52a0 1\u3002\u5982\u679c\u7b2c\u4e8c\u4e2a\u7ebf\u7a0b\u5728\u8bfb\u53d6\u65e7\u503c\u548c\u5199\u5165\u65b0\u503c\u4e4b\u95f4\u8bfb\u53d6\u5b57\u6bb5\uff0c\u5219\u7b2c\u4e8c\u4e2a\u7ebf\u7a0b\u5c06\u770b\u5230\u4e0e\u7b2c\u4e00\u4e2a\u7ebf\u7a0b\u76f8\u540c\u7684\u503c\uff0c\u5e76\u8fd4\u56de\u76f8\u540c\u7684\u5e8f\u5217\u53f7\u3002\u8fd9\u662f\u4e00\u4e2a\u5b89\u5168\u6545\u969c\uff1a\u4f7f\u7a0b\u5e8f\u8ba1\u7b97\u9519\u8bef\u7684\u539f\u56e0\u3002"),(0,o.kt)("p",null,"One way to fix generateSerialNumber is to add the synchronized modifier to its declaration. This ensures that multiple invocations won\u2019t be interleaved and that each invocation of the method will see the effects of all previous invocations. Once you\u2019ve done that, you can and should remove the volatile modifier from nextSerialNumber. To bulletproof the method, use long instead of int, or throw an exception if nextSerialNumber is about to wrap."),(0,o.kt)("p",null,"\u4fee\u590d generateSerialNumber \u7684\u4e00\u79cd\u65b9\u6cd5\u662f\u5c06 synchronized \u4fee\u9970\u7b26\u6dfb\u52a0\u5230\u5b83\u7684\u58f0\u660e\u4e2d\u3002\u8fd9\u786e\u4fdd\u4e86\u591a\u4e2a\u8c03\u7528\u4e0d\u4f1a\u4ea4\u53c9\uff0c\u5e76\u4e14\u8be5\u65b9\u6cd5\u7684\u6bcf\u6b21\u8c03\u7528\u90fd\u5c06\u770b\u5230\u4e4b\u524d\u6240\u6709\u8c03\u7528\u7684\u6548\u679c\u3002\u4e00\u65e6\u4f60\u8fd9\u6837\u505a\u4e86\uff0c\u4f60\u5c31\u53ef\u4ee5\u5e76\u4e14\u5e94\u8be5\u4ece nextSerialNumber \u4e2d\u5220\u9664 volatile \u4fee\u9970\u7b26\u3002\u4e3a\u4e86\u4f7f\u65b9\u6cd5\u66f4\u53ef\u9760\uff0c\u5e94\u4f7f\u7528 long \u800c\u4e0d\u662f int\uff0c\u6216\u8005\u5728 nextSerialNumber \u5373\u5c06\u8d85\u9650\u65f6\u629b\u51fa\u5f02\u5e38\u3002"),(0,o.kt)("p",null,"Better still, follow the advice in Item 59 and use the class AtomicLong, which is part of java.util.concurrent.atomic. This package provides primitives for lock-free, thread-safe programming on single variables. While volatile provides only the communication effects of synchronization, this package also provides atomicity. This is exactly what we want for generateSerialNumber, and it is likely to outperform the synchronized version:"),(0,o.kt)("p",null,"\u66f4\u597d\u7684\u65b9\u6cd5\u662f\uff0c\u9075\u5faa ",(0,o.kt)("a",{parentName:"p",href:"./Chapter-9-Item-59-Know-and-use-the-libraries"},"Item-59")," \u4e2d\u7684\u5efa\u8bae\u5e76\u4f7f\u7528 AtomicLong \u7c7b\uff0c\u5b83\u662f ",(0,o.kt)("inlineCode",{parentName:"p"},"java.util.concurrent.atomic")," \u7684\u4e00\u90e8\u5206\u3002\u8fd9\u4e2a\u5305\u4e3a\u5355\u53d8\u91cf\u7684\u65e0\u9501\u3001\u7ebf\u7a0b\u5b89\u5168\u7f16\u7a0b\u63d0\u4f9b\u4e86\u57fa\u672c\u7c7b\u578b\u3002\u867d\u7136 volatile \u53ea\u63d0\u4f9b\u540c\u6b65\u7684\u901a\u4fe1\u6548\u679c\uff0c\u4f46\u662f\u8fd9\u4e2a\u5305\u63d0\u4f9b\u539f\u5b50\u6027\u3002\u8fd9\u6b63\u662f\u6211\u4eec\u60f3\u8981\u7684 generateSerialNumber\uff0c\u5b83\u5f88\u53ef\u80fd\u4f18\u4e8e\u540c\u6b65\u7248\u672c\uff1a"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"// Lock-free synchronization with java.util.concurrent.atomic\nprivate static final AtomicLong nextSerialNum = new AtomicLong();\n\npublic static long generateSerialNumber() {\n    return nextSerialNum.getAndIncrement();\n}\n")),(0,o.kt)("p",null,"The best way to avoid the problems discussed in this item is not to share mutable data. Either share immutable data (Item 17) or don\u2019t share at all. In other words, ",(0,o.kt)("strong",{parentName:"p"},"confine mutable data to a single thread.")," If you adopt this policy, it is important to document it so that the policy is maintained as your program evolves. It is also important to have a deep understanding of the frameworks and libraries you\u2019re using because they may introduce threads that you are unaware of."),(0,o.kt)("p",null,"\u4e3a\u907f\u514d\u51fa\u73b0\u672c\u6761\u76ee\u4e2d\u8ba8\u8bba\u7684\u95ee\u9898\uff0c\u6700\u4f73\u65b9\u6cd5\u662f\u4e0d\u5171\u4eab\u53ef\u53d8\u6570\u636e\u3002\u8981\u4e48\u5171\u4eab\u4e0d\u53ef\u53d8\u6570\u636e\uff08",(0,o.kt)("a",{parentName:"p",href:"./Chapter-4-Item-17-Minimize-mutability"},"Item-17"),"\uff09\uff0c\u8981\u4e48\u5b8c\u5168\u4e0d\u5171\u4eab\u3002\u6362\u53e5\u8bdd\u8bf4\uff0c",(0,o.kt)("strong",{parentName:"p"},"\u5e94\u5f53\u5c06\u53ef\u53d8\u6570\u636e\u9650\u5236\u5728\u4e00\u4e2a\u7ebf\u7a0b\u4e2d\u3002")," \u5982\u679c\u91c7\u7528\u6b64\u7b56\u7565\uff0c\u91cd\u8981\u7684\u662f\u5bf9\u5176\u8fdb\u884c\u6587\u6863\u5316\uff0c\u4ee5\u4fbf\u968f\u7740\u7a0b\u5e8f\u7684\u53d1\u5c55\u7ef4\u62a4\u8be5\u7b56\u7565\u3002\u6df1\u5165\u4e86\u89e3\u4f60\u6b63\u5728\u4f7f\u7528\u7684\u6846\u67b6\u548c\u5e93\u4e5f\u5f88\u91cd\u8981\uff0c\u56e0\u4e3a\u5b83\u4eec\u53ef\u80fd\u4f1a\u5f15\u5165\u4f60\u4e0d\u77e5\u9053\u7684\u7ebf\u7a0b\u3002"),(0,o.kt)("p",null,"It is acceptable for one thread to modify a data object for a while and then to share it with other threads, synchronizing only the act of sharing the object reference. Other threads can then read the object without further synchronization, so long as it isn\u2019t modified again. Such objects are said to be effectively immutable ","[Goetz06, 3.5.4]",". Transferring such an object reference from one thread to others is called safe publication ","[Goetz06, 3.5.3]",". There are many ways to safely publish an object reference: you can store it in a static field as part of class initialization; you can store it in a volatile field, a final field, or a field that is accessed with normal locking; or you can put it into a concurrent collection (Item 81)."),(0,o.kt)("p",null,"\u4e00\u4e2a\u7ebf\u7a0b\u53ef\u4ee5\u6682\u65f6\u4fee\u6539\u4e00\u4e2a\u6570\u636e\u5bf9\u8c61\uff0c\u7136\u540e\u4e0e\u5176\u4ed6\u7ebf\u7a0b\u5171\u4eab\uff0c\u5e76\u4e14\u53ea\u540c\u6b65\u5171\u4eab\u5bf9\u8c61\u5f15\u7528\u7684\u64cd\u4f5c\u3002\u7136\u540e\uff0c\u5176\u4ed6\u7ebf\u7a0b\u53ef\u4ee5\u5728\u6ca1\u6709\u8fdb\u4e00\u6b65\u540c\u6b65\u7684\u60c5\u51b5\u4e0b\u8bfb\u53d6\u5bf9\u8c61\uff0c\u53ea\u8981\u4e0d\u518d\u6b21\u4fee\u6539\u8be5\u5bf9\u8c61\u3002\u8fd9\u4e9b\u5bf9\u8c61\u88ab\u8ba4\u4e3a\u662f\u6709\u6548\u4e0d\u53ef\u53d8\u7684 ","[Goetz06, 3.5.4]","\u3002\u5c06\u8fd9\u6837\u7684\u5bf9\u8c61\u5f15\u7528\u4ece\u4e00\u4e2a\u7ebf\u7a0b\u8f6c\u79fb\u5230\u5176\u4ed6\u7ebf\u7a0b\u79f0\u4e3a\u5b89\u5168\u53d1\u5e03 ","[Goetz06, 3.5.3]","\u3002\u5b89\u5168\u5730\u53d1\u5e03\u5bf9\u8c61\u5f15\u7528\u7684\u65b9\u6cd5\u6709\u5f88\u591a\uff1a\u53ef\u4ee5\u5c06\u5b83\u5b58\u50a8\u5728\u9759\u6001\u5b57\u6bb5\u4e2d\uff0c\u4f5c\u4e3a\u7c7b\u521d\u59cb\u5316\u7684\u4e00\u90e8\u5206\uff1b\u4f60\u53ef\u4ee5\u5c06\u5176\u5b58\u50a8\u5728\u6613\u5931\u6027\u5b57\u6bb5\u3001final \u5b57\u6bb5\u6216\u4f7f\u7528\u666e\u901a\u9501\u5b9a\u8bbf\u95ee\u7684\u5b57\u6bb5\u4e2d\uff1b\u6216\u8005\u4f60\u53ef\u4ee5\u5c06\u5176\u653e\u5165\u5e76\u53d1\u96c6\u5408\u4e2d\uff08",(0,o.kt)("a",{parentName:"p",href:"./Chapter-11/Chapter-11-Item-81-Prefer-concurrency-utilities-to-wait-and-notify"},"Item-81"),"\uff09\u3002"),(0,o.kt)("p",null,"In summary, ",(0,o.kt)("strong",{parentName:"p"},"when multiple threads share mutable data, each thread that reads or writes the data must perform synchronization.")," In the absence of synchronization, there is no guarantee that one thread\u2019s changes will be visible to another thread. The penalties for failing to synchronize shared mutable data are liveness and safety failures. These failures are among the most difficult to debug. They can be intermittent and timing-dependent, and program behavior can vary radically from one VM to another. If you need only inter-thread communication, and not mutual exclusion, the volatile modifier is an acceptable form of synchronization, but it can be tricky to use correctly."),(0,o.kt)("p",null,"\u603b\u4e4b\uff0c",(0,o.kt)("strong",{parentName:"p"},"\u5f53\u591a\u4e2a\u7ebf\u7a0b\u5171\u4eab\u53ef\u53d8\u6570\u636e\u65f6\uff0c\u6bcf\u4e2a\u8bfb\u53d6\u6216\u5199\u5165\u6570\u636e\u7684\u7ebf\u7a0b\u90fd\u5fc5\u987b\u6267\u884c\u540c\u6b65\u3002")," \u5728\u7f3a\u4e4f\u540c\u6b65\u7684\u60c5\u51b5\u4e0b\uff0c\u4e0d\u80fd\u4fdd\u8bc1\u4e00\u4e2a\u7ebf\u7a0b\u7684\u66f4\u6539\u5bf9\u53e6\u4e00\u4e2a\u7ebf\u7a0b\u53ef\u89c1\u3002\u540c\u6b65\u5171\u4eab\u53ef\u53d8\u6570\u636e\u5931\u8d25\u7684\u4ee3\u4ef7\u662f\u6d3b\u6027\u5931\u8d25\u548c\u5b89\u5168\u5931\u8d25\u3002\u8fd9\u4e9b\u6545\u969c\u662f\u6700\u96be\u8c03\u8bd5\u7684\u6545\u969c\u4e4b\u4e00\u3002\u5b83\u4eec\u53ef\u80fd\u662f\u95f4\u6b47\u6027\u7684\uff0c\u5e76\u4e0e\u65f6\u95f4\u76f8\u5173\uff0c\u800c\u4e14\u7a0b\u5e8f\u884c\u4e3a\u53ef\u80fd\u5728\u4e0d\u540c VM \u4e4b\u95f4\u53d1\u751f\u6839\u672c\u7684\u53d8\u5316\u3002\u5982\u679c\u53ea\u9700\u8981\u7ebf\u7a0b\u95f4\u901a\u4fe1\uff0c\u800c\u4e0d\u9700\u8981\u4e92\u65a5\uff0c\u90a3\u4e48 volatile \u4fee\u9970\u7b26\u662f\u4e00\u79cd\u53ef\u63a5\u53d7\u7684\u540c\u6b65\u5f62\u5f0f\uff0c\u4f46\u662f\u8981\u60f3\u6b63\u786e\u4f7f\u7528\u5b83\u53ef\u80fd\u4f1a\u6bd4\u8f83\u68d8\u624b\u3002"),(0,o.kt)("hr",null),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("a",{parentName:"strong",href:"./Chapter-11/Chapter-11-Introduction"},"Back to contents of the chapter\uff08\u8fd4\u56de\u7ae0\u8282\u76ee\u5f55\uff09"))),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Previous Item\uff08\u4e0a\u4e00\u6761\u76ee\uff09\uff1a",(0,o.kt)("a",{parentName:"strong",href:"./Chapter-10/Chapter-10-Item-77-Don%E2%80%99t-ignore-exceptions"},"Item 77: Don\u2019t ignore exceptions\uff08\u4e0d\u8981\u5ffd\u7565\u5f02\u5e38\uff09"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Next Item\uff08\u4e0b\u4e00\u6761\u76ee\uff09\uff1a",(0,o.kt)("a",{parentName:"strong",href:"./Chapter-11/Chapter-11-Item-79-Avoid-excessive-synchronization"},"Item 79: Avoid excessive synchronization\uff08\u907f\u514d\u8fc7\u5ea6\u540c\u6b65\uff09")))))}u.isMDXComponent=!0}}]);