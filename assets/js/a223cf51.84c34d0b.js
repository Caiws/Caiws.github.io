"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[7032],{3905:(e,t,r)=>{r.d(t,{Zo:()=>p,kt:()=>h});var a=r(7294);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function s(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function i(e,t){if(null==e)return{};var r,a,n=function(e,t){if(null==e)return{};var r,a,n={},o=Object.keys(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var l=a.createContext({}),c=function(e){var t=a.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):s(s({},t),e)),r},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,o=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),m=c(r),h=n,d=m["".concat(l,".").concat(h)]||m[h]||u[h]||o;return r?a.createElement(d,s(s({ref:t},p),{},{components:r})):a.createElement(d,s({ref:t},p))}));function h(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=r.length,s=new Array(o);s[0]=m;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:n,s[1]=i;for(var c=2;c<o;c++)s[c]=r[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,r)}m.displayName="MDXCreateElement"},1084:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var a=r(7462),n=(r(7294),r(3905));const o={},s=void 0,i={unversionedId:"Books/EffectiveJava3/Chapter-7/Chapter-7-Item-47-Prefer-Collection-to-Stream-as-a-return-type",id:"Books/EffectiveJava3/Chapter-7/Chapter-7-Item-47-Prefer-Collection-to-Stream-as-a-return-type",title:"Chapter-7-Item-47-Prefer-Collection-to-Stream-as-a-return-type",description:"Chapter 7. Lambdas and Streams\uff08\u03bb \u8868\u8fbe\u5f0f\u548c\u6d41\uff09",source:"@site/docs/Books/EffectiveJava3/Chapter-7/Chapter-7-Item-47-Prefer-Collection-to-Stream-as-a-return-type.md",sourceDirName:"Books/EffectiveJava3/Chapter-7",slug:"/Books/EffectiveJava3/Chapter-7/Chapter-7-Item-47-Prefer-Collection-to-Stream-as-a-return-type",permalink:"/docs/Books/EffectiveJava3/Chapter-7/Chapter-7-Item-47-Prefer-Collection-to-Stream-as-a-return-type",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Books/EffectiveJava3/Chapter-7/Chapter-7-Item-47-Prefer-Collection-to-Stream-as-a-return-type.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Chapter-7-Item-46-Prefer-side-effect-free-functions-in-streams",permalink:"/docs/Books/EffectiveJava3/Chapter-7/Chapter-7-Item-46-Prefer-side-effect-free-functions-in-streams"},next:{title:"Chapter-7-Item-48-Use-caution-when-making-streams-parallel",permalink:"/docs/Books/EffectiveJava3/Chapter-7/Chapter-7-Item-48-Use-caution-when-making-streams-parallel"}},l={},c=[{value:"Chapter 7. Lambdas and Streams\uff08\u03bb \u8868\u8fbe\u5f0f\u548c\u6d41\uff09",id:"chapter-7-lambdas-and-streams\u03bb-\u8868\u8fbe\u5f0f\u548c\u6d41",level:2},{value:"Item 47: Prefer Collection to Stream as a return type\uff08\u4f18\u5148\u9009\u62e9 Collection \u800c\u4e0d\u662f\u6d41\u4f5c\u4e3a\u8fd4\u56de\u7c7b\u578b\uff09",id:"item-47-prefer-collection-to-stream-as-a-return-type\u4f18\u5148\u9009\u62e9-collection-\u800c\u4e0d\u662f\u6d41\u4f5c\u4e3a\u8fd4\u56de\u7c7b\u578b",level:3}],p={toc:c};function u(e){let{components:t,...r}=e;return(0,n.kt)("wrapper",(0,a.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h2",{id:"chapter-7-lambdas-and-streams\u03bb-\u8868\u8fbe\u5f0f\u548c\u6d41"},"Chapter 7. Lambdas and Streams\uff08\u03bb \u8868\u8fbe\u5f0f\u548c\u6d41\uff09"),(0,n.kt)("h3",{id:"item-47-prefer-collection-to-stream-as-a-return-type\u4f18\u5148\u9009\u62e9-collection-\u800c\u4e0d\u662f\u6d41\u4f5c\u4e3a\u8fd4\u56de\u7c7b\u578b"},"Item 47: Prefer Collection to Stream as a return type\uff08\u4f18\u5148\u9009\u62e9 Collection \u800c\u4e0d\u662f\u6d41\u4f5c\u4e3a\u8fd4\u56de\u7c7b\u578b\uff09"),(0,n.kt)("p",null,"Many methods return sequences of elements. Prior to Java 8, the obvious return types for such methods were the collection interfaces Collection, Set, and List; Iterable; and the array types. Usually, it was easy to decide which of these types to return. The norm was a collection interface. If the method existed solely to enable for-each loops or the returned sequence couldn\u2019t be made to implement some Collection method (typically, contains(Object)), the Iterable interface was used. If the returned elements were primitive values or there were stringent performance requirements, arrays were used. In Java 8, streams were added to the platform, substantially complicating the task of choosing the appropriate return type for a sequence-returning method."),(0,n.kt)("p",null,"\u8bb8\u591a\u65b9\u6cd5\u90fd\u8fd4\u56de\u5143\u7d20\u5e8f\u5217\u3002\u5728 Java 8 \u4e4b\u524d\uff0c\u6b64\u7c7b\u65b9\u6cd5\u5e38\u89c1\u7684\u8fd4\u56de\u7c7b\u578b\u662f Collection \u96c6\u5408\u63a5\u53e3\uff0c\u5982 Set \u548c List\uff0c\u53e6\u5916\u8fd8\u6709 Iterable \u4ee5\u53ca\u6570\u7ec4\u7c7b\u578b\u3002\u901a\u5e38\uff0c\u5f88\u5bb9\u6613\u51b3\u5b9a\u4f7f\u7528\u54ea\u4e00\u79cd\u7c7b\u578b\u3002\u6807\u51c6\u662f\u4e00\u4e2a\u96c6\u5408\u63a5\u53e3\u3002\u5982\u679c\u65b9\u6cd5\u7684\u5b58\u5728\u4ec5\u4ec5\u662f\u4e3a\u4e86\u652f\u6301 for-each \u5faa\u73af\uff0c\u6216\u8005\u65e0\u6cd5\u4f7f\u8fd4\u56de\u7684\u5e8f\u5217\u5b9e\u73b0\u67d0\u4e2a\u96c6\u5408\u65b9\u6cd5\uff08\u901a\u5e38\u662f ",(0,n.kt)("inlineCode",{parentName:"p"},"contains(Object)"),"\uff09\uff0c\u5219\u4f7f\u7528 Iterable \u63a5\u53e3\u3002\u5982\u679c\u8fd4\u56de\u7684\u5143\u7d20\u662f\u57fa\u672c\u6570\u636e\u7c7b\u578b\u6216\u6709\u4e25\u683c\u7684\u6027\u80fd\u8981\u6c42\uff0c\u5219\u4f7f\u7528\u6570\u7ec4\u3002\u5728 Java 8 \u4e2d\uff0c\u6d41\u88ab\u6dfb\u52a0\u8fdb\u6765\uff0c\u8fd9\u5927\u5927\u589e\u52a0\u4e86\u4e3a\u5e8f\u5217\u8fd4\u56de\u65b9\u6cd5\u9009\u62e9\u9002\u5f53\u8fd4\u56de\u7c7b\u578b\u7684\u590d\u6742\u6027\u3002"),(0,n.kt)("p",null,"You may hear it said that streams are now the obvious choice to return a sequence of elements, but as discussed in Item 45, streams do not make iteration obsolete: writing good code requires combining streams and iteration judiciously. If an API returns only a stream and some users want to iterate over the returned sequence with a for-each loop, those users will be justifiably upset. It is especially frustrating because the Stream interface contains the sole abstract method in the Iterable interface, and Stream\u2019s specification for this method is compatible with Iterable\u2019s. The only thing preventing programmers from using a for-each loop to iterate over a stream is Stream\u2019s failure to extend Iterable."),(0,n.kt)("p",null,"\u4f60\u53ef\u80fd\u542c\u8bf4\u73b0\u5728\u6d41\u662f\u8fd4\u56de\u5143\u7d20\u5e8f\u5217\u7684\u660e\u663e\u9009\u62e9\uff0c\u4f46\u662f\u6b63\u5982 ",(0,n.kt)("a",{parentName:"p",href:"./Chapter-7-Item-45-Use-streams-judiciously"},"Item-45")," \u4e2d\u6240\u8ba8\u8bba\u7684\uff0c\u6d41\u4e0d\u4f1a\u8ba9\u8fed\u4ee3\u8fc7\u65f6\uff1a\u7f16\u5199\u597d\u7684\u4ee3\u7801\u9700\u8981\u660e\u667a\u5730\u5c06\u6d41\u548c\u8fed\u4ee3\u7ed3\u5408\u8d77\u6765\u3002\u5982\u679c\u4e00\u4e2a API \u53ea\u8fd4\u56de\u4e00\u4e2a\u6d41\uff0c\u800c\u4e00\u4e9b\u7528\u6237\u5e0c\u671b\u4f7f\u7528 for-each \u5faa\u73af\u904d\u5386\u8fd4\u56de\u7684\u5e8f\u5217\uff0c\u90a3\u4e48\u8fd9\u4e9b\u7528\u6237\u5c06\u4f1a\u611f\u5230\u4e0d\u9002\u3002\u8fd9\u5c24\u5176\u4ee4\u4eba\u6cae\u4e27\uff0c\u56e0\u4e3a\u6d41\u63a5\u53e3\u5305\u542b Iterable \u63a5\u53e3\u4e2d\u60df\u4e00\u7684\u62bd\u8c61\u65b9\u6cd5\uff0c\u800c\u4e14\u6d41\u5bf9\u8be5\u65b9\u6cd5\u7684\u89c4\u8303\u4e0e Iterable \u7684\u89c4\u8303\u517c\u5bb9\u3002\u552f\u4e00\u963b\u6b62\u7a0b\u5e8f\u5458\u4f7f\u7528 for-each \u5faa\u73af\u5728\u6d41\u4e0a\u8fed\u4ee3\u7684\u662f\u6d41\u4e0d\u80fd\u6269\u5c55 Iterable\u3002"),(0,n.kt)("p",null,"Sadly, there is no good workaround for this problem. At first glance, it might appear that passing a method reference to Stream\u2019s iterator method would work. The resulting code is perhaps a bit noisy and opaque, but not unreasonable:"),(0,n.kt)("p",null,"\u9057\u61be\u7684\u662f\uff0c\u8fd9\u4e2a\u95ee\u9898\u6ca1\u6709\u597d\u7684\u89e3\u51b3\u529e\u6cd5\u3002\u4e4d\u4e00\u770b\uff0c\u4f3c\u4e4e\u5c06\u65b9\u6cd5\u5f15\u7528\u4f20\u9012\u7ed9\u6d41\u7684 iterator \u65b9\u6cd5\u662f\u53ef\u884c\u7684\u3002\u751f\u6210\u7684\u4ee3\u7801\u53ef\u80fd\u6709\u70b9\u7e41\u7410\uff0c\u4e0d\u6613\u7406\u89e3\uff0c\u4f46\u5e76\u975e\u4e0d\u5408\u7406\uff1a"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"// Won't compile, due to limitations on Java's type inference\nfor (ProcessHandle ph : ProcessHandle.allProcesses()::iterator) {\n    // Process the process\n}\n")),(0,n.kt)("p",null,"Unfortunately, if you attempt to compile this code, you\u2019ll get an error message:"),(0,n.kt)("p",null,"\u4e0d\u5e78\u7684\u662f\uff0c\u5982\u679c\u4f60\u8bd5\u56fe\u7f16\u8bd1\u8fd9\u6bb5\u4ee3\u7801\uff0c\u4f60\u4f1a\u5f97\u5230\u4e00\u4e2a\u9519\u8bef\u6d88\u606f\uff1a"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"Test.java:6: error: method reference not expected here\nfor (ProcessHandle ph : ProcessHandle.allProcesses()::iterator) {\n^\n")),(0,n.kt)("p",null,"In order to make the code compile, you have to cast the method reference to an appropriately parameterized Iterable:"),(0,n.kt)("p",null,"\u4e3a\u4e86\u7f16\u8bd1\u4ee3\u7801\uff0c\u4f60\u5fc5\u987b\u5c06\u65b9\u6cd5\u5f15\u7528\u8f6c\u6362\u4e3a\u9002\u5f53\u53c2\u6570\u5316\u7684 Iterable\uff1a"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"// Hideous workaround to iterate over a stream\nfor (ProcessHandle ph : (Iterable<ProcessHandle>)ProcessHandle.allProcesses()::iterator)\n")),(0,n.kt)("p",null,"This client code works, but it is too noisy and opaque to use in practice. A better workaround is to use an adapter method. The JDK does not provide such a method, but it\u2019s easy to write one, using the same technique used in-line in the snippets above. Note that no cast is necessary in the adapter method because Java\u2019s type inference works properly in this context:"),(0,n.kt)("p",null,"\u8fd9\u4e2a\u5ba2\u6237\u7aef\u4ee3\u7801\u53ef\u4ee5\u5de5\u4f5c\uff0c\u4f46\u662f\u5b83\u592a\u8fc7\u7e41\u7410\u5e76\u4e0d\u6613\u7406\u89e3\uff0c\u65e0\u6cd5\u5728\u5b9e\u8df5\u4e2d\u4f7f\u7528\u3002\u66f4\u597d\u7684\u89e3\u51b3\u65b9\u6848\u662f\u4f7f\u7528\u9002\u914d\u5668\u65b9\u6cd5\u3002JDK \u6ca1\u6709\u63d0\u4f9b\u8fd9\u6837\u7684\u65b9\u6cd5\uff0c\u4f46\u662f\u4f7f\u7528\u4e0a\u9762\u4ee3\u7801\u7247\u6bb5\u4e2d\u4f7f\u7528\u7684\u5185\u8054\u6280\u672f\u7f16\u5199\u65b9\u6cd5\u5f88\u5bb9\u6613\u3002\u6ce8\u610f\uff0c\u9002\u914d\u5668\u65b9\u6cd5\u4e2d\u4e0d\u9700\u8981\u5f3a\u5236\u8f6c\u6362\uff0c\u56e0\u4e3a Java \u7684\u7c7b\u578b\u63a8\u65ad\u5728\u6b64\u4e0a\u4e0b\u6587\u4e2d\u5de5\u4f5c\u6b63\u5e38\uff1a"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"// Adapter from Stream<E> to Iterable<E>\npublic static <E> Iterable<E> iterableOf(Stream<E> stream) {\n    return stream::iterator;\n}\n")),(0,n.kt)("p",null,"With this adapter, you can iterate over any stream with a for-each statement:"),(0,n.kt)("p",null,"\u4f7f\u7528\u6b64\u9002\u914d\u5668\uff0c\u4f60\u53ef\u4ee5\u4f7f\u7528 for-each \u8bed\u53e5\u904d\u5386\u4efb\u4f55\u6d41\uff1a"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"for (ProcessHandle p : iterableOf(ProcessHandle.allProcesses())) {\n    // Process the process\n}\n")),(0,n.kt)("p",null,"Note that the stream versions of the Anagrams program in Item 34 use the Files.lines method to read the dictionary, while the iterative version uses a scanner. The Files.lines method is superior to a scanner, which silently swallows any exceptions encountered while reading the file. Ideally, we would have used Files.lines in the iterative version too. This is the sort of compromise that programmers will make if an API provides only stream access to a sequence and they want to iterate over the sequence with a for-each statement."),(0,n.kt)("p",null,"\u6ce8\u610f\uff0c",(0,n.kt)("a",{parentName:"p",href:"./Chapter-6-Item-34-Use-enums-instead-of-int-constants"},"Item-34")," \u4e2d Anagrams \u7a0b\u5e8f\u7684\u6d41\u7248\u672c\u4f7f\u7528 ",(0,n.kt)("inlineCode",{parentName:"p"},"Files.lines")," \u8bfb\u53d6\u5b57\u5178\uff0c\u800c\u8fed\u4ee3\u7248\u672c\u4f7f\u7528\u626b\u63cf\u5668\u3002",(0,n.kt)("inlineCode",{parentName:"p"},"Files.lines")," \u65b9\u6cd5\u4f18\u4e8e\u626b\u63cf\u5668\uff0c\u626b\u63cf\u5668\u5728\u8bfb\u53d6\u6587\u4ef6\u65f6\u9759\u9ed8\u5730\u63a5\u6536\u4efb\u4f55\u5f02\u5e38\u3002\u7406\u60f3\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u5728 ",(0,n.kt)("inlineCode",{parentName:"p"},"Files.lines")," \u7684\u8fed\u4ee3\u7248\u672c\u4e5f\u5e94\u8be5\u5982\u6b64\u3002\u5982\u679c\u4e00\u4e2a API \u53ea\u63d0\u4f9b\u5bf9\u4e00\u4e2a\u5e8f\u5217\u7684\u6d41\u8bbf\u95ee\uff0c\u800c\u7a0b\u5e8f\u5458\u5e0c\u671b\u7528 for-each \u8bed\u53e5\u904d\u5386\u8be5\u5e8f\u5217\uff0c\u90a3\u4e48\u8fd9\u662f\u7a0b\u5e8f\u5458\u4f1a\u505a\u51fa\u7684\u4e00\u79cd\u59a5\u534f\u3002"),(0,n.kt)("p",null,"Conversely, a programmer who wants to process a sequence using a stream pipeline will be justifiably upset by an API that provides only an Iterable. Again the JDK does not provide an adapter, but it\u2019s easy enough to write one:"),(0,n.kt)("p",null,"\u76f8\u53cd\uff0c\u5982\u679c\u7a0b\u5e8f\u5458\u5e0c\u671b\u4f7f\u7528\u6d41\u7ba1\u9053\u6765\u5904\u7406\u5e8f\u5217\uff0c\u90a3\u4e48\u53ea\u63d0\u4f9b\u53ef\u8fed\u4ee3\u7684 API \u5c31\u4f1a\u6709\u7406\u7531\u8ba9\u4ed6\u5fc3\u70e6\u3002JDK \u540c\u6837\u6ca1\u6709\u63d0\u4f9b\u9002\u914d\u5668\uff0c\u4f46\u662f\u7f16\u5199\u9002\u914d\u5668\u975e\u5e38\u7b80\u5355\uff1a"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"// Adapter from Iterable<E> to Stream<E>\npublic static <E> Stream<E> streamOf(Iterable<E> iterable) {\n    return StreamSupport.stream(iterable.spliterator(), false);\n}\n")),(0,n.kt)("p",null,"If you\u2019re writing a method that returns a sequence of objects and you know that it will only be used in a stream pipeline, then of course you should feel free to return a stream. Similarly, a method returning a sequence that will only be used for iteration should return an Iterable. But if you\u2019re writing a public API that returns a sequence, you should provide for users who want to write stream pipelines as well as those who want to write for-each statements, unless you have a good reason to believe that most of your users will want to use the same mechanism."),(0,n.kt)("p",null,"\u5982\u679c\u4f60\u6b63\u5728\u7f16\u5199\u4e00\u4e2a\u8fd4\u56de\u5bf9\u8c61\u5e8f\u5217\u7684\u65b9\u6cd5\uff0c\u5e76\u4e14\u4f60\u77e5\u9053\u5b83\u53ea\u4f1a\u5728\u6d41\u7ba1\u9053\u4e2d\u4f7f\u7528\uff0c\u90a3\u4e48\u4f60\u5f53\u7136\u5e94\u8be5\u53ef\u4ee5\u968f\u610f\u8fd4\u56de\u6d41\u3002\u7c7b\u4f3c\u5730\uff0c\u8fd4\u56de\u4ec5\u7528\u4e8e\u8fed\u4ee3\u7684\u5e8f\u5217\u7684\u65b9\u6cd5\u5e94\u8be5\u8fd4\u56de\u4e00\u4e2a Iterable\u3002\u4f46\u662f\u5982\u679c\u4f60\u5199\u4e00\u4e2a\u516c\u5171 API\uff0c\u5b83\u8fd4\u56de\u4e00\u4e2a\u5e8f\u5217\uff0c\u4f60\u5e94\u8be5\u517c\u987e\u60f3\u5199\u6d41\u7ba1\u9053\u4ee5\u53ca\u60f3\u5199 for-each \u8bed\u53e5\u7684\u7528\u6237\uff0c\u9664\u975e\u4f60\u6709\u5145\u5206\u7684\u7406\u7531\u76f8\u4fe1\u5927\u591a\u6570\u7528\u6237\u60f3\u8981\u4f7f\u7528\u76f8\u540c\u7684\u673a\u5236\u3002"),(0,n.kt)("p",null,"The Collection interface is a subtype of Iterable and has a stream method, so it provides for both iteration and stream access. Therefore, ",(0,n.kt)("strong",{parentName:"p"},"Collection or an appropriate subtype is generally the best return type for a public, sequence-returning method.")," Arrays also provide for easy iteration and stream access with the Arrays.asList and Stream.of methods. If the sequence you\u2019re returning is small enough to fit easily in memory, you\u2019re probably best off returning one of the standard collection implementations, such as ArrayList or HashSet. But ",(0,n.kt)("strong",{parentName:"p"},"do not store a large sequence in memory just to return it as a collection.")),(0,n.kt)("p",null,"Collection \u63a5\u53e3\u662f Iterable \u7684\u4e00\u4e2a\u5b50\u7c7b\u578b\uff0c\u5b83\u6709\u4e00\u4e2a\u6d41\u65b9\u6cd5\uff0c\u56e0\u6b64\u5b83\u63d0\u4f9b\u4e86\u8fed\u4ee3\u548c\u6d41\u4e24\u79cd\u8bbf\u95ee\u65b9\u5f0f\u3002\u56e0\u6b64\uff0c",(0,n.kt)("strong",{parentName:"p"},"Collection \u6216\u5176\u9002\u5f53\u7684\u5b50\u7c7b\u901a\u5e38\u662f\u516c\u5171\u5e8f\u5217\u8fd4\u56de\u65b9\u6cd5\u7684\u6700\u4f73\u8fd4\u56de\u7c7b\u578b\u3002")," \u6570\u7ec4\u8fd8\u63d0\u4f9b\u4e86\u4f7f\u7528 ",(0,n.kt)("inlineCode",{parentName:"p"},"Arrays.asList")," \u548c ",(0,n.kt)("inlineCode",{parentName:"p"},"Stream.of")," \u65b9\u6cd5\u8fdb\u884c\u7b80\u5355\u8fed\u4ee3\u548c\u6d41\u8bbf\u95ee\u3002\u5982\u679c\u8fd4\u56de\u7684\u5e8f\u5217\u8db3\u591f\u5c0f\uff0c\u53ef\u4ee5\u8f7b\u677e\u5730\u88c5\u5165\u5185\u5b58\uff0c\u90a3\u4e48\u6700\u597d\u8fd4\u56de\u6807\u51c6\u96c6\u5408\u5b9e\u73b0\u4e4b\u4e00\uff0c\u4f8b\u5982 ArrayList \u6216 HashSet\u3002\u4f46\u662f ",(0,n.kt)("strong",{parentName:"p"},"\u4e0d\u8981\u5c06\u4e00\u4e2a\u5927\u7684\u5e8f\u5217\u5b58\u50a8\u5728\u5185\u5b58\u4e2d\uff0c\u53ea\u662f\u4e3a\u4e86\u5c06\u5b83\u4f5c\u4e3a\u4e00\u4e2a\u96c6\u5408\u8fd4\u56de\u3002")),(0,n.kt)("p",null,"If the sequence you\u2019re returning is large but can be represented concisely, consider implementing a special-purpose collection. For example, suppose you want to return the power set of a given set, which consists of all of its subsets. The power set of {a, b, c} is {{}, {a}, {b}, {c}, {a, b}, {a, c}, {b, c}, {a, b, c}}. If a set has n elements, its power set has 2n. Therefore, you shouldn\u2019t even consider storing the power set in a standard collection implementation. It is, however, easy to implement a custom collection for the job with the help of AbstractList."),(0,n.kt)("p",null,"\u5982\u679c\u8fd4\u56de\u7684\u5e8f\u5217\u6bd4\u8f83\u5927\uff0c\u4f46\u662f\u53ef\u4ee5\u6709\u89c4\u5f8b\u5730\u8868\u793a\uff0c\u90a3\u4e48\u53ef\u4ee5\u8003\u8651\u5b9e\u73b0\u4e00\u4e2a\u7279\u6b8a\u7528\u9014\u7684\u96c6\u5408\u3002\u4f8b\u5982\uff0c\u5047\u8bbe\u4f60\u60f3\u8981\u8fd4\u56de\u7ed9\u5b9a\u96c6\u5408\u7684\u5e42\u96c6\uff0c\u8be5\u96c6\u5408\u7531\u5b83\u7684\u6240\u6709\u5b50\u96c6\u7ec4\u6210\u3002",(0,n.kt)("inlineCode",{parentName:"p"},"{a, b, c}")," \u7684\u6392\u5217\u7ec4\u5408\u6709 ",(0,n.kt)("inlineCode",{parentName:"p"},"{{}, {a}, {b}, {c}, {a, b}, {a, c}, {b, c}, {a, b, c}}"),"\u3002\u5982\u679c\u4e00\u4e2a\u96c6\u5408\u6709 n \u4e2a\u5143\u7d20\uff0c\u5b83\u7684\u5e42\u96c6\u6709 2",(0,n.kt)("sup",null,"n"),"\u3002\u56e0\u6b64\uff0c\u4f60\u751a\u81f3\u4e0d\u5e94\u8be5\u8003\u8651\u5728\u6807\u51c6\u96c6\u5408\u5b9e\u73b0\u4e2d\u5b58\u50a8\u5168\u90e8\u6392\u5217\u7ec4\u5408\u3002\u7136\u800c\uff0c\u5728 AbstractList \u7684\u5e2e\u52a9\u4e0b\uff0c\u53ef\u4ee5\u5f88\u5bb9\u6613\u5b9e\u73b0\u8fd9\u4e2a\u9700\u6c42\u7684\u81ea\u5b9a\u4e49\u96c6\u5408\u3002"),(0,n.kt)("p",null,"The trick is to use the index of each element in the power set as a bit vector, where the nth bit in the index indicates the presence or absence of the nth element from the source set. In essence, there is a natural mapping between the binary numbers from 0 to 2n \u2212 1 and the power set of an n-element set. Here\u2019s the code:"),(0,n.kt)("p",null,"\u8bc0\u7a8d\u662f\u4f7f\u7528\u7d22\u5f15\u5e42\u96c6\u7684\u6bcf\u4e2a\u5143\u7d20\u8bbe\u7f6e\u4e00\u4e2a\u4f4d\u5411\u91cf\uff0c\u5728\u8be5\u6307\u6570\u7684 n \u4f4d\u8868\u793a\u7b2c n \u4e2a\u5143\u7d20\u7684\u5b58\u5728\u4e0e\u5426\u4ece\u6e90\u3002\u5728\u672c\u8d28\u4e0a\uff0c\u4e4b\u95f4\u6709\u4e00\u4e2a\u81ea\u7136\u7684\u6620\u5c04\u4e8c\u8fdb\u5236\u6570\u5b57\u4ece 0 \u5230 2n\u22121 \u548c\u4e00\u7ec4 n \u5143\u7684\u5e42\u96c6\u3002\u8fd9\u662f\u4ee3\u7801\uff1a"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},'// Returns the power set of an input set as custom collection\npublic class PowerSet {\n    public static final <E> Collection<Set<E>> of(Set<E> s) {\n        List<E> src = new ArrayList<>(s);\n        if (src.size() > 30)\n            throw new IllegalArgumentException("Set too big " + s);\n\n        return new AbstractList<Set<E>>() {\n            @Override\n            public int size() {\n                return 1 << src.size(); // 2 to the power srcSize\n            }\n\n            @Override\n            public boolean contains(Object o) {\n                return o instanceof Set && src.containsAll((Set)o);\n            }\n\n            @Override\n            public Set<E> get(int index) {\n                Set<E> result = new HashSet<>();\n                for (int i = 0; index != 0; i++, index >>= 1)\n                    if ((index & 1) == 1)\n                        result.add(src.get(i));\n                return result;\n            }\n        };\n    }\n}\n')),(0,n.kt)("p",null,"Note that PowerSet.of throws an exception if the input set has more than 30 elements. This highlights a disadvantage of using Collection as a return type rather than Stream or Iterable: Collection has an int-returning size method, which limits the length of the returned sequence to Integer.MAX_VALUE, or 231 \u2212 1. The Collection specification does allow the size method to return 231 \u2212 1 if the collection is larger, even infinite, but this is not a wholly satisfying solution."),(0,n.kt)("p",null,"\u6ce8\u610f\uff0c\u5982\u679c\u8f93\u5165\u96c6\u5305\u542b\u8d85\u8fc7 30 \u4e2a\u5143\u7d20\uff0c",(0,n.kt)("inlineCode",{parentName:"p"},"PowerSet.of")," \u5c06\u629b\u51fa\u5f02\u5e38\u3002\u8fd9\u7a81\u51fa\u7684\u7f3a\u70b9\u4f7f\u7528 Collection \u4f5c\u4e3a\u8fd4\u56de\u7c7b\u578b\u800c\u4e0d\u662f\u6d41\u6216 Iterable\uff1a\u6536\u96c6 int-returning \u5927\u5c0f\u7684\u65b9\u6cd5,\u8fd9\u9650\u5236\u4e86 Integer.MAX_VALUE \u8fd4\u56de\u5e8f\u5217\u7684\u957f\u5ea6\uff0c\u6216 231\u22121\u3002\u6536\u96c6\u89c4\u8303\u5141\u8bb8\u5927\u5c0f\u65b9\u6cd5\u8fd4\u56de 231\u22121 \u5982\u679c\u96c6\u5408\u66f4\u5927\uff0c\u751a\u81f3\u662f\u65e0\u9650\u7684,\u4f46\u8fd9\u4e0d\u662f\u4e00\u4e2a\u5b8c\u5168\u4ee4\u4eba\u6ee1\u610f\u7684\u89e3\u51b3\u65b9\u6848\u3002"),(0,n.kt)("p",null,"In order to write a Collection implementation atop AbstractCollection, you need implement only two methods beyond the one required for Iterable: contains and size. Often it\u2019s easy to write efficient implementations of these methods. If it isn\u2019t feasible, perhaps because the contents of the sequence aren\u2019t predetermined before iteration takes place, return a stream or iterable, whichever feels more natural. If you choose, you can return both using two separate methods."),(0,n.kt)("p",null,"\u4e3a\u4e86\u5728 AbstractCollection \u4e4b\u4e0a\u7f16\u5199 Collection \u5b9e\u73b0\uff0c\u9664\u4e86 Iterable \u6240\u9700\u7684\u65b9\u6cd5\u5916\uff0c\u53ea\u9700\u8981\u5b9e\u73b0\u4e24\u4e2a\u65b9\u6cd5\uff1acontains \u548c size\u3002\u901a\u5e38\u5f88\u5bb9\u6613\u7f16\u5199\u8fd9\u4e9b\u65b9\u6cd5\u7684\u6709\u6548\u5b9e\u73b0\u3002\u5982\u679c\u5b83\u662f\u4e0d\u53ef\u884c\u7684\uff0c\u53ef\u80fd\u662f\u56e0\u4e3a\u5e8f\u5217\u7684\u5185\u5bb9\u5728\u8fed\u4ee3\u53d1\u751f\u4e4b\u524d\u6ca1\u6709\u9884\u5148\u786e\u5b9a\uff0c\u90a3\u4e48\u8fd4\u56de\u4e00\u4e2a\u6d41\u6216 iterable\uff0c\u4ee5\u611f\u89c9\u66f4\u81ea\u7136\u7684\u65b9\u5f0f\u8fd4\u56de\u3002\u5982\u679c\u4f60\u9009\u62e9\uff0c\u4f60\u53ef\u4ee5\u4f7f\u7528\u4e24\u4e2a\u4e0d\u540c\u7684\u65b9\u6cd5\u8fd4\u56de\u8fd9\u4e24\u4e2a\u503c\u3002"),(0,n.kt)("p",null,"There are times when you\u2019ll choose the return type based solely on ease of implementation. For example, suppose you want to write a method that returns all of the (contiguous) sublists of an input list. It takes only three lines of code to generate these sublists and put them in a standard collection, but the memory required to hold this collection is quadratic in the size of the source list. While this is not as bad as the power set, which is exponential, it is clearly unacceptable. Implementing a custom collection, as we did for the power set, would be tedious, more so because the JDK lacks a skeletal Iterator implementation to help us."),(0,n.kt)("p",null,"\u6709\u65f6\uff0c\u4f60\u5c06\u4ec5\u6839\u636e\u5b9e\u73b0\u7684\u6613\u7528\u6027\u6765\u9009\u62e9\u8fd4\u56de\u7c7b\u578b\u3002\u4f8b\u5982\uff0c\u5047\u8bbe\u4f60\u60f3\u7f16\u5199\u4e00\u4e2a\u8fd4\u56de\u8f93\u5165\u5217\u8868\u7684\u6240\u6709\uff08\u8fde\u7eed\u7684\uff09\u5b50\u5217\u8868\u7684\u65b9\u6cd5\u3002\u751f\u6210\u8fd9\u4e9b\u5b50\u5217\u8868\u5e76\u5c06\u5b83\u4eec\u653e\u5165\u6807\u51c6\u96c6\u5408\u4e2d\u53ea\u9700\u8981\u4e09\u884c\u4ee3\u7801\uff0c\u4f46\u662f\u4fdd\u5b58\u8be5\u96c6\u5408\u6240\u9700\u7684\u5185\u5b58\u662f\u6e90\u5217\u8868\u5927\u5c0f\u7684\u4e8c\u6b21\u65b9\u3002\u867d\u7136\u8fd9\u6ca1\u6709\u5e42\u96c6\u90a3\u4e48\u7cdf\u7cd5\uff0c\u5e42\u96c6\u662f\u6307\u6570\u7684\uff0c\u4f46\u663e\u7136\u662f\u4e0d\u53ef\u63a5\u53d7\u7684\u3002\u5b9e\u73b0\u81ea\u5b9a\u4e49\u96c6\u5408\uff08\u5c31\u50cf\u6211\u4eec\u4e3a power \u96c6\u6240\u505a\u7684\u90a3\u6837\uff09\u5c06\u4f1a\u975e\u5e38\u7e41\u7410\uff0c\u56e0\u4e3a JDK \u7f3a\u5c11\u4e00\u4e2a\u6846\u67b6\u8fed\u4ee3\u5668\u5b9e\u73b0\u6765\u5e2e\u52a9\u6211\u4eec\u3002"),(0,n.kt)("p",null,"It is, however, straightforward to implement a stream of all the sublists of an input list, though it does require a minor insight. Let\u2019s call a sublist that contains the first element of a list a prefix of the list. For example, the prefixes of (a, b, c) are (a), (a, b), and (a, b, c). Similarly, let\u2019s call a sublist that contains the last element a suffix, so the suffixes of (a, b, c) are (a, b, c), (b, c), and (c). The insight is that the sublists of a list are simply the suffixes of the prefixes (or identically, the prefixes of the suffixes) and the empty list. This observation leads directly to a clear, reasonably concise implementation:"),(0,n.kt)("p",null,"\u7136\u800c\uff0c\u5b9e\u73b0\u4e00\u4e2a\u8f93\u5165\u5217\u8868\u7684\u6240\u6709\u5b50\u5217\u8868\u7684\u6d41\u662f\u5f88\u7b80\u5355\u7684\uff0c\u5c3d\u7ba1\u5b83\u786e\u5b9e\u9700\u8981\u4e00\u4e9b\u6df1\u5165\u7684\u4e86\u89e3\u3002\u8ba9\u6211\u4eec\u5c06\u5305\u542b\u5217\u8868\u7684\u7b2c\u4e00\u4e2a\u5143\u7d20\u7684\u5b50\u5217\u8868\u79f0\u4e3a\u5217\u8868\u7684\u524d\u7f00\u3002\u4f8b\u5982\uff0c",(0,n.kt)("inlineCode",{parentName:"p"},"(a,b,c)")," \u7684\u524d\u7f00 ",(0,n.kt)("inlineCode",{parentName:"p"},"(a)"),"\u3001",(0,n.kt)("inlineCode",{parentName:"p"},"(a\u3001b)")," \u548c ",(0,n.kt)("inlineCode",{parentName:"p"},"(a,b,c)"),"\u3002\u7c7b\u4f3c\u5730\uff0c\u8ba9\u6211\u4eec\u8c03\u7528\u5305\u542b\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u540e\u7f00\u7684\u5b50\u5217\u8868\uff0c\u56e0\u6b64 ",(0,n.kt)("inlineCode",{parentName:"p"},"(a, b, c)")," \u7684\u540e\u7f00\u662f ",(0,n.kt)("inlineCode",{parentName:"p"},"(a, b, c)"),"\u3001",(0,n.kt)("inlineCode",{parentName:"p"},"(b, c)")," \u548c ",(0,n.kt)("inlineCode",{parentName:"p"},"(c)"),"\u3002\u6211\u4eec\u7684\u7406\u89e3\u662f\uff0c\u5217\u8868\u7684\u5b50\u5217\u8868\u4ec5\u4ec5\u662f\u524d\u7f00\u7684\u540e\u7f00\uff08\u6216\u540e\u7f00\u7684\u524d\u7f00\u76f8\u540c\uff09\u548c\u7a7a\u5217\u8868\u3002\u8fd9\u4e2a\u89c2\u5bdf\u76f4\u63a5\u5bfc\u81f4\u4e86\u4e00\u4e2a\u6e05\u6670\u3001\u5408\u7406\u3001\u7b80\u6d01\u7684\u5b9e\u73b0\uff1a"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"// Returns a stream of all the sublists of its input list\npublic class SubLists {\n    public static <E> Stream<List<E>> of(List<E> list) {\n        return Stream.concat(Stream.of(Collections.emptyList()),prefixes(list).flatMap(SubLists::suffixes));\n    }\n\n    private static <E> Stream<List<E>> prefixes(List<E> list) {\n        return IntStream.rangeClosed(1, list.size()).mapToObj(end -> list.subList(0, end));\n    }\n\n    private static <E> Stream<List<E>> suffixes(List<E> list) {\n        return IntStream.range(0, list.size()).mapToObj(start -> list.subList(start, list.size()));\n    }\n}\n")),(0,n.kt)("p",null,"Note that the Stream.concat method is used to add the empty list into the returned stream. Also note that the flatMap method (Item 45) is used to generate a single stream consisting of all the suffixes of all the prefixes. Finally, note that we generate the prefixes and suffixes by mapping a stream of consecutive int values returned by IntStream.range and IntStream.rangeClosed. This idiom is, roughly speaking, the stream equivalent of the standard for-loop on integer indices. Thus, our sublist implementation is similar in spirit to the obvious nested for-loop:"),(0,n.kt)("p",null,"\u6ce8\u610f ",(0,n.kt)("inlineCode",{parentName:"p"},"Stream.concat")," \u65b9\u6cd5\u5c06\u7a7a\u5217\u8868\u6dfb\u52a0\u5230\u8fd4\u56de\u7684\u6d41\u4e2d\u3002\u8fd8\u8981\u6ce8\u610f\uff0cflatMap \u65b9\u6cd5\uff08",(0,n.kt)("a",{parentName:"p",href:"./Chapter-7-Item-45-Use-streams-judiciously"},"Item-45"),"\uff09\u7528\u4e8e\u751f\u6210\u7531\u6240\u6709\u524d\u7f00\u7684\u6240\u6709\u540e\u7f00\u7ec4\u6210\u7684\u5355\u4e00\u6d41\u3002\u6700\u540e\uff0c\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u901a\u8fc7\u6620\u5c04\u7531 ",(0,n.kt)("inlineCode",{parentName:"p"},"IntStream.range")," \u548c ",(0,n.kt)("inlineCode",{parentName:"p"},"IntStream.rangeClosed")," \u8fd4\u56de\u7684\u8fde\u7eed int \u503c\u6d41\u6765\u751f\u6210\u524d\u7f00\u548c\u540e\u7f00\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u7684\u5b50\u5217\u8868\u5b9e\u73b0\u5728\u672c\u8d28\u4e0a\u7c7b\u4f3c\u4e8e\u5d4c\u5957\u7684 for \u5faa\u73af\uff1a"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"for (int start = 0; start < src.size(); start++)\n    for (int end = start + 1; end <= src.size(); end++)\n        System.out.println(src.subList(start, end));\n")),(0,n.kt)("p",null,"It is possible to translate this for-loop directly into a stream. The result is more concise than our previous implementation, but perhaps a bit less readable. It is similar in spirit to the streams code for the Cartesian product in Item 45:"),(0,n.kt)("p",null,"\u53ef\u4ee5\u5c06\u8fd9\u4e2a for \u5faa\u73af\u76f4\u63a5\u8f6c\u6362\u4e3a\u6d41\u3002\u7ed3\u679c\u6bd4\u6211\u4eec\u4ee5\u524d\u7684\u5b9e\u73b0\u66f4\u7b80\u6d01\uff0c\u4f46\u53ef\u8bfb\u6027\u53ef\u80fd\u7a0d\u5dee\u3002\u5b83\u5728\u5f62\u6001\u4e0a\u7c7b\u4f3c\u4e8e ",(0,n.kt)("a",{parentName:"p",href:"./Chapter-7-Item-45-Use-streams-judiciously"},"Item-45")," \u4e2d Cartesian \u7684 streams \u4ee3\u7801\uff1a"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"// Returns a stream of all the sublists of its input list\npublic static <E> Stream<List<E>> of(List<E> list) {\n    return IntStream.range(0, list.size())\n    .mapToObj(start ->\n    IntStream.rangeClosed(start + 1, list.size())\n    .mapToObj(end -> list.subList(start, end)))\n    .flatMap(x -> x);\n}\n")),(0,n.kt)("p",null,"Like the for-loop that precedes it, this code does not emit the empty list. In order to fix this deficiency, you could either use concat, as we did in the previous version, or replace 1 by (int) Math.signum(start) in the rangeClosed call."),(0,n.kt)("p",null,"\u4e0e\u524d\u9762\u7684 for \u5faa\u73af\u4e00\u6837\uff0c\u8be5\u4ee3\u7801\u4e0d\u53d1\u51fa\u7a7a\u5217\u8868\u3002\u4e3a\u4e86\u4fee\u590d\u8fd9\u4e2a\u7f3a\u9677\uff0c\u4f60\u53ef\u4ee5\u4f7f\u7528 concat\uff0c\u5c31\u50cf\u6211\u4eec\u5728\u4e0a\u4e00\u4e2a\u7248\u672c\u4e2d\u6240\u505a\u7684\u90a3\u6837\uff0c\u6216\u8005\u5728 rangeClosed \u8c03\u7528\u4e2d\u5c06 1 \u66ff\u6362\u4e3a ",(0,n.kt)("inlineCode",{parentName:"p"},"(int) Math.signum(start)"),"\u3002"),(0,n.kt)("p",null,"Either of these stream implementations of sublists is fine, but both will require some users to employ a Stream-to-Iterable adapter or to use a stream in places where iteration would be more natural. Not only does the Stream-to- Iterable adapter clutter up client code, but it slows down the loop by a factor of 2.3 on my machine. A purpose-built Collection implementation (not shown here) is considerably more verbose but runs about 1.4 times as fast as our stream-based implementation on my machine."),(0,n.kt)("p",null,"\u5b50\u5217\u8868\u7684\u8fd9\u4e24\u79cd\u6d41\u5b9e\u73b0\u90fd\u53ef\u4ee5\uff0c\u4f46\u662f\u90fd\u9700\u8981\u4e00\u4e9b\u7528\u6237\u4f7f\u7528\u6d41\u5230\u8fed\u4ee3\u7684\u9002\u914d\u5668\uff0c\u6216\u8005\u5728\u8fed\u4ee3\u66f4\u81ea\u7136\u7684\u5730\u65b9\u4f7f\u7528\u6d41\u3002\u6d41\u5230\u8fed\u4ee3\u9002\u914d\u5668\u4e0d\u4ec5\u6253\u4e71\u4e86\u5ba2\u6237\u673a\u4ee3\u7801\uff0c\u800c\u4e14\u5728\u6211\u7684\u673a\u5668\u4e0a\uff0c\u5b83\u8fd8\u5c06\u5faa\u73af\u901f\u5ea6\u964d\u4f4e\u4e86 2.3 \u500d\u3002\u4e13\u95e8\u6784\u5efa\u7684\u96c6\u5408\u5b9e\u73b0\uff08\u8fd9\u91cc\u6ca1\u6709\u663e\u793a\uff09\u975e\u5e38\u5197\u957f\uff0c\u4f46\u662f\u8fd0\u884c\u901f\u5ea6\u662f\u6211\u7684\u673a\u5668\u4e0a\u57fa\u4e8e\u6d41\u7684\u5b9e\u73b0\u7684 1.4 \u500d\u3002"),(0,n.kt)("p",null,"In summary, when writing a method that returns a sequence of elements, remember that some of your users may want to process them as a stream while others may want to iterate over them. Try to accommodate both groups. If it\u2019s feasible to return a collection, do so. If you already have the elements in a collection or the number of elements in the sequence is small enough to justify creating a new one, return a standard collection such as ArrayList. Otherwise, consider implementing a custom collection as we did for the power set. If it isn\u2019t feasible to return a collection, return a stream or iterable, whichever seems more natural. If, in a future Java release, the Stream interface declaration is modified to extend Iterable, then you should feel free to return streams because they will allow for both stream processing and iteration."),(0,n.kt)("p",null,"\u603b\u4e4b\uff0c\u5728\u7f16\u5199\u8fd4\u56de\u5143\u7d20\u5e8f\u5217\u7684\u65b9\u6cd5\u65f6\uff0c\u8bf7\u8bb0\u4f4f\uff0c\u6709\u4e9b\u7528\u6237\u53ef\u80fd\u5e0c\u671b\u5c06\u5b83\u4eec\u4f5c\u4e3a\u6d41\u5904\u7406\uff0c\u800c\u6709\u4e9b\u7528\u6237\u53ef\u80fd\u5e0c\u671b\u5bf9\u5b83\u4eec\u8fdb\u884c\u8fed\u4ee3\u3002\u8bd5\u7740\u9002\u5e94\u8fd9\u4e24\u4e2a\u7fa4\u4f53\u3002\u5982\u679c\u53ef\u4ee5\u8fd4\u56de\u96c6\u5408\uff0c\u90a3\u4e48\u5c31\u8fd9\u6837\u505a\u3002\u5982\u679c\u4f60\u5df2\u7ecf\u5728\u4e00\u4e2a\u96c6\u5408\u4e2d\u62e5\u6709\u4e86\u5143\u7d20\uff0c\u6216\u8005\u5e8f\u5217\u4e2d\u7684\u5143\u7d20\u6570\u91cf\u8db3\u591f\u5c0f\uff0c\u53ef\u4ee5\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u5143\u7d20\uff0c\u90a3\u4e48\u8fd4\u56de\u4e00\u4e2a\u6807\u51c6\u96c6\u5408\uff0c\u4f8b\u5982 ArrayList \u3002\u5426\u5219\uff0c\u8bf7\u8003\u8651\u50cf\u5bf9 power \u96c6\u90a3\u6837\u5b9e\u73b0\u81ea\u5b9a\u4e49\u96c6\u5408\u3002\u5982\u679c\u8fd4\u56de\u96c6\u5408\u4e0d\u53ef\u884c\uff0c\u5219\u8fd4\u56de\u6d41\u6216 iterable\uff0c\u4ee5\u770b\u8d77\u6765\u66f4\u81ea\u7136\u7684\u65b9\u5f0f\u8fd4\u56de\u3002\u5982\u679c\u5728\u672a\u6765\u7684 Java \u7248\u672c\u4e2d\uff0c\u6d41\u63a5\u53e3\u58f0\u660e\u88ab\u4fee\u6539\u4e3a\u53ef\u8fed\u4ee3\u7684\uff0c\u90a3\u4e48\u4f60\u5e94\u8be5\u53ef\u4ee5\u968f\u610f\u8fd4\u56de\u6d41\uff0c\u56e0\u4e3a\u5b83\u4eec\u5c06\u5141\u8bb8\u6d41\u5904\u7406\u548c\u8fed\u4ee3\u3002"),(0,n.kt)("hr",null),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},(0,n.kt)("a",{parentName:"strong",href:"./Chapter-7-Introduction"},"Back to contents of the chapter\uff08\u8fd4\u56de\u7ae0\u8282\u76ee\u5f55\uff09"))),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Previous Item\uff08\u4e0a\u4e00\u6761\u76ee\uff09\uff1a",(0,n.kt)("a",{parentName:"strong",href:"./Chapter-7-Item-46-Prefer-side-effect-free-functions-in-streams"},"Item 46: Prefer side effect free functions in streams\uff08\u5728\u6d41\u4e2d\u4f7f\u7528\u65e0\u526f\u4f5c\u7528\u7684\u51fd\u6570\uff09"))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Next Item\uff08\u4e0b\u4e00\u6761\u76ee\uff09\uff1a",(0,n.kt)("a",{parentName:"strong",href:"./Chapter-7-Item-48-Use-caution-when-making-streams-parallel"},"Item 48: Use caution when making streams parallel\uff08\u8c28\u614e\u4f7f\u7528\u5e76\u884c\u6d41\uff09")))))}u.isMDXComponent=!0}}]);