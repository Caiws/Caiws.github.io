"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[4796],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>f});var s=a(7294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);t&&(s=s.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,s)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,s,n=function(e,t){if(null==e)return{};var a,s,n={},i=Object.keys(e);for(s=0;s<i.length;s++)a=i[s],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(s=0;s<i.length;s++)a=i[s],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var o=s.createContext({}),c=function(e){var t=s.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},p=function(e){var t=c(e.components);return s.createElement(o.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return s.createElement(s.Fragment,{},t)}},u=s.forwardRef((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,o=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=c(a),f=n,h=u["".concat(o,".").concat(f)]||u[f]||m[f]||i;return a?s.createElement(h,r(r({ref:t},p),{},{components:a})):s.createElement(h,r({ref:t},p))}));function f(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,r=new Array(i);r[0]=u;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l.mdxType="string"==typeof e?e:n,r[1]=l;for(var c=2;c<i;c++)r[c]=a[c];return s.createElement.apply(null,r)}return s.createElement.apply(null,a)}u.displayName="MDXCreateElement"},2986:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>r,default:()=>m,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var s=a(7462),n=(a(7294),a(3905));const i={},r=void 0,l={unversionedId:"Books/EffectiveJava3/Chapter-4/Chapter-4-Item-25-Limit-source-files-to-a-single-top-level-class",id:"Books/EffectiveJava3/Chapter-4/Chapter-4-Item-25-Limit-source-files-to-a-single-top-level-class",title:"Chapter-4-Item-25-Limit-source-files-to-a-single-top-level-class",description:"Chapter 4. Classes and Interfaces\uff08\u7c7b\u548c\u63a5\u53e3\uff09",source:"@site/docs/Books/EffectiveJava3/Chapter-4/Chapter-4-Item-25-Limit-source-files-to-a-single-top-level-class.md",sourceDirName:"Books/EffectiveJava3/Chapter-4",slug:"/Books/EffectiveJava3/Chapter-4/Chapter-4-Item-25-Limit-source-files-to-a-single-top-level-class",permalink:"/docs/Books/EffectiveJava3/Chapter-4/Chapter-4-Item-25-Limit-source-files-to-a-single-top-level-class",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Books/EffectiveJava3/Chapter-4/Chapter-4-Item-25-Limit-source-files-to-a-single-top-level-class.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Chapter-4-Item-24-Favor-static-member-classes-over-nonstatic",permalink:"/docs/Books/EffectiveJava3/Chapter-4/Chapter-4-Item-24-Favor-static-member-classes-over-nonstatic"},next:{title:"Chapter-5-Introduction",permalink:"/docs/Books/EffectiveJava3/Chapter-5/Chapter-5-Introduction"}},o={},c=[{value:"Chapter 4. Classes and Interfaces\uff08\u7c7b\u548c\u63a5\u53e3\uff09",id:"chapter-4-classes-and-interfaces\u7c7b\u548c\u63a5\u53e3",level:2},{value:"Item 25: Limit source files to a single top-level class\uff08\u6e90\u6587\u4ef6\u4ec5\u9650\u6709\u5355\u4e2a\u9876\u5c42\u7c7b\uff09",id:"item-25-limit-source-files-to-a-single-top-level-class\u6e90\u6587\u4ef6\u4ec5\u9650\u6709\u5355\u4e2a\u9876\u5c42\u7c7b",level:3}],p={toc:c};function m(e){let{components:t,...a}=e;return(0,n.kt)("wrapper",(0,s.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h2",{id:"chapter-4-classes-and-interfaces\u7c7b\u548c\u63a5\u53e3"},"Chapter 4. Classes and Interfaces\uff08\u7c7b\u548c\u63a5\u53e3\uff09"),(0,n.kt)("h3",{id:"item-25-limit-source-files-to-a-single-top-level-class\u6e90\u6587\u4ef6\u4ec5\u9650\u6709\u5355\u4e2a\u9876\u5c42\u7c7b"},"Item 25: Limit source files to a single top-level class\uff08\u6e90\u6587\u4ef6\u4ec5\u9650\u6709\u5355\u4e2a\u9876\u5c42\u7c7b\uff09"),(0,n.kt)("p",null,"While the Java compiler lets you define multiple top-level classes in a single source file, there are no benefits associated with doing so, and there are significant risks. The risks stem from the fact that defining multiple top-level classes in a source file makes it possible to provide multiple definitions for a class. Which definition gets used is affected by the order in which the source files are passed to the compiler. To make this concrete, consider this source file, which contains only a Main class that refers to members of two other top-level classes (Utensil and Dessert):"),(0,n.kt)("p",null,"\u867d\u7136 Java \u7f16\u8bd1\u5668\u5141\u8bb8\u4f60\u5728\u5355\u4e2a\u6e90\u6587\u4ef6\u4e2d\u5b9a\u4e49\u591a\u4e2a\u9876\u5c42\u7c7b\uff0c\u4f46\u8fd9\u6837\u505a\u6ca1\u6709\u4efb\u4f55\u597d\u5904\uff0c\u800c\u4e14\u5b58\u5728\u91cd\u5927\u98ce\u9669\u3002\u8fd9\u79cd\u98ce\u9669\u6e90\u4e8e\u8fd9\u6837\u4e00\u4e2a\u4e8b\u5b9e\uff1a\u5728\u6e90\u6587\u4ef6\u4e2d\u5b9a\u4e49\u591a\u4e2a\u9876\u5c42\u7c7b\u4f7f\u5f97\u4e3a\u4e00\u4e2a\u7c7b\u63d0\u4f9b\u591a\u4e2a\u5b9a\u4e49\u6210\u4e3a\u53ef\u80fd\u3002\u6240\u4f7f\u7528\u7684\u5b9a\u4e49\u53d7\u6e90\u6587\u4ef6\u4f20\u7ed9\u7f16\u8bd1\u5668\u7684\u987a\u5e8f\u7684\u5f71\u54cd\u3002\u8bf4\u5f97\u66f4\u5177\u4f53\u4e9b\uff0c\u8bf7\u8003\u8651\u8fd9\u4e2a\u6e90\u6587\u4ef6\uff0c\u5b83\u53ea\u5305\u542b\u4e00\u4e2a\u4e3b\u7c7b\uff0c\u8be5\u4e3b\u7c7b\u5f15\u7528\u53e6\u5916\u4e24\u4e2a\u9876\u5c42\u7c7b\u7684\u6210\u5458\uff08Utensil \u548c Dessert\uff09\uff1a"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"public class Main {\n    public static void main(String[] args) {\n        System.out.println(Utensil.NAME + Dessert.NAME);\n    }\n}\n")),(0,n.kt)("p",null,"Now suppose you define both Utensil and Dessert in a single source file named Utensil.java:"),(0,n.kt)("p",null,"\u73b0\u5728\u5047\u8bbe\u4f60\u5728\u4e00\u4e2a\u540d\u4e3a ",(0,n.kt)("inlineCode",{parentName:"p"},"Utensil.java")," \u7684\u6e90\u6587\u4ef6\u4e2d\u5b9a\u4e49\u4e86 Utensil \u7c7b\u548c Dessert \u7c7b\uff1a"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},'// Two classes defined in one file. Don\'t ever do this!\nclass Utensil {\n    static final String NAME = "pan";\n}\n\nclass Dessert {\n    static final String NAME = "cake";\n}\n')),(0,n.kt)("p",null,"Of course the main program prints pancake. Now suppose you accidentally make another source file named Dessert.java that defines the same two classes:"),(0,n.kt)("p",null,"\u5f53\u7136\uff0cmain \u65b9\u6cd5\u5e94\u8be5\u8f93\u51fa pancake\u3002\u73b0\u5728\u5047\u8bbe\u4f60\u610f\u5916\u5730\u5236\u4f5c\u4e86\u53e6\u4e00\u4e2a\u540d\u4e3a Dessert \u7684\u6e90\u6587\u4ef6\u3002java \u5b9a\u4e49\u4e86\u76f8\u540c\u7684\u4e24\u4e2a\u7c7b\uff1a"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},'// Two classes defined in one file. Don\'t ever do this!\nclass Utensil {\n    static final String NAME = "pot";\n}\n\nclass Dessert {\n    static final String NAME = "pie";\n}\n')),(0,n.kt)("p",null,"If you\u2019re lucky enough to compile the program with the command javac Main.java Dessert.java, the compilation will fail, and the compiler will tell you that you\u2019ve multiply defined the classes Utensil and Dessert. This is so because the compiler will first compile Main.java, and when it sees the reference to Utensil (which precedes the reference to Dessert), it will look in Utensil.java for this class and find both Utensil and Dessert. When the compiler encounters Dessert.java on the command line, it will pull in that file too, causing it to encounter both definitions of Utensil and Dessert."),(0,n.kt)("p",null,"\u5982\u679c\u4f60\u8db3\u591f\u5e78\u8fd0\uff0c\u4f7f\u7528 ",(0,n.kt)("inlineCode",{parentName:"p"},"javac Main.java Dessert.java")," \u547d\u4ee4\u7f16\u8bd1\u7a0b\u5e8f\u65f6\uff0c\u7f16\u8bd1\u5c06\u5931\u8d25\uff0c\u7f16\u8bd1\u5668\u5c06\u544a\u8bc9\u4f60\u591a\u91cd\u5b9a\u4e49\u4e86 Utensil \u548c Dessert\u3002\u8fd9\u662f\u56e0\u4e3a\u7f16\u8bd1\u5668\u5c06\u9996\u5148\u7f16\u8bd1 ",(0,n.kt)("inlineCode",{parentName:"p"},"Main.java"),"\uff0c\u5f53\u5b83\u770b\u5230\u5bf9 Utensil \u7684\u5f15\u7528\uff08\u5728\u5bf9 Dessert \u7684\u5f15\u7528\u4e4b\u524d\uff09\u65f6\uff0c\u5b83\u5c06\u5728 ",(0,n.kt)("inlineCode",{parentName:"p"},"Utensil.java")," \u4e2d\u67e5\u627e\u8fd9\u4e2a\u7c7b\uff0c\u5e76\u627e\u5230\u9910\u5177\u548c\u751c\u70b9\u3002\u5f53\u7f16\u8bd1\u5668\u5728\u547d\u4ee4\u884c\u4e0a\u9047\u5230 ",(0,n.kt)("inlineCode",{parentName:"p"},"Dessert.java")," \u65f6\uff0c\uff08\u7f16\u8bd1\u5668\uff09\u4e5f\u4f1a\u8f7d\u5165\u8be5\u6587\u4ef6\uff0c\u5bfc\u81f4\uff08\u7f16\u8bd1\u5668\uff09\u540c\u65f6\u9047\u5230 Utensil \u548c Dessert \u7684\u5b9a\u4e49\u3002"),(0,n.kt)("p",null,"If you compile the program with the command javac Main.java or javac Main.java Utensil.java, it will behave as it did before you wrote the Dessert.java file, printing pancake. But if you compile the program with the command javac Dessert.java Main.java, it will print potpie. The behavior of the program is thus affected by the order in which the source files are passed to the compiler, which is clearly unacceptable."),(0,n.kt)("p",null,"\u5982\u679c\u4f60\u4f7f\u7528\u547d\u4ee4 ",(0,n.kt)("inlineCode",{parentName:"p"},"javac Main.java")," \u6216 ",(0,n.kt)("inlineCode",{parentName:"p"},"javac Main.java Utensil.java")," \u7f16\u8bd1\u7a0b\u5e8f\uff0c\u5b83\u7684\u884c\u4e3a\u5c06\u4e0e\u7f16\u5199 ",(0,n.kt)("inlineCode",{parentName:"p"},"Dessert.java")," \u6587\u4ef6\uff08\u6253\u5370 pancake\uff09\u4e4b\u524d\u4e00\u6837\u3002\u4f46\u662f\u5982\u679c\u4f60\u4f7f\u7528\u547d\u4ee4 ",(0,n.kt)("inlineCode",{parentName:"p"},"javac Dessert.java Main.java")," \u7f16\u8bd1\u7a0b\u5e8f\uff0c\u5b83\u5c06\u6253\u5370 potpie\u3002\u56e0\u6b64\uff0c\u7a0b\u5e8f\u7684\u884c\u4e3a\u53d7\u5230\u6e90\u6587\u4ef6\u4f20\u9012\u7ed9\u7f16\u8bd1\u5668\u7684\u987a\u5e8f\u7684\u5f71\u54cd\uff0c\u8fd9\u663e\u7136\u662f\u4e0d\u53ef\u63a5\u53d7\u7684\u3002"),(0,n.kt)("p",null,"Fixing the problem is as simple as splitting the top-level classes (Utensil and Dessert, in the case of our example) into separate source files. If you are tempted to put multiple top-level classes into a single source file, consider using static member classes (Item 24) as an alternative to splitting the classes into separate source files. If the classes are subservient to another class, making them into static member classes is generally the better alternative because it enhances readability and makes it possible to reduce the accessibility of the classes by declaring them private (Item 15). Here is how our example looks with static member classes:"),(0,n.kt)("p",null,"\u4fee\u590d\u8fd9\u4e2a\u95ee\u9898\u975e\u5e38\u7b80\u5355\uff0c\u53ea\u9700\u5c06\u9876\u5c42\u7c7b\uff08\u5728\u6211\u4eec\u7684\u793a\u4f8b\u4e2d\u662f Utensil \u548c Dessert\uff09\u5206\u5272\u4e3a\u5355\u72ec\u7684\u6e90\u6587\u4ef6\u5373\u53ef\u3002\u5982\u679c\u4f60\u60f3\u5c06\u591a\u4e2a\u9876\u5c42\u7c7b\u653e\u5230\u4e00\u4e2a\u6e90\u6587\u4ef6\u4e2d\uff0c\u8bf7\u8003\u8651\u4f7f\u7528\u9759\u6001\u6210\u5458\u7c7b\uff08",(0,n.kt)("a",{parentName:"p",href:"./Chapter-4-Item-24-Favor-static-member-classes-over-nonstatic"},"Item-24"),"\uff09\u4f5c\u4e3a\u5c06\u7c7b\u5206\u5272\u4e3a\u5355\u72ec\u7684\u6e90\u6587\u4ef6\u7684\u66ff\u4ee3\u65b9\u6cd5\u3002\u5982\u679c\uff08\u591a\u4e2a\u9876\u5c42\u7c7b\uff09\u96b6\u5c5e\u4e8e\u53e6\u4e00\u4e2a\u7c7b\uff0c\u90a3\u4e48\u5c06\u5b83\u4eec\u8f6c\u6362\u6210\u9759\u6001\u6210\u5458\u7c7b\u901a\u5e38\u662f\u66f4\u597d\u7684\u9009\u62e9\uff0c\u56e0\u4e3a\u5b83\u589e\u5f3a\u4e86\u53ef\u8bfb\u6027\uff0c\u5e76\u901a\u8fc7\u58f0\u660e\u5b83\u4eec\u4e3a\u79c1\u6709\uff08",(0,n.kt)("a",{parentName:"p",href:"./Chapter-4-Item-15-Minimize-the-accessibility-of-classes-and-members"},"Item-15"),"\uff09\uff0c\u964d\u4f4e\u4e86\u7c7b\u7684\u53ef\u8bbf\u95ee\u6027\u3002\u4e0b\u9762\u662f\u6211\u4eec\u7684\u9759\u6001\u6210\u5458\u7c7b\u793a\u4f8b\u7684\u6837\u5b50\uff1a"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},'// Static member classes instead of multiple top-level classes\npublic class Test {\n\n    public static void main(String[] args) {\n        System.out.println(Utensil.NAME + Dessert.NAME);\n    }\n\n    private static class Utensil {\n        static final String NAME = "pan";\n    }\n\n    private static class Dessert {\n        static final String NAME = "cake";\n    }\n}\n')),(0,n.kt)("p",null,"The lesson is clear: Never put multiple top-level classes or interfaces in a single source file. Following this rule guarantees that you can\u2019t have multiple definitions for a single class at compile time. This in turn guarantees that the class files generated by compilation, and the behavior of the resulting program, are independent of the order in which the source files are passed to the compiler."),(0,n.kt)("p",null,"\u6559\u8bad\u5f88\u6e05\u695a\uff1a\u6c38\u8fdc\u4e0d\u8981\u5c06\u591a\u4e2a\u9876\u5c42\u7c7b\u6216\u63a5\u53e3\u653e\u5728\u4e00\u4e2a\u6e90\u6587\u4ef6\u4e2d\u3002\u9075\u5faa\u6b64\u89c4\u5219\u53ef\u4ee5\u786e\u4fdd\u5728\u7f16\u8bd1\u65f6\u5355\u4e2a\u7c7b\u4e0d\u4f1a\u62e5\u6709\u591a\u4e2a\u5b9a\u4e49\u3002\u8fd9\u53cd\u8fc7\u6765\u4fdd\u8bc1\u4e86\u7f16\u8bd1\u6240\u751f\u6210\u7684\u7c7b\u6587\u4ef6\uff0c\u4ee5\u53ca\u7a0b\u5e8f\u7684\u884c\u4e3a\uff0c\u4e0e\u6e90\u4ee3\u7801\u6587\u4ef6\u4f20\u9012\u7ed9\u7f16\u8bd1\u5668\u7684\u987a\u5e8f\u65e0\u5173\u3002"),(0,n.kt)("hr",null),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},(0,n.kt)("a",{parentName:"strong",href:"./Chapter-4-Introduction"},"Back to contents of the chapter\uff08\u8fd4\u56de\u7ae0\u8282\u76ee\u5f55\uff09"))),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Previous Item\uff08\u4e0a\u4e00\u6761\u76ee\uff09\uff1a",(0,n.kt)("a",{parentName:"strong",href:"./Chapter-4-Item-24-Favor-static-member-classes-over-nonstatic"},"Item 24: Favor static member classes over nonstatic\uff08\u9759\u6001\u6210\u5458\u7c7b\u4f18\u4e8e\u975e\u9759\u6001\u6210\u5458\u7c7b\uff09"))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Next Item\uff08\u4e0b\u4e00\u6761\u76ee\uff09\uff1a",(0,n.kt)("a",{parentName:"strong",href:"./Chapter-5-Introduction"},"Chapter 5 Introduction\uff08\u7ae0\u8282\u4ecb\u7ecd\uff09")))))}m.isMDXComponent=!0}}]);