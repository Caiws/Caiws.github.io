"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[6381],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>d});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),p=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=p(e.components);return r.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(n),d=a,h=u["".concat(l,".").concat(d)]||u[d]||m[d]||i;return n?r.createElement(h,o(o({ref:t},c),{},{components:n})):r.createElement(h,o({ref:t},c))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var p=2;p<i;p++)o[p]=n[p];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},1696:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var r=n(7462),a=(n(7294),n(3905));const i={},o=void 0,s={unversionedId:"Books/EffectiveJava3/Chapter-5/Chapter-5-Item-30-Favor-generic-methods",id:"Books/EffectiveJava3/Chapter-5/Chapter-5-Item-30-Favor-generic-methods",title:"Chapter-5-Item-30-Favor-generic-methods",description:"Chapter 5. Generics\uff08\u6cdb\u578b\uff09",source:"@site/docs/Books/EffectiveJava3/Chapter-5/Chapter-5-Item-30-Favor-generic-methods.md",sourceDirName:"Books/EffectiveJava3/Chapter-5",slug:"/Books/EffectiveJava3/Chapter-5/Chapter-5-Item-30-Favor-generic-methods",permalink:"/docs/Books/EffectiveJava3/Chapter-5/Chapter-5-Item-30-Favor-generic-methods",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Books/EffectiveJava3/Chapter-5/Chapter-5-Item-30-Favor-generic-methods.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Chapter-5-Item-29-Favor-generic-types",permalink:"/docs/Books/EffectiveJava3/Chapter-5/Chapter-5-Item-29-Favor-generic-types"},next:{title:"Chapter-5-Item-31-Use-bounded-wildcards-to-increase-API-flexibility",permalink:"/docs/Books/EffectiveJava3/Chapter-5/Chapter-5-Item-31-Use-bounded-wildcards-to-increase-API-flexibility"}},l={},p=[{value:"Chapter 5. Generics\uff08\u6cdb\u578b\uff09",id:"chapter-5-generics\u6cdb\u578b",level:2},{value:"Item 30: Favor generic methods\uff08\u4f18\u5148\u4f7f\u7528\u6cdb\u578b\u65b9\u6cd5\uff09",id:"item-30-favor-generic-methods\u4f18\u5148\u4f7f\u7528\u6cdb\u578b\u65b9\u6cd5",level:3}],c={toc:p};function m(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"chapter-5-generics\u6cdb\u578b"},"Chapter 5. Generics\uff08\u6cdb\u578b\uff09"),(0,a.kt)("h3",{id:"item-30-favor-generic-methods\u4f18\u5148\u4f7f\u7528\u6cdb\u578b\u65b9\u6cd5"},"Item 30: Favor generic methods\uff08\u4f18\u5148\u4f7f\u7528\u6cdb\u578b\u65b9\u6cd5\uff09"),(0,a.kt)("p",null,"Just as classes can be generic, so can methods. Static utility methods that operate on parameterized types are usually generic. All of the \u201calgorithm\u201d methods in Collections (such as binarySearch and sort) are generic."),(0,a.kt)("p",null,"\u7c7b\u53ef\u4ee5\u662f\u6cdb\u578b\u7684\uff0c\u65b9\u6cd5\u4e5f\u53ef\u4ee5\u662f\u6cdb\u578b\u7684\u3002\u64cd\u4f5c\u53c2\u6570\u5316\u7c7b\u578b\u7684\u9759\u6001\u5b9e\u7528\u7a0b\u5e8f\u65b9\u6cd5\u901a\u5e38\u662f\u6cdb\u578b\u7684\u3002Collections \u7c7b\u4e2d\u7684\u6240\u6709\u300c\u7b97\u6cd5\u300d\u65b9\u6cd5\uff08\u5982 binarySearch \u548c sort\uff09\u90fd\u662f\u6cdb\u578b\u7684\u3002"),(0,a.kt)("p",null,"Writing generic methods is similar to writing generic types. Consider this deficient method, which returns the union of two sets:"),(0,a.kt)("p",null,"\u7f16\u5199\u6cdb\u578b\u65b9\u6cd5\u7c7b\u4f3c\u4e8e\u7f16\u5199\u6cdb\u578b\u7c7b\u578b\u3002\u8003\u8651\u8fd9\u4e2a\u6709\u7f3a\u9677\u7684\u65b9\u6cd5\uff0c\u5b83\u8fd4\u56de\u4e24\u4e2a\u96c6\u5408\u7684\u5e76\u96c6\uff1a"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"// Uses raw types - unacceptable! (Item 26)\npublic static Set union(Set s1, Set s2) {\n    Set result = new HashSet(s1);\n    result.addAll(s2);\n    return result;\n}\n")),(0,a.kt)("p",null,"This method compiles but with two warnings:"),(0,a.kt)("p",null,"\u8be5\u65b9\u6cd5\u53ef\u8fdb\u884c\u7f16\u8bd1\uff0c\u4f46\u6709\u4e24\u4e2a\u8b66\u544a\uff1a"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Union.java:5: warning: [unchecked] unchecked call to\nHashSet(Collection<? extends E>) as a member of raw type HashSet\n        Set result = new HashSet(s1);\n                      ^\n\nUnion.java:6: warning: [\nunchecked] unchecked call to\naddAll(Collection<? extends E>) as a member of raw type Set\n        result.addAll(s2);\n                      ^\n")),(0,a.kt)("p",null,"To fix these warnings and make the method typesafe, modify its declaration to declare a type parameter representing the element type for the three sets (the two arguments and the return value) and use this type parameter throughout the method. ",(0,a.kt)("strong",{parentName:"p"},"The type parameter list, which declares the type parameters, goes between a method\u2019s modifiers and its return type.")," In this example, the type parameter list is ",(0,a.kt)("inlineCode",{parentName:"p"},"<E>"),", and the return type is ",(0,a.kt)("inlineCode",{parentName:"p"},"Set<E>"),". The naming conventions for type parameters are the same for generic methods and generic types (Items 29, 68):"),(0,a.kt)("p",null,"\u8981\u4fee\u590d\u8fd9\u4e9b\u8b66\u544a\u5e76\u4f7f\u65b9\u6cd5\u7c7b\u578b\u5b89\u5168\uff0c\u8bf7\u4fee\u6539\u5176\u58f0\u660e\uff0c\u4ee5\u58f0\u660e\u8868\u793a\u4e09\u4e2a\u96c6\u5408\uff08\u4e24\u4e2a\u53c2\u6570\u548c\u8fd4\u56de\u503c\uff09\u7684\u5143\u7d20\u7c7b\u578b\u7684\u7c7b\u578b\u53c2\u6570\uff0c\u5e76\u5728\u6574\u4e2a\u65b9\u6cd5\u4e2d\u4f7f\u7528\u8be5\u7c7b\u578b\u53c2\u6570\u3002\u7c7b\u578b\u53c2\u6570\u5217\u8868\u58f0\u660e\u7c7b\u578b\u53c2\u6570\uff0c\u5b83\u4f4d\u4e8e\u65b9\u6cd5\u7684\u4fee\u9970\u7b26\u4e0e\u5176\u8fd4\u56de\u7c7b\u578b\u4e4b\u95f4\u3002\u5728\u672c\u4f8b\u4e2d\uff0c\u7c7b\u578b\u53c2\u6570\u5217\u8868\u4e3a ",(0,a.kt)("inlineCode",{parentName:"p"},"<E>"),"\uff0c\u8fd4\u56de\u7c7b\u578b\u4e3a ",(0,a.kt)("inlineCode",{parentName:"p"},"Set<E>"),"\u3002\u7c7b\u578b\u53c2\u6570\u7684\u547d\u540d\u7ea6\u5b9a\u4e0e\u6cdb\u578b\u65b9\u6cd5\u548c\u6cdb\u578b\u7c7b\u578b\u7684\u547d\u540d\u7ea6\u5b9a\u76f8\u540c\uff08",(0,a.kt)("a",{parentName:"p",href:"./Chapter-5-Item-29-Favor-generic-types"},"Item-29"),"\u3001",(0,a.kt)("a",{parentName:"p",href:"./Chapter-9-Item-68-Adhere-to-generally-accepted-naming-conventions"},"Item-68"),"\uff09:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"// Generic method\npublic static <E> Set<E> union(Set<E> s1, Set<E> s2) {\n    Set<E> result = new HashSet<>(s1);\n    result.addAll(s2);\n    return result;\n}\n")),(0,a.kt)("p",null,"At least for simple generic methods, that\u2019s all there is to it. This method compiles without generating any warnings and provides type safety as well as ease of use. Here\u2019s a simple program to exercise the method. This program contains no casts and compiles without errors or warnings:"),(0,a.kt)("p",null,"\u81f3\u5c11\u5bf9\u4e8e\u7b80\u5355\u7684\u6cdb\u578b\u65b9\u6cd5\uff0c\u8fd9\u5c31\u662f\uff08\u8981\u6ce8\u610f\u7ec6\u8282\u7684\uff09\u5168\u90e8\u3002\u8be5\u65b9\u6cd5\u7f16\u8bd1\u65f6\u4e0d\u751f\u6210\u4efb\u4f55\u8b66\u544a\uff0c\u5e76\u4e14\u63d0\u4f9b\u4e86\u7c7b\u578b\u5b89\u5168\u6027\u548c\u6613\u7528\u6027\u3002\u8fd9\u91cc\u6709\u4e00\u4e2a\u7b80\u5355\u7684\u7a0b\u5e8f\u6765\u6f14\u793a\u3002\u8fd9\u4e2a\u7a0b\u5e8f\u4e0d\u5305\u542b\u8f6c\u6362\uff0c\u7f16\u8bd1\u65f6\u6ca1\u6709\u9519\u8bef\u6216\u8b66\u544a\uff1a"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'// Simple program to exercise generic method\npublic static void main(String[] args) {\n    Set<String> guys = Set.of("Tom", "Dick", "Harry");\n    Set<String> stooges = Set.of("Larry", "Moe", "Curly");\n    Set<String> aflCio = union(guys, stooges);\n    System.out.println(aflCio);\n}\n')),(0,a.kt)("p",null,"When you run the program, it prints ","[Moe, Tom, Harry, Larry, Curly, Dick]",". (The order of the elements in the output is implementation-dependent.)"),(0,a.kt)("p",null,"\u5f53\u4f60\u8fd0\u884c\u7a0b\u5e8f\u65f6\uff0c\u5b83\u4f1a\u6253\u5370\u51fa ","[Moe, Tom, Harry, Larry, Curly, Dick]","\u3002\uff08\u8f93\u51fa\u5143\u7d20\u7684\u987a\u5e8f\u53ef\u80fd\u4e0d\u540c\uff09\u3002"),(0,a.kt)("p",null,"A limitation of the union method is that the types of all three sets (both input parameters and the return value) have to be exactly the same. You can make the method more flexible by using bounded wildcard types (Item 31)."),(0,a.kt)("p",null,"union \u65b9\u6cd5\u7684\u4e00\u4e2a\u9650\u5236\u662f\uff0c\u6240\u6709\u4e09\u4e2a\u96c6\u5408\uff08\u8f93\u5165\u53c2\u6570\u548c\u8fd4\u56de\u503c\uff09\u7684\u7c7b\u578b\u5fc5\u987b\u5b8c\u5168\u76f8\u540c\u3002\u4f60\u53ef\u4ee5\u901a\u8fc7\u4f7f\u7528\u6709\u754c\u901a\u914d\u7b26\u7c7b\u578b\uff08",(0,a.kt)("a",{parentName:"p",href:"./Chapter-5-Item-31-Use-bounded-wildcards-to-increase-API-flexibility"},"Item-31"),"\uff09\u4f7f\u65b9\u6cd5\u66f4\u52a0\u7075\u6d3b\u3002"),(0,a.kt)("p",null,"On occasion, you will need to create an object that is immutable but applicable to many different types. Because generics are implemented by erasure (Item 28), you can use a single object for all required type parameterizations, but you need to write a static factory method to repeatedly dole out the object for each requested type parameterization. This pattern, called the generic singleton factory, is used for function objects (Item 42) such as Collections.reverseOrder, and occasionally for collections such as Collections.emptySet."),(0,a.kt)("p",null,"\u6709\u65f6\uff0c\u4f60\u9700\u8981\u521b\u5efa\u4e00\u4e2a\u5bf9\u8c61\uff0c\u8be5\u5bf9\u8c61\u662f\u4e0d\u53ef\u53d8\u7684\uff0c\u4f46\u9002\u7528\u4e8e\u8bb8\u591a\u4e0d\u540c\u7c7b\u578b\u3002\u56e0\u4e3a\u6cdb\u578b\u662f\u7531\u64e6\u9664\uff08",(0,a.kt)("a",{parentName:"p",href:"./Chapter-5-Item-28-Prefer-lists-to-arrays"},"Item-28"),"\uff09\u5b9e\u73b0\u7684\uff0c\u6240\u4ee5\u4f60\u53ef\u4ee5\u4e3a\u6240\u6709\u9700\u8981\u7684\u7c7b\u578b\u53c2\u6570\u5316\u4f7f\u7528\u5355\u4e2a\u5bf9\u8c61\uff0c\u4f46\u662f\u4f60\u9700\u8981\u7f16\u5199\u4e00\u4e2a\u9759\u6001\u5de5\u5382\u65b9\u6cd5\uff0c\u4e3a\u6bcf\u4e2a\u8bf7\u6c42\u7684\u7c7b\u578b\u53c2\u6570\u5316\u91cd\u590d\u5206\u914d\u5bf9\u8c61\u3002\u8fd9\u79cd\u6a21\u5f0f\u79f0\u4e3a\u6cdb\u578b\u5355\u4f8b\u5de5\u5382\uff0c\u53ef\u7528\u4e8e\u51fd\u6570\u5bf9\u8c61\uff08",(0,a.kt)("a",{parentName:"p",href:"./Chapter-7-Item-42-Prefer-lambdas-to-anonymous-classes"},"Item-42"),"\uff09\uff0c\u5982 Collections.reverseOrder\uff0c\u5076\u5c14\u4e5f\u7528\u4e8e\u96c6\u5408\uff0c\u5982 Collections.emptySet\u3002"),(0,a.kt)("p",null,"Suppose that you want to write an identity function dispenser. The libraries provide Function.identity, so there\u2019s no reason to write your own (Item 59), but it is instructive. It would be wasteful to create a new identity function object time one is requested, because it\u2019s stateless. If Java\u2019s generics were reified, you would need one identity function per type, but since they\u2019re erased a generic singleton will suffice. Here\u2019s how it looks:"),(0,a.kt)("p",null,"\u5047\u8bbe\u4f60\u60f3\u8981\u7f16\u5199\u4e00\u4e2a\u6052\u7b49\u51fd\u6570\u5206\u53d1\u5668\u3002\u8fd9\u4e9b\u5e93\u63d0\u4f9b Function.identity\uff0c\u6240\u4ee5\u6ca1\u6709\u7406\u7531\u7f16\u5199\u81ea\u5df1\u7684\u5e93\uff08",(0,a.kt)("a",{parentName:"p",href:"./Chapter-9-Item-59-Know-and-use-the-libraries"},"Item-59"),"\uff09\uff0c\u4f46\u662f\u5b83\u5f88\u6709\u6307\u5bfc\u610f\u4e49\u3002\u5728\u8bf7\u6c42\u6807\u8bc6\u51fd\u6570\u5bf9\u8c61\u65f6\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u6807\u8bc6\u51fd\u6570\u5bf9\u8c61\u662f\u6d6a\u8d39\u65f6\u95f4\u7684\uff0c\u56e0\u4e3a\u5b83\u662f\u65e0\u72b6\u6001\u7684\u3002\u5982\u679c Java \u7684\u6cdb\u578b\u88ab\u5177\u4f53\u5316\u4e86\uff0c\u90a3\u4e48\u6bcf\u4e2a\u7c7b\u578b\u90fd\u9700\u8981\u4e00\u4e2a\u6807\u8bc6\u51fd\u6570\uff0c\u4f46\u662f\u7531\u4e8e\u5b83\u4eec\u5df2\u7ecf\u88ab\u64e6\u9664\uff0c\u4e00\u4e2a\u6cdb\u578b\u5355\u4f8b\u5c31\u8db3\u591f\u4e86\u3002\u5b83\u662f\u8fd9\u6837\u7684\uff1a"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'// Generic singleton factory pattern\nprivate static UnaryOperator<Object> IDENTITY_FN = (t) -> t;\n\n@SuppressWarnings("unchecked")\npublic static <T> UnaryOperator<T> identityFunction() {\n    return (UnaryOperator<T>) IDENTITY_FN;\n}\n')),(0,a.kt)("p",null,"The cast of IDENTITY_FN to (",(0,a.kt)("inlineCode",{parentName:"p"},"UnaryFunction<T>"),") generates an unchecked cast warning, as ",(0,a.kt)("inlineCode",{parentName:"p"},"UnaryOperator<Object>")," is not a ",(0,a.kt)("inlineCode",{parentName:"p"},"UnaryOperator<T>")," for every T. But the identity function is special: it returns its argument unmodified, so we know that it is typesafe to use it as a ",(0,a.kt)("inlineCode",{parentName:"p"},"UnaryFunction<T>"),", whatever the value of T. Therefore, we can confidently suppress the unchecked cast warning generated by this cast. Once we\u2019ve done this, the code compiles without error or warning."),(0,a.kt)("p",null,"IDENTITY_FN \u5230\uff08",(0,a.kt)("inlineCode",{parentName:"p"},"UnaryFunction<T>"),"\uff09\u7684\u8f6c\u6362\u4f1a\u751f\u6210\u4e00\u4e2a unchecked \u8f6c\u6362\u8b66\u544a\uff0c\u56e0\u4e3a ",(0,a.kt)("inlineCode",{parentName:"p"},"UnaryOperator<Object>")," \u5e76\u4e0d\u662f\u6bcf\u4e2a T \u90fd\u662f ",(0,a.kt)("inlineCode",{parentName:"p"},"UnaryOperator<T>"),"\uff0c\u4f46\u662f\u6052\u7b49\u51fd\u6570\u662f\u7279\u6b8a\u7684\uff1a\u5b83\u4f1a\u8fd4\u56de\u672a\u4fee\u6539\u7684\u53c2\u6570\uff0c\u6240\u4ee5\u6211\u4eec\u77e5\u9053\uff0c\u65e0\u8bba T \u7684\u503c\u662f\u591a\u5c11\uff0c\u90fd\u53ef\u4ee5\u5c06\u5176\u4f5c\u4e3a ",(0,a.kt)("inlineCode",{parentName:"p"},"UnaryFunction<T>")," \u4f7f\u7528\uff0c\u8fd9\u662f\u7c7b\u578b\u5b89\u5168\u7684\u3002\u4e00\u65e6\u6211\u4eec\u8fd9\u6837\u505a\u4e86\uff0c\u4ee3\u7801\u7f16\u8bd1\u5c31\u4e0d\u4f1a\u51fa\u73b0\u9519\u8bef\u6216\u8b66\u544a\u3002"),(0,a.kt)("p",null,"Here is a sample program that uses our generic singleton as a ",(0,a.kt)("inlineCode",{parentName:"p"},"UnaryOperator<String>")," and a ",(0,a.kt)("inlineCode",{parentName:"p"},"UnaryOperator<Number>"),". As usual, it contains no casts and compiles without errors or warnings:"),(0,a.kt)("p",null,"\u4e0b\u9762\u662f\u4e00\u4e2a\u793a\u4f8b\u7a0b\u5e8f\uff0c\u5b83\u4f7f\u7528\u6211\u4eec\u7684\u6cdb\u578b\u5355\u4f8b\u4f5c\u4e3a ",(0,a.kt)("inlineCode",{parentName:"p"},"UnaryOperator<String>")," \u548c ",(0,a.kt)("inlineCode",{parentName:"p"},"UnaryOperator<Number>"),"\u3002\u50cf\u5f80\u5e38\u4e00\u6837\uff0c\u5b83\u4e0d\u5305\u542b\u7c7b\u578b\u8f6c\u6362\u548c\u7f16\u8bd1\uff0c\u6ca1\u6709\u9519\u8bef\u6216\u8b66\u544a\uff1a"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'// Sample program to exercise generic singleton\npublic static void main(String[] args) {\n    String[] strings = { "jute", "hemp", "nylon" };\n    UnaryOperator<String> sameString = identityFunction();\n\n    for (String s : strings)\n        System.out.println(sameString.apply(s));\n\n    Number[] numbers = { 1, 2.0, 3L };\n    UnaryOperator<Number> sameNumber = identityFunction();\n\n    for (Number n : numbers)\n        System.out.println(sameNumber.apply(n));\n}\n')),(0,a.kt)("p",null,"It is permissible, though relatively rare, for a type parameter to be bounded by some expression involving that type parameter itself. This is what\u2019s known as a recursive type bound. A common use of recursive type bounds is in connection with the Comparable interface, which defines a type\u2019s natural ordering (Item 14). This interface is shown here:"),(0,a.kt)("p",null,"\u5141\u8bb8\u7c7b\u578b\u53c2\u6570\u88ab\u5305\u542b\u8be5\u7c7b\u578b\u53c2\u6570\u672c\u8eab\u7684\u8868\u8fbe\u5f0f\u9650\u5236\uff0c\u5c3d\u7ba1\u8fd9\u79cd\u60c5\u51b5\u6bd4\u8f83\u5c11\u89c1\u3002\u8fd9\u5c31\u662f\u6240\u8c13\u7684\u9012\u5f52\u7c7b\u578b\u9650\u5b9a\u3002\u9012\u5f52\u7c7b\u578b\u8fb9\u754c\u7684\u4e00\u4e2a\u5e38\u89c1\u7528\u6cd5\u662f\u4e0e Comparable \u63a5\u53e3\u76f8\u5173\u8054\uff0c\u540e\u8005\u5b9a\u4e49\u4e86\u7c7b\u578b\u7684\u81ea\u7136\u987a\u5e8f\uff08",(0,a.kt)("a",{parentName:"p",href:"./Chapter-3-Item-14-Consider-implementing-Comparable"},"Item-14"),"\uff09\u3002\u8be5\u754c\u9762\u5982\u4e0b\u56fe\u6240\u793a\uff1a"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"public interface Comparable<T> {\n    int compareTo(T o);\n}\n")),(0,a.kt)("p",null,"The type parameter T defines the type to which elements of the type implementing ",(0,a.kt)("inlineCode",{parentName:"p"},"Comparable<T>")," can be compared. In practice, nearly all types can be compared only to elements of their own type. So, for example, String implements ",(0,a.kt)("inlineCode",{parentName:"p"},"Comparable<String>"),", Integer implements ",(0,a.kt)("inlineCode",{parentName:"p"},"Comparable<Integer>"),", and so on."),(0,a.kt)("p",null,"\u7c7b\u578b\u53c2\u6570 T \u5b9a\u4e49\u4e86\u5b9e\u73b0 ",(0,a.kt)("inlineCode",{parentName:"p"},"Comparable<T>")," \u7684\u7c7b\u578b\u7684\u5143\u7d20\u53ef\u4ee5\u4e0e\u4e4b\u8fdb\u884c\u6bd4\u8f83\u7684\u7c7b\u578b\u3002\u5728\u5b9e\u8df5\u4e2d\uff0c\u51e0\u4e4e\u6240\u6709\u7c7b\u578b\u90fd\u53ea\u80fd\u4e0e\u5b83\u4eec\u81ea\u5df1\u7c7b\u578b\u7684\u5143\u7d20\u8fdb\u884c\u6bd4\u8f83\u3002\u4f8b\u5982\uff0cString \u5b9e\u73b0 ",(0,a.kt)("inlineCode",{parentName:"p"},"Comparable<String>"),"\uff0c Integer \u5b9e\u73b0 ",(0,a.kt)("inlineCode",{parentName:"p"},"Comparable<Integer>"),"\uff0c\u7b49\u7b49\u3002"),(0,a.kt)("p",null,"Many methods take a collection of elements implementing Comparable to sort it, search within it, calculate its minimum or maximum, and the like. To do these things, it is required that every element in the collection be comparable to every other element in it, in other words, that the elements of the list be mutually comparable. Here is how to express that constraint:"),(0,a.kt)("p",null,"\u8bb8\u591a\u65b9\u6cd5\u91c7\u7528\u5b9e\u73b0 Comparable \u7684\u5143\u7d20\u96c6\u5408\uff0c\u5728\u5176\u4e2d\u8fdb\u884c\u641c\u7d22\uff0c\u8ba1\u7b97\u5176\u6700\u5c0f\u503c\u6216\u6700\u5927\u503c\uff0c\u7b49\u7b49\u3002\u8981\u505a\u5230\u8fd9\u4e9b\uff0c\u9700\u8981\u96c6\u5408\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u4e0e\u96c6\u5408\u4e2d\u7684\u6bcf\u4e2a\u5176\u4ed6\u5143\u7d20\u76f8\u6bd4\u8f83\uff0c\u6362\u53e5\u8bdd\u8bf4\uff0c\u5c31\u662f\u5217\u8868\u4e2d\u7684\u5143\u7d20\u76f8\u4e92\u6bd4\u8f83\u3002\u4e0b\u9762\u662f\u5982\u4f55\u8868\u8fbe\u8fd9\u79cd\u7ea6\u675f\uff08\u7684\u793a\u4f8b\uff09\uff1a"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"// Using a recursive type bound to express mutual comparability\npublic static <E extends Comparable<E>> E max(Collection<E> c);\n")),(0,a.kt)("p",null,"The type bound ",(0,a.kt)("inlineCode",{parentName:"p"},"<E extends Comparable<E>>")," may be read as \u201cany type E that can be compared to itself,\u201d which corresponds more or less precisely to the notion of mutual comparability."),(0,a.kt)("p",null,"\u7c7b\u578b\u9650\u5b9a ",(0,a.kt)("inlineCode",{parentName:"p"},"<E extends Comparable<E>>")," \u53ef\u4ee5\u88ab\u7406\u89e3\u4e3a\u300c\u53ef\u4ee5\u4e0e\u81ea\u8eab\u8fdb\u884c\u6bd4\u8f83\u7684\u4efb\u4f55\u7c7b\u578b E\u300d\uff0c\u8fd9\u6216\u591a\u6216\u5c11\u4e0e\u76f8\u4e92\u53ef\u6bd4\u6027\u7684\u6982\u5ff5\u76f8\u5bf9\u5e94\u3002"),(0,a.kt)("p",null,"Here is a method to go with the previous declaration. It calculates the maximum value in a collection according to its elements\u2019 natural order, and it compiles without errors or warnings:"),(0,a.kt)("p",null,"\u4e0b\u9762\u662f\u4e00\u4e2a\u4e0e\u524d\u9762\u58f0\u660e\u76f8\u540c\u7684\u65b9\u6cd5\u3002\u5b83\u6839\u636e\u5143\u7d20\u7684\u81ea\u7136\u987a\u5e8f\u8ba1\u7b97\u96c6\u5408\u4e2d\u7684\u6700\u5927\u503c\uff0c\u7f16\u8bd1\u65f6\u6ca1\u6709\u9519\u8bef\u6216\u8b66\u544a\uff1a"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'// Returns max value in a collection - uses recursive type bound\npublic static <E extends Comparable<E>> E max(Collection<E> c) {\n    if (c.isEmpty())\n        throw new IllegalArgumentException("Empty collection");\n\n    E result = null;\n\n    for (E e : c)\n        if (result == null || e.compareTo(result) > 0)\n\n    result = Objects.requireNonNull(e);\n    return result;\n}\n')),(0,a.kt)("p",null,"Note that this method throws IllegalArgumentException if the list is empty. A better alternative would be to return an ",(0,a.kt)("inlineCode",{parentName:"p"},"Optional<E>")," (Item 55)."),(0,a.kt)("p",null,"\u6ce8\u610f\uff0c\u5982\u679c\u5217\u8868\u4e3a\u7a7a\uff0c\u8be5\u65b9\u6cd5\u5c06\u629b\u51fa IllegalArgumentException\u3002\u66f4\u597d\u7684\u9009\u62e9\u662f\u8fd4\u56de\u4e00\u4e2a ",(0,a.kt)("inlineCode",{parentName:"p"},"Optional<E>"),"\uff08",(0,a.kt)("a",{parentName:"p",href:"./Chapter-8-Item-55-Return-optionals-judiciously"},"Item-55"),"\uff09\u3002"),(0,a.kt)("p",null,"Recursive type bounds can get much more complex, but luckily they rarely do. If you understand this idiom, its wildcard variant (Item 31), and the simulated self-type idiom (Item 2), you\u2019ll be able to deal with most of the recursive type bounds you encounter in practice."),(0,a.kt)("p",null,"\u9012\u5f52\u7c7b\u578b\u9650\u5b9a\u53ef\u80fd\u4f1a\u53d8\u5f97\u590d\u6742\u5f97\u591a\uff0c\u4f46\u5e78\u8fd0\u7684\u662f\uff0c\u8fd9\u79cd\u60c5\u51b5\u5f88\u5c11\u3002\u5982\u679c\u4f60\u7406\u89e3\u8fd9\u4e2a\u4e60\u60ef\u7528\u6cd5\u3001\u5b83\u7684\u901a\u914d\u7b26\u53d8\u91cf\uff08",(0,a.kt)("a",{parentName:"p",href:"./Chapter-5-Item-31-Use-bounded-wildcards-to-increase-API-flexibility"},"Item-31"),"\uff09\u548c\u6a21\u62df\u7684\u81ea\u7c7b\u578b\u4e60\u60ef\u7528\u6cd5\uff08",(0,a.kt)("a",{parentName:"p",href:"./Chapter-2-Item-2-Consider-a-builder-when-faced-with-many-constructor-parameters"},"Item-2"),"\uff09\uff0c\u4f60\u5c31\u80fd\u591f\u5904\u7406\u5728\u5b9e\u8df5\u4e2d\u9047\u5230\u7684\u5927\u591a\u6570\u9012\u5f52\u7c7b\u578b\u9650\u5b9a\u3002"),(0,a.kt)("p",null,"In summary, generic methods, like generic types, are safer and easier to use than methods requiring their clients to put explicit casts on input parameters and return values. Like types, you should make sure that your methods can be used without casts, which often means making them generic. And like types, you should generify existing methods whose use requires casts. This makes life easier for new users without breaking existing clients (Item 26)."),(0,a.kt)("p",null,"\u603b\u4e4b\uff0c\u4e0e\u8981\u6c42\u5ba2\u6237\u7aef\u5bf9\u8f93\u5165\u53c2\u6570\u548c\u8fd4\u56de\u503c\u8fdb\u884c\u663e\u5f0f\u8f6c\u6362\u7684\u65b9\u6cd5\u76f8\u6bd4\uff0c\u6cdb\u578b\u65b9\u6cd5\u4e0e\u6cdb\u578b\u4e00\u6837\uff0c\u66f4\u5b89\u5168\u3001\u66f4\u5bb9\u6613\u4f7f\u7528\u3002\u4e0e\u7c7b\u578b\u4e00\u6837\uff0c\u4f60\u5e94\u8be5\u786e\u4fdd\u4f60\u7684\u65b9\u6cd5\u53ef\u4ee5\u5728\u4e0d\u4f7f\u7528\u7c7b\u578b\u8f6c\u6362\u7684\u60c5\u51b5\u4e0b\u4f7f\u7528\uff0c\u8fd9\u901a\u5e38\u610f\u5473\u7740\u8981\u4f7f\u5b83\u4eec\u5177\u6709\u901a\u7528\u6027\u3002\u4e0e\u7c7b\u578b\u7c7b\u4f3c\uff0c\u4f60\u5e94\u8be5\u5c06\u9700\u8981\u5f3a\u5236\u7c7b\u578b\u8f6c\u6362\u7684\u73b0\u6709\u65b9\u6cd5\u6cdb\u578b\u5316\u3002\u8fd9\u4f7f\u5f97\u65b0\u7528\u6237\u5728\u4e0d\u7834\u574f\u73b0\u6709\u5ba2\u6237\u7aef\u7684\u60c5\u51b5\u4e0b\u66f4\u5bb9\u6613\u4f7f\u7528\uff08",(0,a.kt)("a",{parentName:"p",href:"./Chapter-5-Item-26-Do-not-use-raw-types"},"Item-26"),"\uff09\u3002"),(0,a.kt)("hr",null),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("a",{parentName:"strong",href:"./Chapter-5-Introduction"},"Back to contents of the chapter\uff08\u8fd4\u56de\u7ae0\u8282\u76ee\u5f55\uff09"))),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Previous Item\uff08\u4e0a\u4e00\u6761\u76ee\uff09\uff1a",(0,a.kt)("a",{parentName:"strong",href:"./Chapter-5-Item-29-Favor-generic-types"},"Item 29: Favor generic types\uff08\u4f18\u5148\u4f7f\u7528\u6cdb\u578b\uff09"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Next Item\uff08\u4e0b\u4e00\u6761\u76ee\uff09\uff1a",(0,a.kt)("a",{parentName:"strong",href:"./Chapter-5-Item-31-Use-bounded-wildcards-to-increase-API-flexibility"},"Item 31: Use bounded wildcards to increase API flexibility\uff08\u4f7f\u7528\u6709\u754c\u901a\u914d\u7b26\u589e\u52a0 API \u7684\u7075\u6d3b\u6027\uff09")))))}m.isMDXComponent=!0}}]);