"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[7313],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var o=n(7294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,o,l=function(e,t){if(null==e)return{};var n,o,l={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var s=o.createContext({}),c=function(e){var t=o.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=c(e.components);return o.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},h=o.forwardRef((function(e,t){var n=e.components,l=e.mdxType,a=e.originalType,s=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),h=c(n),m=l,d=h["".concat(s,".").concat(m)]||h[m]||u[m]||a;return n?o.createElement(d,r(r({ref:t},p),{},{components:n})):o.createElement(d,r({ref:t},p))}));function m(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var a=n.length,r=new Array(a);r[0]=h;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:l,r[1]=i;for(var c=2;c<a;c++)r[c]=n[c];return o.createElement.apply(null,r)}return o.createElement.apply(null,n)}h.displayName="MDXCreateElement"},7382:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>c});var o=n(7462),l=(n(7294),n(3905));const a={},r=void 0,i={unversionedId:"Books/EffectiveJava3/Chapter-3/Chapter-3-Item-13-Override-clone-judiciously",id:"Books/EffectiveJava3/Chapter-3/Chapter-3-Item-13-Override-clone-judiciously",title:"Chapter-3-Item-13-Override-clone-judiciously",description:"Chapter 3. Methods Common to All Objects\uff08\u5bf9\u8c61\u7684\u901a\u7528\u65b9\u6cd5\uff09",source:"@site/docs/Books/EffectiveJava3/Chapter-3/Chapter-3-Item-13-Override-clone-judiciously.md",sourceDirName:"Books/EffectiveJava3/Chapter-3",slug:"/Books/EffectiveJava3/Chapter-3/Chapter-3-Item-13-Override-clone-judiciously",permalink:"/docs/Books/EffectiveJava3/Chapter-3/Chapter-3-Item-13-Override-clone-judiciously",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Books/EffectiveJava3/Chapter-3/Chapter-3-Item-13-Override-clone-judiciously.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Chapter-3-Item-12-Always-override-toString",permalink:"/docs/Books/EffectiveJava3/Chapter-3/Chapter-3-Item-12-Always-override-toString"},next:{title:"Chapter-3-Item-14-Consider-implementing-Comparable",permalink:"/docs/Books/EffectiveJava3/Chapter-3/Chapter-3-Item-14-Consider-implementing-Comparable"}},s={},c=[{value:"Chapter 3. Methods Common to All Objects\uff08\u5bf9\u8c61\u7684\u901a\u7528\u65b9\u6cd5\uff09",id:"chapter-3-methods-common-to-all-objects\u5bf9\u8c61\u7684\u901a\u7528\u65b9\u6cd5",level:2},{value:"Item 13: Override clone judiciously\uff08\u660e\u667a\u5730\u8986\u76d6 clone \u65b9\u6cd5\uff09",id:"item-13-override-clone-judiciously\u660e\u667a\u5730\u8986\u76d6-clone-\u65b9\u6cd5",level:3}],p={toc:c};function u(e){let{components:t,...n}=e;return(0,l.kt)("wrapper",(0,o.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h2",{id:"chapter-3-methods-common-to-all-objects\u5bf9\u8c61\u7684\u901a\u7528\u65b9\u6cd5"},"Chapter 3. Methods Common to All Objects\uff08\u5bf9\u8c61\u7684\u901a\u7528\u65b9\u6cd5\uff09"),(0,l.kt)("h3",{id:"item-13-override-clone-judiciously\u660e\u667a\u5730\u8986\u76d6-clone-\u65b9\u6cd5"},"Item 13: Override clone judiciously\uff08\u660e\u667a\u5730\u8986\u76d6 clone \u65b9\u6cd5\uff09"),(0,l.kt)("p",null,"The Cloneable interface was intended as a mixin interface (Item 20) for classes to advertise that they permit cloning. Unfortunately, it fails to serve this purpose. Its primary flaw is that it lacks a clone method, and Object\u2019s clone method is protected. You cannot, without resorting to reflection (Item 65), invoke clone on an object merely because it implements Cloneable. Even a reflective invocation may fail, because there is no guarantee that the object has an accessible clone method. Despite this flaw and many others, the facility is in reasonably wide use, so it pays to understand it. This item tells you how to implement a well-behaved clone method, discusses when it is appropriate to do so, and presents alternatives."),(0,l.kt)("p",null,"Cloneable \u63a5\u53e3\u7684\u76ee\u7684\u662f\u4f5c\u4e3a mixin \u63a5\u53e3\uff08",(0,l.kt)("a",{parentName:"p",href:"./Chapter-4-Item-20-Prefer-interfaces-to-abstract-classes"},"Item-20"),"\uff09\uff0c\u7528\u4e8e\u8ba9\u7c7b\u6765\u5ba3\u79f0\u5b83\u4eec\u5141\u8bb8\u514b\u9686\u3002\u4e0d\u5e78\u7684\u662f\uff0c\u5b83\u6ca1\u6709\u8fbe\u5230\u8fd9\u4e2a\u76ee\u7684\u3002\u5b83\u7684\u4e3b\u8981\u7f3a\u70b9\u662f\u7f3a\u5c11 clone \u65b9\u6cd5\uff0c\u5e76\u4e14 Object \u7c7b\u7684 clone \u65b9\u6cd5\u662f\u53d7\u4fdd\u62a4\u7684\u3002\u5982\u679c\u4e0d\u6c42\u52a9\u4e8e\u53cd\u5c04\uff08",(0,l.kt)("a",{parentName:"p",href:"./Chapter-9-Item-65-Prefer-interfaces-to-reflection"},"Item-65"),"\uff09\uff0c\u5c31\u4e0d\u80fd\u4ec5\u4ec5\u56e0\u4e3a\u5bf9\u8c61\u5b9e\u73b0\u4e86 Cloneable \u63a5\u53e3\u5c31\u80fd\u8c03\u7528 clone \u65b9\u6cd5\u3002\u5373\u4f7f\u53cd\u5c04\u8c03\u7528\u4e5f\u53ef\u80fd\u5931\u8d25\uff0c\u56e0\u4e3a\u4e0d\u80fd\u4fdd\u8bc1\u5bf9\u8c61\u5177\u6709\u53ef\u8bbf\u95ee\u7684 clone \u65b9\u6cd5\u3002\u5c3d\u7ba1\u5b58\u5728\u591a\u79cd\u7f3a\u9677\uff0c\u4f46\u8be5\u673a\u5236\u7684\u4f7f\u7528\u8303\u56f4\u76f8\u5f53\u5e7f\u6cdb\uff0c\u56e0\u6b64\u7406\u89e3\u5b83\u662f\u503c\u5f97\u7684\u3002\u672c\u6761\u76ee\u5c06\u544a\u8bc9\u4f60\u5982\u4f55\u5b9e\u73b0\u884c\u4e3a\u826f\u597d\u7684 clone \u65b9\u6cd5\uff0c\u8ba8\u8bba\u4ec0\u4e48\u65f6\u5019\u5e94\u8be5\u8fd9\u6837\u505a\uff0c\u5e76\u63d0\u4f9b\u66ff\u4ee3\u65b9\u6848\u3002"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"\u8bd1\u6ce8\uff1amixin \u63a5\u53e3\u5f88\u53ef\u80fd\u662f\u6307\u4e00\u79cd\u5e26\u6709\u5168\u90e8\u5b9e\u73b0\u6216\u8005\u90e8\u5206\u5b9e\u73b0\u7684\u63a5\u53e3\uff0c\u5176\u4e3b\u8981\u4f5c\u7528\u662f\uff1a\uff081\uff09\u66f4\u597d\u7684\u8fdb\u884c\u4ee3\u7801\u590d\u7528\uff1b\uff082\uff09\u95f4\u63a5\u5b9e\u73b0\u591a\u91cd\u7ee7\u627f\uff1b\uff083\uff09\u6269\u5c55\u529f\u80fd\u3002\u4e0e\u4f20\u7edf\u63a5\u53e3\u76f8\u6bd4\uff0c\u4f20\u7edf\u63a5\u53e3\u4e2d\u4e0d\u5e26\u5b9e\u73b0\uff0c\u800c mixin \u63a5\u53e3\u5e26\u6709\u5b9e\u73b0\u3002")),(0,l.kt)("p",null,"So what does Cloneable do, given that it contains no methods? It determines the behavior of Object\u2019s protected clone implementation: if a class implements Cloneable, Object\u2019s clone method returns a field-byfield copy of the object; otherwise it throws CloneNotSupportedException. This is a highly atypical use of interfaces and not one to be emulated. Normally, implementing an interface says something about what a class can do for its clients. In this case, it modifies the behavior of a protected method on a superclass."),(0,l.kt)("p",null,"\u65e2\u7136 Cloneable \u63a5\u53e3\u4e0d\u5305\u542b\u4efb\u4f55\u65b9\u6cd5\uff0c\u7528\u5b83\u6765\u505a\u4ec0\u4e48\u5462\uff1f\u5b83\u51b3\u5b9a\u4e86 Object \u7c7b\u53d7\u4fdd\u62a4\u7684 clone \u5b9e\u73b0\u7684\u884c\u4e3a\uff1a\u5982\u679c\u4e00\u4e2a\u7c7b\u5b9e\u73b0\u4e86 Cloneable \u63a5\u53e3\uff0cObject \u7c7b\u7684 clone \u65b9\u6cd5\u5219\u8fd4\u56de\u8be5\u7c7b\u5b9e\u4f8b\u7684\u9010\u5b57\u6bb5\u62f7\u8d1d\uff1b\u5426\u5219\u5b83\u4f1a\u629b\u51fa CloneNotSupportedException\u3002\u8fd9\u662f\u63a5\u53e3\u975e\u5e38\u4e0d\u5178\u578b\u7684\u4e00\u79cd\u4f7f\u7528\u65b9\u5f0f\uff0c\u4e0d\u5e94\u8be5\u6548\u4eff\u3002\u901a\u5e38\uff0c\u7c7b\u5b9e\u73b0\u63a5\u53e3\u53ef\u4ee5\u8868\u660e\u7c7b\u80fd\u591f\u4e3a\u5176\u5ba2\u6237\u7aef\u505a\u4e9b\u4ec0\u4e48\u3002\u5728\u672c\u4f8b\u4e2d\uff0c\u5b83\u4fee\u6539\u4e86\u8d85\u7c7b\u4e0a\u53d7\u4fdd\u62a4\u7684\u65b9\u6cd5\u7684\u884c\u4e3a\u3002"),(0,l.kt)("p",null,"Though the specification doesn\u2019t say it, in practice, a class implementing Cloneable is expected to provide a properly functioning public clone method. In order to achieve this, the class and all of its superclasses must obey a complex, unenforceable, thinly documented protocol. The resulting mechanism is fragile, dangerous, and extralinguistic: it creates objects without calling a constructor."),(0,l.kt)("p",null,"\u867d\u7136\u89c4\u8303\u6ca1\u6709\u8bf4\u660e\uff0c\u4f46\u662f\u5728\u5b9e\u8df5\u4e2d\uff0c\u5b9e\u73b0 Cloneable \u63a5\u53e3\u7684\u7c7b\u5e94\u8be5\u63d0\u4f9b\u4e00\u4e2a\u529f\u80fd\u6b63\u5e38\u7684\u516c\u5171 clone \u65b9\u6cd5\u3002\u4e3a\u4e86\u5b9e\u73b0\u8fd9\u4e00\u70b9\uff0c\u7c7b\u53ca\u5176\u6240\u6709\u8d85\u7c7b\u5fc5\u987b\u9075\u5b88\u590d\u6742\u7684\u3001\u4e0d\u53ef\u5f3a\u5236\u6267\u884c\u7684\u3001\u6587\u6863\u5f88\u5c11\u7684\u534f\u8bae\u3002\u4ea7\u751f\u7684\u673a\u5236\u662f\u8106\u5f31\u7684\u3001\u5371\u9669\u7684\u548c\u975e\u8bed\u8a00\u7684\uff1a\u5373\u5b83\u521b\u5efa\u5bf9\u8c61\u800c\u4e0d\u8c03\u7528\u6784\u9020\u51fd\u6570\u3002"),(0,l.kt)("p",null,"The general contract for the clone method is weak. Here it is, copied from the Object specification:"),(0,l.kt)("p",null,"clone \u65b9\u6cd5\u7684\u4e00\u822c\u7ea6\u5b9a\u5f88\u8584\u5f31\u3002\u4e0b\u9762\u7684\u5185\u5bb9\u662f\u4ece Object \u89c4\u8303\u590d\u5236\u8fc7\u6765\u7684\uff1a"),(0,l.kt)("hr",null),(0,l.kt)("p",null,"Creates and returns a copy of this object. The precise meaning of \u201ccopy\u201d may depend on the class of the object. The general intent is that, for any object x,the expression"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"x.clone() != x\n")),(0,l.kt)("p",null,"will be true, and the expression"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"x.clone().getClass() == x.getClass()\n")),(0,l.kt)("p",null,"will be true, but these are not absolute requirements. While it is typically the case that"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"x.clone().equals(x)\n")),(0,l.kt)("p",null,"will be true, this is not an absolute requirement."),(0,l.kt)("hr",null),(0,l.kt)("p",null,"clone \u65b9\u6cd5\u521b\u5efa\u5e76\u8fd4\u56de\u5bf9\u8c61\u7684\u526f\u672c\u3002\u300c\u526f\u672c\u300d\u7684\u786e\u5207\u542b\u4e49\u53ef\u80fd\u53d6\u51b3\u4e8e\u5bf9\u8c61\u7684\u7c7b\u522b\u3002\u901a\u5e38\uff0c\u5bf9\u4e8e\u4efb\u4f55\u5bf9\u8c61 x\uff0c\u8868\u8fbe\u5f0f ",(0,l.kt)("inlineCode",{parentName:"p"},"x.clone() != x"),"\u3001",(0,l.kt)("inlineCode",{parentName:"p"},"x.clone().getClass() == x.getClass()")," \u4ee5\u53ca ",(0,l.kt)("inlineCode",{parentName:"p"},"x.clone().equals(x)")," \u7684\u503c\u90fd\u5c06\u4e3a true\uff0c\u4f46\u90fd\u4e0d\u662f\u7edd\u5bf9\u7684\u3002"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"\u8bd1\u6ce8\uff1a\u4ee5\u4e0a\u60c5\u51b5\u7684 equals \u65b9\u6cd5\u5e94\u8986\u76d6\u9ed8\u8ba4\u5b9e\u73b0\uff0c\u6539\u4e3a\u6bd4\u8f83\u5bf9\u8c61\u4e2d\u7684\u5b57\u6bb5\u624d\u80fd\u5f97\u5230 true\u3002\u9ed8\u8ba4\u5b9e\u73b0\u662f\u6bd4\u8f83\u4e24\u4e2a\u5f15\u7528\u7c7b\u578b\u7684\u5185\u5b58\u5730\u5740\uff0c\u7ed3\u679c\u5fc5\u7136\u4e3a false")),(0,l.kt)("p",null,"By convention, the object returned by this method should be obtained by calling super.clone. If a class and all of its superclasses (except Object) obey this convention, it will be the case that"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"x.clone().getClass() == x.getClass().\n")),(0,l.kt)("p",null,"\u6309\u7167\u7ea6\u5b9a\uff0cclone \u65b9\u6cd5\u8fd4\u56de\u7684\u5bf9\u8c61\u5e94\u8be5\u901a\u8fc7\u8c03\u7528 super.clone() \u6765\u83b7\u5f97\u3002\u5982\u679c\u4e00\u4e2a\u7c7b\u548c\u5b83\u7684\u6240\u6709\u8d85\u7c7b\uff08Object \u7c7b\u9664\u5916\uff09\u90fd\u9075\u5b88\u8fd9\u4e2a\u7ea6\u5b9a\uff0c\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u8868\u8fbe\u5f0f ",(0,l.kt)("inlineCode",{parentName:"p"},"x.clone().getClass() == x.getClass()")," \u5219\u4e3a true"),(0,l.kt)("p",null,"By convention, the returned object should be independent of the object being cloned. To achieve this independence, it may be necessary to modify one or more fields of the object returned by super.clone before returning it."),(0,l.kt)("p",null,"\u6309\u7167\u7ea6\u5b9a\uff0c\u8fd4\u56de\u7684\u5bf9\u8c61\u5e94\u8be5\u72ec\u7acb\u4e8e\u88ab\u514b\u9686\u7684\u5bf9\u8c61\u3002\u4e3a\u4e86\u5b9e\u73b0\u8fd9\u79cd\u72ec\u7acb\u6027\uff0c\u53ef\u80fd\u9700\u8981\u5728 super.clone() \u8fd4\u56de\u524d\uff0c\u4fee\u6539\u5bf9\u8c61\u7684\u4e00\u4e2a\u6216\u591a\u4e2a\u5b57\u6bb5\u3002"),(0,l.kt)("p",null,"This mechanism is vaguely similar to constructor chaining, except that it isn\u2019t enforced: if a class\u2019s clone method returns an instance that is not obtained by calling super.clone but by calling a constructor, the compiler won\u2019t complain, but if a subclass of that class calls super.clone, the resulting object will have the wrong class, preventing the subclass from clone method from working properly. If a class that overrides clone is final, this convention may be safely ignored, as there are no subclasses to worry about. But if a final class has a clone method that does not invoke super.clone, there is no reason for the class to implement Cloneable, as it doesn\u2019t rely on the behavior of Object\u2019s clone implementation."),(0,l.kt)("p",null,"\u8fd9\u79cd\u673a\u5236\u6709\u70b9\u7c7b\u4f3c\u4e8e\u6784\u9020\u65b9\u6cd5\u94fe\uff0c\u53ea\u662f\u6ca1\u6709\u5f3a\u5236\u6267\u884c\uff1a"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"\uff081\uff09\u5982\u679c\u4e00\u4e2a\u7c7b\u7684 clone \u65b9\u6cd5\u8fd4\u56de\u7684\u5b9e\u4f8b\u4e0d\u662f\u901a\u8fc7\u8c03\u7528 super.clone() \u800c\u662f\u901a\u8fc7\u8c03\u7528\u6784\u9020\u51fd\u6570\u83b7\u5f97\u7684\uff0c\u7f16\u8bd1\u5668\u4e0d\u4f1a\u62a5\u9519\uff0c\u4f46\u662f\u5982\u679c\u8fd9\u4e2a\u7c7b\u7684\u4e00\u4e2a\u5b50\u7c7b\u8c03\u7528 super.clone()\uff0c\u7531\u6b64\u4ea7\u751f\u7684\u5bf9\u8c61\u7c7b\u578b\u5c06\u662f\u9519\u8bef\u7684\uff0c\u5f71\u54cd\u5b50\u7c7b clone \u65b9\u6cd5\u6b63\u5e38\u5de5\u4f5c\u3002"),(0,l.kt)("li",{parentName:"ul"},"\uff082\uff09\u5982\u679c\u8986\u76d6 clone \u65b9\u6cd5\u7684\u7c7b\u662f final \u4fee\u9970\u7684\uff0c\u90a3\u4e48\u53ef\u4ee5\u5b89\u5168\u5730\u5ffd\u7565\u8fd9\u4e2a\u7ea6\u5b9a\uff0c\u56e0\u4e3a\u6ca1\u6709\u5b50\u7c7b\u9700\u8981\u62c5\u5fc3\u3002"),(0,l.kt)("li",{parentName:"ul"},"\uff083\uff09\u5982\u679c\u4e00\u4e2a final \u4fee\u9970\u7684\u7c7b\u4e0d\u8c03\u7528 super.clone() \u7684 clone \u65b9\u6cd5\u3002\u7c7b\u6ca1\u6709\u7406\u7531\u5b9e\u73b0 Cloneable \u63a5\u53e3\uff0c\u56e0\u4e3a\u5b83\u4e0d\u4f9d\u8d56\u4e8e Object \u7c7b\u7684 clone \u5b9e\u73b0\u7684\u884c\u4e3a\u3002")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"\u8bd1\u6ce8\uff1a\u672c\u6bb5\u63cf\u8ff0\uff081\uff09\u7684\u4f8b\u5b50\u5982\u4e0b\uff0c\u8868\u8fbe\u5f0f ",(0,l.kt)("inlineCode",{parentName:"strong"},"x.clone().getClass() == x.getClass()")," \u503c\u4e3a false")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"class Base {\n    @Override protected Object clone() throws CloneNotSupportedException {\n        return new Base(); // \u2460\n    }\n}\n\nclass BasePro extends Base implements Cloneable {\n    @Override protected Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n    public static void main(String[] args) throws Exception {\n        BasePro basePro = new BasePro();\n        System.out.println(basePro.clone().getClass()); // \u8f93\u51fa class com.example.demo.Base\n        System.out.println(basePro.getClass()); // \u8f93\u51fa class com.example.demo.BasePro\n    }\n}\n")),(0,l.kt)("p",null,"\u53ef\u91c7\u7528\u4e24\u79cd\u65b9\u5f0f\u4fee\u590d"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"\u2460 \u5904\u6539\u7528 super.clone()"),(0,l.kt)("li",{parentName:"ul"},"\u79fb\u9664 Base \u7c7b\u6574\u4e2a clone() \u5b9e\u73b0")),(0,l.kt)("p",null,"Suppose you want to implement Cloneable in a class whose superclass provides a well-behaved clone method. First call super.clone. The object you get back will be a fully functional replica of the original. Any fields declared in your class will have values identical to those of the original. If every field contains a primitive value or a reference to an immutable object, the returned object may be exactly what you need, in which case no further processing is necessary. This is the case, for example, for the PhoneNumber class in Item 11, but note that ",(0,l.kt)("strong",{parentName:"p"},"immutable classes should never provide a clone method")," because it would merely encourage wasteful copying. With that caveat, here\u2019s how a clone method for PhoneNumber would look:"),(0,l.kt)("p",null,"\u5047\u8bbe\u4f60\u5e0c\u671b\u5728\u4e00\u4e2a\u7c7b\u4e2d\u5b9e\u73b0 Cloneable \u63a5\u53e3\uff0c\u8be5\u7c7b\u7684\u8d85\u7c7b\u63d0\u4f9b\u4e86\u4e00\u4e2a\u8868\u73b0\u826f\u597d\u7684 clone \u65b9\u6cd5\u3002\u9996\u5148\u8c03\u7528 super.clone()\u3002\u8fd4\u56de\u7684\u5bf9\u8c61\u5c06\u662f\u539f\u59cb\u5bf9\u8c61\u7684\u5b8c\u6574\u529f\u80fd\u526f\u672c\u3002\u7c7b\u4e2d\u58f0\u660e\u7684\u4efb\u4f55\u5b57\u6bb5\u90fd\u5177\u6709\u4e0e\u539f\u59cb\u5b57\u6bb5\u76f8\u540c\u7684\u503c\u3002\u5982\u679c\u6bcf\u4e2a\u5b57\u6bb5\u90fd\u5305\u542b\u4e00\u4e2a\u57fa\u672c\u7c7b\u578b\u6216\u5bf9\u4e0d\u53ef\u53d8\u5bf9\u8c61\u7684\u5f15\u7528\uff0c\u90a3\u4e48\u8fd4\u56de\u7684\u5bf9\u8c61\u53ef\u80fd\u6b63\u662f\u4f60\u6240\u9700\u8981\u7684\uff0c\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\u4e0d\u9700\u8981\u8fdb\u4e00\u6b65\u7684\u5904\u7406\u3002\u4f8b\u5982\uff0c\u5bf9\u4e8e",(0,l.kt)("a",{parentName:"p",href:"./Chapter-3-Item-11-Always-override-hashCode-when-you-override-equals"},"Item-11"),"\u4e2d\u7684 PhoneNumber \u7c7b\u5c31\u662f\u8fd9\u6837\uff0c\u4f46\u662f\u8981\u6ce8\u610f\uff0c",(0,l.kt)("strong",{parentName:"p"},"\u4e0d\u53ef\u53d8\u7c7b\u6c38\u8fdc\u4e0d\u5e94\u8be5\u63d0\u4f9b clone \u65b9\u6cd5"),"\uff0cbecause it would merely encourage wasteful copying. \u6709\u4e86\u8fd9\u4e2a\u8b66\u544a\uff0c\u4ee5\u4e0b\u662f PhoneNumber \u7c7b\u7684 clone \u65b9\u6cd5\u6982\u8c8c\uff1a"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"// Clone method for class with no references to mutable state\n@Override public PhoneNumber clone() {\n    try {\n        return (PhoneNumber) super.clone();\n    } catch (CloneNotSupportedException e) {\n        throw new AssertionError(); // Can't happen\n    }\n}\n")),(0,l.kt)("p",null,"In order for this method to work, the class declaration for PhoneNumber would have to be modified to indicate that it implements Cloneable. Though Object\u2019s clone method returns Object, this clone method returns PhoneNumber. It is legal and desirable to do this because Java supports covariant return types. In other words, an overriding method\u2019s return type can be a subclass of the overridden method\u2019s return type. This eliminates the need for casting in the client. We must cast the result of super.clone from Object to PhoneNumber before returning it, but the cast is guaranteed to succeed."),(0,l.kt)("p",null,"\u4e3a\u4e86\u8ba9\u8fd9\u4e2a\u65b9\u6cd5\u5de5\u4f5c\uff0c\u5fc5\u987b\u4fee\u6539 PhoneNumber \u7c7b\u7684\u58f0\u660e\uff0c\u4f7f\u4e4b\u5b9e\u73b0 Cloneable \u63a5\u53e3\u3002\u867d\u7136 Object \u7684 clone \u65b9\u6cd5\u8fd4\u56de Object \u7c7b\u578b\uff0c\u4f46\u662f\u8fd9\u4e2a clone \u65b9\u6cd5\u8fd4\u56de PhoneNumber \u7c7b\u578b\u3002\u8fd9\u6837\u505a\u662f\u5408\u6cd5\u7684\uff0c\u4e5f\u662f\u53ef\u53d6\u7684\uff0c\u56e0\u4e3a Java \u7684\u8fd4\u56de\u503c\u7c7b\u578b\u652f\u6301\u534f\u53d8\u3002\u6362\u53e5\u8bdd\u8bf4\uff0c\u8986\u76d6\u65b9\u6cd5\u7684\u8fd4\u56de\u7c7b\u578b\u53ef\u4ee5\u662f\u88ab\u8986\u76d6\u65b9\u6cd5\u7684\u8fd4\u56de\u7c7b\u578b\u7684\u5b50\u7c7b\u3002\u8fd9\u6837\u5c31\u4e0d\u9700\u8981\u5728\u5ba2\u6237\u7aef\u4e2d\u8fdb\u884c\u5f3a\u5236\u8f6c\u6362\u3002\u6211\u4eec\u5fc5\u987b\u628a\u6e90\u81ea Object \u7c7b\u7684 super.clone() \u65b9\u6cd5\u5728\u8fd4\u56de\u524d\u5c06\u7ed3\u679c\u8f6c\u6362\u4e3a PhoneNumber \u7c7b\u578b\uff0c\u8fd9\u7c7b\u5f3a\u5236\u8f6c\u6362\u80af\u5b9a\u4f1a\u6210\u529f\u3002"),(0,l.kt)("p",null,"The call to super.clone is contained in a try-catch block. This is because Object declares its clone method to throw CloneNotSupportedException, which is a checked exception. Because PhoneNumber implements Cloneable, we know the call to super.clone will succeed. The need for this boilerplate indicates that CloneNotSupportedException should have been unchecked (Item 71)."),(0,l.kt)("p",null,"\u5c06 super.clone() \u5305\u542b\u5728 try-catch \u5757\u4e2d\u3002\u8fd9\u662f\u56e0\u4e3a Object \u7c7b\u58f0\u660e\u7684 clone \u65b9\u6cd5\u4f1a\u629b\u51fa CloneNotSupportedException\uff0c\u8fd9\u662f\u4e00\u79cd checked exception\u3002\u56e0\u4e3a PhoneNumber \u7c7b\u5b9e\u73b0\u4e86 Cloneable \u63a5\u53e3\uff0c\u6240\u4ee5\u6211\u4eec\u77e5\u9053\u5bf9 super.clone() \u7684\u8c03\u7528\u5c06\u4f1a\u6210\u529f\u3002\u8fd9\u4e2a\u6837\u677f\u6587\u4ef6\u7684\u9700\u6c42\u8868\u660e CloneNotSupportedException \u5e94\u8be5\u662f unchecked exception\uff08",(0,l.kt)("a",{parentName:"p",href:"./Chapter-10/Chapter-10-Item-71-Avoid-unnecessary-use-of-checked-exceptions"},"Item-71"),"\uff09\u3002"),(0,l.kt)("p",null,"If an object contains fields that refer to mutable objects, the simple clone implementation shown earlier can be disastrous. For example, consider the Stack class in Item 7:"),(0,l.kt)("p",null,"\u5982\u679c\u5bf9\u8c61\u7684\u5b57\u6bb5\u5305\u542b\u53ef\u53d8\u5bf9\u8c61\u7684\u5f15\u7528\uff0c\u524d\u9762\u6240\u793a clone \u65b9\u6cd5\u7684\u8fd9\u79cd\u7b80\u6613\u5b9e\u73b0\u53ef\u80fd\u5f15\u53d1\u707e\u96be\u3002\u4f8b\u5982\uff0c\u8003\u8651 ",(0,l.kt)("a",{parentName:"p",href:"./Chapter-2-Item-7-Eliminate-obsolete-object-references"},"Item-7")," \u4e2d\u7684 Stack \u7c7b\uff1a"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"public class Stack {\n    private Object[] elements;\n    private int size = 0;\n    private static final int DEFAULT_INITIAL_CAPACITY = 16;\n\n    public Stack() {\n      this.elements = new Object[DEFAULT_INITIAL_CAPACITY];\n    }\n\n    public void push(Object e) {\n        ensureCapacity();\n        elements[size++] = e;\n    }\n\n    public Object pop() {\n        if (size == 0)\n            throw new EmptyStackException();\n        Object result = elements[--size];\n        elements[size] = null; // Eliminate obsolete reference\n        return result;\n    }\n\n    // Ensure space for at least one more element.\n    private void ensureCapacity() {\n        if (elements.length == size)\n            elements = Arrays.copyOf(elements, 2 * size + 1);\n    }\n}\n")),(0,l.kt)("p",null,"Suppose you want to make this class cloneable. If the clone method merely returns super.clone(), the resulting Stack instance will have the correct value in its size field, but its elements field will refer to the same array as the original Stack instance. Modifying the original will destroy the invariants in the clone and vice versa. You will quickly find that your program produces nonsensical results or throws a NullPointerException."),(0,l.kt)("p",null,"\u5047\u8bbe\u4f60\u60f3\u8ba9\u8fd9\u4e2a\u7c7b\u53ef\u514b\u9686\u3002\u5982\u679c clone \u65b9\u6cd5\u53ea\u8fd4\u56de super.clone()\uff0c\u5f97\u5230\u7684 Stack \u5b9e\u4f8b\u5728\u5176 size \u5b57\u6bb5\u4e2d\u4f1a\u6709\u6b63\u786e\u7684\u503c\uff0c\u4f46\u5176 elements \u5b57\u6bb5\u5c06\u5f15\u7528\u4e0e\u539f\u59cb Stack \u5b9e\u4f8b\u76f8\u540c\u7684\u6570\u7ec4\u3002\u4fee\u6539\u521d\u59cb\u503c\u5c06\u7834\u574f\u514b\u9686\u7684\u4e0d\u53d8\u6027\uff0c\u53cd\u4e4b\u4ea6\u7136\u3002\u4f60\u5c06\u5f88\u5feb\u53d1\u73b0\u4f60\u7684\u7a0b\u5e8f\u4ea7\u751f\u4e86\u65e0\u610f\u4e49\u7684\u7ed3\u679c\u6216\u629b\u51fa NullPointerException\u3002"),(0,l.kt)("p",null,"This situation could never occur as a result of calling the sole constructor in the Stack class. In effect, the clone method functions as a constructor; you must ensure that it does no harm to the original object and that it properly establishes invariants on the clone. In order for the clone method on Stack to work properly, it must copy the internals of the stack. The easiest way to do this is to call clone recursively on the elements array:"),(0,l.kt)("p",null,"\u8c03\u7528 Stack \u7c7b\u4e2d\u552f\u4e00\u6784\u9020\u51fd\u6570\u7684\u60c5\u51b5\u6c38\u8fdc\u4e0d\u4f1a\u53d1\u751f\u3002\u5b9e\u9645\u4e0a\uff0cclone \u65b9\u6cd5\u5c06\u5145\u5f53\u6784\u9020\u51fd\u6570\uff1b\u4f60\u5fc5\u987b\u786e\u4fdd\u5b83\u4e0d\u4f1a\u5bf9\u539f\u59cb\u5bf9\u8c61\u9020\u6210\u4f24\u5bb3\uff0c\u5e76\u4e14 clone \u65b9\u6cd5\u6b63\u786e\u5730\u5b9e\u73b0\u4e86\u4e0d\u53d8\u6027\u3002\u4e3a\u4e86\u4f7f Stack \u7c7b\u4e0a\u7684 clone \u65b9\u6cd5\u6b63\u5e38\u5de5\u4f5c\uff0c\u5b83\u5fc5\u987b\u590d\u5236 Stack \u7c7b\u5b9e\u4f8b\u7684\u5185\u90e8\u3002\u6700\u7b80\u5355\u7684\u505a\u6cd5\u662f\u5728 elements \u5b57\u6bb5\u5bf9\u5e94\u7684\u6570\u7ec4\u9012\u5f52\u8c03\u7528 clone \u65b9\u6cd5\uff1a"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"// Clone method for class with references to mutable state\n@Override\npublic Stack clone() {\n    try {\n        Stack result = (Stack) super.clone();\n        result.elements = elements.clone();\n        return result;\n    } catch (CloneNotSupportedException e) {\n        throw new AssertionError();\n    }\n}\n")),(0,l.kt)("p",null,"Note that we do not have to cast the result of elements.clone to Object[]. Calling clone on an array returns an array whose runtime and compile-time types are identical to those of the array being cloned. This is the preferred idiom to duplicate an array. In fact, arrays are the sole compelling use of the clone facility."),(0,l.kt)("p",null,"\u6ce8\u610f\uff0c\u6211\u4eec\u4e0d\u9700\u8981\u5c06 ",(0,l.kt)("inlineCode",{parentName:"p"},"elements.clone")," \u7684\u7ed3\u679c\u5f3a\u5236\u8f6c\u6362\u5230 ",(0,l.kt)("inlineCode",{parentName:"p"},"Object[]"),"\u3002\u5728\u6570\u7ec4\u4e0a\u8c03\u7528 clone \u65b9\u6cd5\u5c06\u8fd4\u56de\u4e00\u4e2a\u6570\u7ec4\uff0c\u8be5\u6570\u7ec4\u7684\u8fd0\u884c\u65f6\u548c\u7f16\u8bd1\u65f6\u7c7b\u578b\u4e0e\u88ab\u514b\u9686\u7684\u6570\u7ec4\u76f8\u540c\u3002\u8fd9\u662f\u590d\u5236\u6570\u7ec4\u7684\u9996\u9009\u4e60\u60ef\u7528\u6cd5\u3002\u5b9e\u9645\u4e0a\uff0c\u590d\u5236\u6570\u7ec4\u662f clone \u673a\u5236\u552f\u4e00\u4ee4\u4eba\u4fe1\u670d\u7684\u4f7f\u7528\u573a\u666f\u3002"),(0,l.kt)("p",null,"Note also that the earlier solution would not work if the elements field were final because clone would be prohibited from assigning a new value to the field. This is a fundamental problem: like serialization, the Cloneable architecture is incompatible with normal use of final fields referring to mutable objects, except in cases where the mutable objects may be safely shared between an object and its clone. In order to make a class cloneable, it may be necessary to remove final modifiers from some fields."),(0,l.kt)("p",null,"\u8fd8\u8981\u6ce8\u610f\uff0c\u5982\u679c elements \u5b57\u6bb5\u662f final \u4fee\u9970\u7684\uff0c\u4e0a\u8ff0\u89e3\u51b3\u65b9\u6848\u5c31\u65e0\u6cd5\u5de5\u4f5c\uff0c\u56e0\u4e3a clone \u65b9\u6cd5\u5c06\u88ab\u7981\u6b62\u4e3a\u5b57\u6bb5\u5206\u914d\u65b0\u503c\u3002\u8fd9\u662f\u4e00\u4e2a\u57fa\u7840\u95ee\u9898\uff1a\u4e0e\u5e8f\u5217\u5316\u4e00\u6837\uff0c\u53ef\u514b\u9686\u4f53\u7cfb\u7ed3\u6784\u4e0e\u4f7f\u7528 final \u4fee\u9970\u53ef\u53d8\u5bf9\u8c61\u5f15\u7528\u7684\u5e38\u7528\u65b9\u5f0f\u4e0d\u517c\u5bb9\uff0c\u9664\u975e\u5728\u5bf9\u8c61\u4e0e\u5176\u514b\u9686\u5bf9\u8c61\u4e4b\u95f4\u53ef\u4ee5\u5b89\u5168\u5730\u5171\u4eab\u53ef\u53d8\u5bf9\u8c61\u3002\u4e3a\u4e86\u4f7f\u7c7b\u53ef\u514b\u9686\uff0c\u53ef\u80fd\u9700\u8981\u4ece\u67d0\u4e9b\u5b57\u6bb5\u4e2d\u5220\u9664 final \u4fee\u9970\u7b26\u3002"),(0,l.kt)("p",null,"It is not always sufficient merely to call clone recursively. For example,suppose you are writing a clone method for a hash table whose internals consist of an array of buckets, each of which references the first entry in a linked list of key-value pairs. For performance, the class implements its own lightweight singly linked list instead of using java.util.LinkedList internally:"),(0,l.kt)("p",null,"\u4ec5\u4ec5\u9012\u5f52\u8c03\u7528 clone \u65b9\u6cd5\u5e76\u4e0d\u603b\u662f\u8db3\u591f\u7684\u3002\u4f8b\u5982\uff0c\u5047\u8bbe\u4f60\u6b63\u5728\u4e3a HashTable \u7f16\u5199\u4e00\u4e2a clone \u65b9\u6cd5\uff0cHashTable \u7684\u5185\u90e8\u7531\u4e00\u7ec4 bucket \u7ec4\u6210\uff0c\u6bcf\u4e2a bucket \u5f15\u7528\u952e-\u503c\u5bf9\u94fe\u8868\u4e2d\u7684\u7b2c\u4e00\u4e2a\u6761\u76ee\u3002\u4e3a\u4e86\u63d0\u9ad8\u6027\u80fd\uff0c\u7c7b\u5b9e\u73b0\u4e86\u81ea\u5df1\u7684\u8f7b\u91cf\u7ea7\u5355\u94fe\u8868\uff0c\u800c\u4e0d\u662f\u5728\u5185\u90e8\u4f7f\u7528 ",(0,l.kt)("inlineCode",{parentName:"p"},"java.util.LinkedList"),"\uff1a"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"public class HashTable implements Cloneable {\n    private Entry[] buckets = ...;\n\n    private static class Entry {\n        final Object key;\n        Object value;\n        Entry next;\n\n        Entry(Object key, Object value, Entry next) {\n            this.key = key;\n            this.value = value;\n            this.next = next;\n        }\n    } ... // Remainder omitted\n}\n")),(0,l.kt)("p",null,"Suppose you merely clone the bucket array recursively, as we did for Stack:"),(0,l.kt)("p",null,"\u5047\u8bbe\u4f60\u53ea\u662f\u50cf\u5bf9 Stack \u6240\u505a\u7684\u90a3\u6837\uff0c\u9012\u5f52\u514b\u9686 bucket \u6570\u7ec4\uff0c\u5982\u4e0b\u6240\u793a\uff1a"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"// Broken clone method - results in shared mutable state!\n@Override\npublic HashTable clone() {\n    try {\n        HashTable result = (HashTable) super.clone();\n        result.buckets = buckets.clone();\n        return result;\n    } catch (CloneNotSupportedException e) {\n        throw new AssertionError();\n    }\n}\n")),(0,l.kt)("p",null,"Though the clone has its own bucket array, this array references the same linked lists as the original, which can easily cause nondeterministic behavior in both the clone and the original. To fix this problem, you\u2019ll have to copy the linked list that comprises each bucket. Here is one common approach:"),(0,l.kt)("p",null,"\u5c3d\u7ba1 clone \u65b9\u6cd5\u6709\u81ea\u5df1\u7684 bucket \u6570\u7ec4\uff0c\u4f46\u8be5\u6570\u7ec4\u5f15\u7528\u7684\u94fe\u63a5\u5217\u8868\u4e0e\u539f\u59cb\u94fe\u8868\u76f8\u540c\uff0c\u8fd9\u5f88\u5bb9\u6613\u5bfc\u81f4\u514b\u9686\u548c\u539f\u59cb\u7684\u4e0d\u786e\u5b9a\u6027\u884c\u4e3a\u3002\u8981\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff0c\u4f60\u5fc5\u987b\u590d\u5236\u5305\u542b\u6bcf\u4e2a bucket \u7684\u94fe\u8868\u3002\u8fd9\u91cc\u6709\u4e00\u4e2a\u5e38\u89c1\u7684\u65b9\u6cd5\uff1a"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"// Recursive clone method for class with complex mutable state\npublic class HashTable implements Cloneable {\n    private Entry[] buckets = ...;\n\n    private static class Entry {\n        final Object key;\n        Object value;\n        Entry next;\n\n        Entry(Object key, Object value, Entry next) {\n            this.key = key;\n            this.value = value;\n            this.next = next;\n        }\n\n        // Recursively copy the linked list headed by this Entry\n        Entry deepCopy() {\n            return new Entry(key, value,next == null ? null : next.deepCopy());\n        }\n    }\n\n    @Override\n    public HashTable clone() {\n        try {\n            HashTable result = (HashTable) super.clone();\n            result.buckets = new Entry[buckets.length];\n\n            for (int i = 0; i < buckets.length; i++)\n                if (buckets[i] != null)\n                    result.buckets[i] = buckets[i].deepCopy();\n\n            return result;\n        } catch (CloneNotSupportedException e) {\n            throw new AssertionError();\n        }\n    } ... // Remainder omitted\n}\n")),(0,l.kt)("p",null,"The private class HashTable.Entry has been augmented to support a \u201cdeep copy\u201d method. The clone method on HashTable allocates a new buckets array of the proper size and iterates over the original buckets array,deep-copying each nonempty bucket. The deepCopy method on Entry invokes itself recursively to copy the entire linked list headed by the entry. While this technique is cute and works fine if the buckets aren\u2019t too long, it is not a good way to clone a linked list because it consumes one stack frame for each element in the list. If the list is long, this could easily cause a stack overflow. To prevent this from happening, you can replace the recursion in deepCopy with iteration:"),(0,l.kt)("p",null,"\u79c1\u6709\u5185\u90e8\u7c7b HashTable.Entry \u5df2\u7ecf\u88ab\u589e\u5f3a\uff0c\u5b83\u63d0\u4f9b\u4e86\u8fdb\u884c\u300c\u6df1\u62f7\u8d1d\u300d\u7684\u65b9\u6cd5\u3002HashTable \u4e0a\u7684 clone \u65b9\u6cd5\u5206\u914d\u4e00\u4e2a\u5927\u5c0f\u5408\u9002\u7684\u65b0 buckets \u6570\u7ec4\uff0c\u5e76\u904d\u5386\u539f\u59cb buckets \u6570\u7ec4\uff0c\u5bf9\u6bcf\u4e2a\u975e\u7a7a buckets \u5143\u7d20\u8fdb\u884c\u6df1\u62f7\u8d1d\u3002Entry \u7c7b\u7684 deepCopy() \u65b9\u6cd5\u4f1a\u88ab\u9012\u5f52\u8c03\u7528\u76f4\u81f3\u590d\u5236\u5b8c\u6574\u4e2a\u94fe\u8868\uff08\u8be5\u94fe\u8868\u4ee5 Entry \u7c7b\u7684\u5b9e\u4f8b\u4f5c\u4e3a\u5934\u8282\u70b9\uff09\u3002\u8fd9\u79cd\u65b9\u6cd5\u867d\u7136\u5f88\u7075\u6d3b\uff0c\u800c\u4e14\u5728 buckets \u4e0d\u592a\u957f\u7684\u60c5\u51b5\u4e0b\u53ef\u4ee5\u5f88\u597d\u5730\u5de5\u4f5c\uff0c\u4f46\u662f\u514b\u9686\u94fe\u8868\u5e76\u4e0d\u662f\u4e00\u4e2a\u597d\u65b9\u6cd5\uff0c\u56e0\u4e3a\u5b83\u4e3a\u94fe\u8868\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u6d88\u8017\u4e00\u4e2a\u5806\u6808\u5e27\u3002\u5982\u679c\u5217\u8868\u5f88\u957f\uff0c\u5f88\u5bb9\u6613\u5bfc\u81f4\u5806\u6808\u6ea2\u51fa\u3002\u4e3a\u4e86\u9632\u6b62\u8fd9\u79cd\u60c5\u51b5\u7684\u53d1\u751f\uff0c\u4f60\u53ef\u4ee5\u7528\u8fed\u4ee3\u66ff\u6362 deepCopy() \u65b9\u6cd5\u7684\u9012\u5f52\u8c03\u7528\uff1a"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"// Iteratively copy the linked list headed by this Entry\nEntry deepCopy() {\n    Entry result = new Entry(key, value, next);\n    for (Entry p = result; p.next != null; p = p.next)\n        p.next = new Entry(p.next.key, p.next.value, p.next.next);\n    return result;\n}\n")),(0,l.kt)("p",null,"A final approach to cloning complex mutable objects is to call super.clone, set all of the fields in the resulting object to their initial state,and then call higher-level methods to regenerate the state of the original object. In the case of our HashTable example, the buckets field would be initialized to a new bucket array, and the put(key, value) method (not shown) would be invoked for each key-value mapping in the hash table being cloned. This approach typically yields a simple, reasonably elegant clone method that does not run as quickly as one that directly manipulates the innards of the clone. While this approach is clean, it is antithetical to the whole Cloneable architecture because it blindly overwrites the field-by-field object copy that forms the basis of the architecture."),(0,l.kt)("p",null,"\u514b\u9686\u590d\u6742\u53ef\u53d8\u5bf9\u8c61\u7684\u6700\u540e\u4e00\u79cd\u65b9\u6cd5\u662f\u8c03\u7528 super.clone()\uff0c\u5c06\u7ed3\u679c\u5bf9\u8c61\u4e2d\u7684\u6240\u6709\u5b57\u6bb5\u8bbe\u7f6e\u4e3a\u521d\u59cb\u72b6\u6001\uff0c\u7136\u540e\u8c03\u7528\u66f4\u9ad8\u7ea7\u522b\u7684\u65b9\u6cd5\u91cd\u65b0\u751f\u6210\u539f\u59cb\u5bf9\u8c61\u7684\u72b6\u6001\u3002\u5728\u6211\u4eec\u7684 HashTable \u793a\u4f8b\u4e2d\uff0cbuckets \u5b57\u6bb5\u5c06\u521d\u59cb\u5316\u4e3a\u4e00\u4e2a\u65b0\u7684 bucket \u6570\u7ec4\uff0c\u5e76\u4e14\u5bf9\u4e8e\u514b\u9686\u7684 hash \u8868\u4e2d\u7684\u6bcf\u4e2a\u952e\u503c\u6620\u5c04\u5c06\u8c03\u7528 put(key, value) \u65b9\u6cd5\uff08\u672a\u663e\u793a\uff09\u3002\u8fd9\u79cd\u65b9\u6cd5\u901a\u5e38\u4ea7\u751f\u4e00\u4e2a\u7b80\u5355\u3001\u76f8\u5f53\u4f18\u96c5\u7684 clone \u65b9\u6cd5\uff0c\u5b83\u7684\u8fd0\u884c\u901f\u5ea6\u4e0d\u5982\u76f4\u63a5\u64cd\u4f5c\u514b\u9686\u7684\u5185\u90e8\u7684\u65b9\u6cd5\u5feb\u3002\u867d\u7136\u8fd9\u79cd\u65b9\u6cd5\u5f88\u7b80\u6d01\uff0c\u4f46\u5b83\u4e0e\u6574\u4e2a\u53ef\u514b\u9686\u4f53\u7cfb\u7ed3\u6784\u662f\u5bf9\u7acb\u7684\uff0c\u56e0\u4e3a\u5b83\u76f2\u76ee\u5730\u8986\u76d6\u4e86\u6784\u6210\u4f53\u7cfb\u7ed3\u6784\u57fa\u7840\u7684\u9010\u5b57\u6bb5\u5bf9\u8c61\u526f\u672c\u3002"),(0,l.kt)("p",null,"Like a constructor, a clone method must never invoke an overridable method on the clone under construction (Item 19). If clone invokes a method that is overridden in a subclass, this method will execute before the subclass has had a chance to fix its state in the clone, quite possibly leading to corruption in the clone and the original. Therefore, the put(key, value) method discussed in the previous paragraph should be either final or private. (If it is private, it is presumably the \u201chelper method\u201d for a nonfinal public method.)"),(0,l.kt)("p",null,"\u4e0e\u6784\u9020\u51fd\u6570\u4e00\u6837\uff0cclone \u65b9\u6cd5\u7edd\u4e0d\u80fd\u5728\u6b63\u5728\u6784\u5efa\u7684\u514b\u9686\u4e0a\u8c03\u7528\u53ef\u8986\u76d6\u65b9\u6cd5\uff08",(0,l.kt)("a",{parentName:"p",href:"./Chapter-4-Item-19-Design-and-document-for-inheritance-or-else-prohibit-it"},"Item-19"),"\uff09\u3002\u5982\u679c clone \u8c03\u7528\u4e00\u4e2a\u5728\u5b50\u7c7b\u4e2d\u88ab\u91cd\u5199\u7684\u65b9\u6cd5\uff0c\u8fd9\u4e2a\u65b9\u6cd5\u5c06\u5728\u5b50\u7c7b\u6709\u673a\u4f1a\u4fee\u590d\u5176\u5728\u514b\u9686\u4e2d\u7684\u72b6\u6001\u4e4b\u524d\u6267\u884c\uff0c\u5f88\u53ef\u80fd\u5bfc\u81f4\u514b\u9686\u548c\u539f\u59cb\u7684\u7834\u574f\u3002\u56e0\u6b64\uff0c\u524d\u4e00\u6bb5\u4e2d\u8ba8\u8bba\u7684 put(key, value) \u65b9\u6cd5\u5e94\u8be5\u662f final \u4fee\u9970\u6216 private \u4fee\u9970\u7684\u65b9\u6cd5\u3002\uff08\u5982\u679c\u5b83\u662f\u79c1\u6709\u7684\uff0c\u90a3\u4e48\u5b83\u53ef\u80fd\u662f\u6ca1\u6709 final \u4fee\u9970\u7684\u516c\u5171\u300c\u52a9\u624b\u65b9\u6cd5\u300d\u3002)"),(0,l.kt)("p",null,"Object\u2019s clone method is declared to throw CloneNotSupportedException, but overriding methods need not. ",(0,l.kt)("strong",{parentName:"p"},"Public clone methods should omit the throws clause,")," as methods that don\u2019t throw checked exceptions are easier to use (Item 71)."),(0,l.kt)("p",null,"\u5bf9\u8c61\u7684 clone \u65b9\u6cd5\u88ab\u58f0\u660e\u4e3a\u629b\u51fa CloneNotSupportedException\uff0c\u4f46\u662f\u91cd\u5199\u65b9\u6cd5\u4e0d\u9700\u8981\u3002",(0,l.kt)("strong",{parentName:"p"},"\u516c\u5171\u514b\u9686\u65b9\u6cd5\u5e94\u8be5\u7701\u7565 throw \u5b50\u53e5\uff0c")," \u4f5c\u4e3a\u4e0d\u629b\u51fa\u53d7\u63a7\u5f02\u5e38\u7684\u65b9\u6cd5\u66f4\u5bb9\u6613\u4f7f\u7528\uff08",(0,l.kt)("a",{parentName:"p",href:"./Chapter-10/Chapter-10-Item-71-Avoid-unnecessary-use-of-checked-exceptions"},"Item-71"),"\uff09\u3002"),(0,l.kt)("p",null,"You have two choices when designing a class for inheritance (Item 19), but whichever one you choose, the class should not implement Cloneable. You may choose to mimic the behavior of Object by implementing a properly functioning protected clone method that is declared to throw CloneNotSupportedException. This gives subclasses the freedom to implement Cloneable or not, just as if they extended Object directly.Alternatively, you may choose not to implement a working clone method, and to prevent subclasses from implementing one, by providing the following degenerate clone implementation:"),(0,l.kt)("p",null,"\u7528\u7ee7\u627f\uff08",(0,l.kt)("a",{parentName:"p",href:"./Chapter-4-Item-19-Design-and-document-for-inheritance-or-else-prohibit-it"},"Item-19"),"\uff09\u65b9\u5f0f\u8bbe\u8ba1\u4e00\u4e2a\u7c7b\u65f6\uff0c\u4f60\u6709\u4e24\u79cd\u9009\u62e9\uff0c\u4f46\u662f\u65e0\u8bba\u4f60\u9009\u62e9\u54ea\u4e00\u79cd\uff0c\u90fd\u4e0d\u5e94\u8be5\u5b9e\u73b0 Cloneable \u63a5\u53e3\u3002\u4f60\u53ef\u4ee5\u9009\u62e9\u901a\u8fc7\u5b9e\u73b0\u4e00\u4e2a\u529f\u80fd\u6b63\u5e38\u7684\u53d7\u4fdd\u62a4\u514b\u9686\u65b9\u6cd5\u6765\u6a21\u62df Object \u7684\u884c\u4e3a\uff0c\u8be5\u65b9\u6cd5\u58f0\u660e\u4e3a\u629b\u51fa CloneNotSupportedException\u3002\u8fd9\u7ed9\u5b50\u7c7b\u5b9e\u73b0 Cloneable \u6216\u4e0d\u5b9e\u73b0 Cloneable \u7684\u81ea\u7531\uff0c\u5c31\u50cf\u5b83\u4eec\u76f4\u63a5\u6269\u5c55\u5bf9\u8c61\u4e00\u6837\u3002\u6216\u8005\uff0c\u4f60\u53ef\u4ee5\u9009\u62e9\u4e0d\u5b9e\u73b0\u4e00\u4e2a\u6709\u6548\u7684\u514b\u9686\u65b9\u6cd5\uff0c\u5e76\u901a\u8fc7\u63d0\u4f9b\u4ee5\u4e0b\u9000\u5316\u7684\u514b\u9686\u5b9e\u73b0\u6765\u9632\u6b62\u5b50\u7c7b\u5b9e\u73b0\u5b83\uff1a"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"// clone method for extendable class not supporting Cloneable\n@Override\nprotected final Object clone() throws CloneNotSupportedException {\n    throw new CloneNotSupportedException();\n}\n")),(0,l.kt)("p",null,"There is one more detail that bears noting. If you write a thread-safe class that implements Cloneable, remember that its clone method must be properly synchronized, just like any other method (Item 78). Object\u2019s clone method is not synchronized, so even if its implementation is otherwise satisfactory, you may have to write a synchronized clone method that returns super.clone()."),(0,l.kt)("p",null,"\u8fd8\u6709\u4e00\u4e2a\u7ec6\u8282\u9700\u8981\u6ce8\u610f\u3002\u5982\u679c\u4f60\u7f16\u5199\u4e86\u4e00\u4e2a\u5b9e\u73b0\u4e86 Cloneable \u63a5\u53e3\u7684\u7ebf\u7a0b\u5b89\u5168\u7c7b\uff0c\u8bf7\u8bb0\u4f4f\u5b83\u7684 clone \u65b9\u6cd5\u5fc5\u987b\u6b63\u786e\u540c\u6b65\uff0c\u5c31\u50cf\u5176\u4ed6\u4efb\u4f55\u65b9\u6cd5\u4e00\u6837\uff08",(0,l.kt)("a",{parentName:"p",href:"./Chapter-11/Chapter-11-Item-78-Synchronize-access-to-shared-mutable-data"},"Item-78"),"\uff09\u3002Object \u7c7b\u7684 clone \u65b9\u6cd5\u4e0d\u662f\u540c\u6b65\u7684\uff0c\u56e0\u6b64\u5373\u4f7f\u5b83\u7684\u5b9e\u73b0\u5728\u5176\u4ed6\u65b9\u9762\u662f\u4ee4\u4eba\u6ee1\u610f\u7684\uff0c\u4f60\u4e5f\u53ef\u80fd\u9700\u8981\u7f16\u5199\u4e00\u4e2a\u8fd4\u56de super.clone() \u7684\u540c\u6b65 clone \u65b9\u6cd5\u3002"),(0,l.kt)("p",null,"To recap, all classes that implement Cloneable should override clone with a public method whose return type is the class itself. This method should first call super.clone, then fix any fields that need fixing. Typically, this means copying any mutable objects that comprise the internal \u201cdeep structure\u201d of the object and replacing the clone\u2019s references to these objects with references to their copies. While these internal copies can usually be made by calling clone recursively, this is not always the best approach. If the class contains only primitive fields or references to immutable objects, then it is likely the case that no fields need to be fixed. There are exceptions to this rule. For example, a field representing a serial number or other unique ID will need to be fixed even if it is primitive or immutable."),(0,l.kt)("p",null,"\u56de\u987e\u4e00\u4e0b\uff0c\u6240\u6709\u5b9e\u73b0 Cloneable \u63a5\u53e3\u7684\u7c7b\u90fd\u5e94\u8be5\u4f7f\u7528\u4e00\u4e2a\u8fd4\u56de\u7c7b\u578b\u4e3a\u7c7b\u672c\u8eab\u7684\u516c\u5171\u65b9\u6cd5\u8986\u76d6 clone\u3002\u8fd9\u4e2a\u65b9\u6cd5\u5e94\u8be5\u9996\u5148\u8c03\u7528 super.clone()\uff0c\u7136\u540e\u300c\u4fee\u590d\u300d\u4efb\u4f55\u9700\u8981\u300c\u4fee\u590d\u300d\u7684\u5b57\u6bb5\u3002\u901a\u5e38\uff0c\u8fd9\u610f\u5473\u7740\u590d\u5236\u4efb\u4f55\u5305\u542b\u5bf9\u8c61\u5185\u90e8\u300c\u6df1\u5c42\u7ed3\u6784\u300d\u7684\u53ef\u53d8\u5bf9\u8c61\uff0c\u5e76\u5c06\u514b\u9686\u5bf9\u8c61\u5bf9\u8fd9\u4e9b\u5bf9\u8c61\u7684\u5f15\u7528\u66ff\u6362\u4e3a\u5bf9\u5176\u526f\u672c\u7684\u5f15\u7528\u3002\u867d\u7136\u8fd9\u4e9b\u5185\u90e8\u526f\u672c\u901a\u5e38\u53ef\u4ee5\u901a\u8fc7\u9012\u5f52\u8c03\u7528 clone \u6765\u5b9e\u73b0\uff0c\u4f46\u8fd9\u5e76\u4e0d\u603b\u662f\u6700\u597d\u7684\u65b9\u6cd5\u3002\u5982\u679c\u7c7b\u53ea\u5305\u542b\u57fa\u672c\u6570\u636e\u7c7b\u578b\u7684\u5b57\u6bb5\u6216\u5bf9\u4e0d\u53ef\u53d8\u5bf9\u8c61\u7684\u5f15\u7528\uff0c\u90a3\u4e48\u5f88\u53ef\u80fd\u4e0d\u9700\u8981\u4fee\u590d\u4efb\u4f55\u5b57\u6bb5\u3002\u8fd9\u6761\u89c4\u5219\u4e5f\u6709\u4f8b\u5916\u3002\u4f8b\u5982\uff0c\u8868\u793a\u5e8f\u5217\u53f7\u6216\u5176\u4ed6\u552f\u4e00 ID \u7684\u5b57\u6bb5\u9700\u8981\u4fee\u590d\uff0c\u5373\u4f7f\u5b83\u662f\u57fa\u672c\u6570\u636e\u7c7b\u578b\u6216\u4e0d\u53ef\u53d8\u7684\u3002"),(0,l.kt)("p",null,"Is all this complexity really necessary? Rarely. If you extend a class that already implements Cloneable, you have little choice but to implement a well-behaved clone method. Otherwise, you are usually better off providing an alternative means of object copying. A better approach to object copying is to provide a copy constructor or copy factory. A copy constructor is simply a constructor that takes a single argument whose type is the class containing the constructor, for example,"),(0,l.kt)("p",null,"\u641e\u8fd9\u4e48\u590d\u6742\u771f\u7684\u6709\u5fc5\u8981\u5417\uff1f\u7b54\u6848\u662f\u5426\u5b9a\u7684\u3002\u5982\u679c\u4f60\u6269\u5c55\u4e86\u4e00\u4e2a\u5df2\u7ecf\u5b9e\u73b0\u4e86 Cloneable \u63a5\u53e3\u7684\u7c7b\uff0c\u90a3\u4e48\u9664\u4e86\u5b9e\u73b0\u884c\u4e3a\u826f\u597d\u7684 clone \u65b9\u6cd5\u4e4b\u5916\uff0c\u4f60\u522b\u65e0\u9009\u62e9\u3002\u5426\u5219\uff0c\u6700\u597d\u63d0\u4f9b\u5bf9\u8c61\u590d\u5236\u7684\u66ff\u4ee3\u65b9\u6cd5\u3002\u4e00\u4e2a\u66f4\u597d\u7684\u5bf9\u8c61\u590d\u5236\u65b9\u6cd5\u662f\u63d0\u4f9b\u4e00\u4e2a\u590d\u5236\u6784\u9020\u51fd\u6570\u6216\u590d\u5236\u5de5\u5382\u3002\u590d\u5236\u6784\u9020\u51fd\u6570\u662f\u4e00\u4e2a\u7b80\u5355\u7684\u6784\u9020\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u5355\u4e2a\u53c2\u6570\uff0c\u5176\u7c7b\u578b\u662f\u5305\u542b\u6784\u9020\u51fd\u6570\u7684\u7c7b\uff0c\u4f8b\u5982"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"// Copy constructor\npublic Yum(Yum yum) { ... };\n")),(0,l.kt)("p",null,"A copy factory is the static factory (Item 1) analogue of a copy constructor:"),(0,l.kt)("p",null,"\u590d\u5236\u5de5\u5382\u4e0e\u590d\u5236\u6784\u9020\u51fd\u6570\u7684\u9759\u6001\u5de5\u5382\uff08",(0,l.kt)("a",{parentName:"p",href:"./Chapter-2-Item-1-Consider-static-factory-methods-instead-of-constructors"},"Item-1"),"\uff09\u7c7b\u4f3c\uff1a"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"// Copy factory\npublic static Yum newInstance(Yum yum) { ... };\n")),(0,l.kt)("p",null,"The copy constructor approach and its static factory variant have many advantages over Cloneable/clone: they don\u2019t rely on a risk-prone extralinguistic object creation mechanism; they don\u2019t demand unenforceable adherence to thinly documented conventions; they don\u2019t conflict with the proper use of final fields; they don\u2019t throw unnecessary checked exceptions; and they don\u2019t require casts."),(0,l.kt)("p",null,"\u590d\u5236\u6784\u9020\u51fd\u6570\u65b9\u6cd5\u53ca\u5176\u9759\u6001\u5de5\u5382\u53d8\u4f53\u4e0e\u514b\u9686/\u514b\u9686\u76f8\u6bd4\u6709\u8bb8\u591a\u4f18\u70b9\uff1a\u5b83\u4eec\u4e0d\u4f9d\u8d56\u4e8e\u6613\u53d1\u751f\u98ce\u9669\u7684\u8bed\u8a00\u5916\u5bf9\u8c61\u521b\u5efa\u673a\u5236\uff1b\u4ed6\u4eec\u4e0d\u8981\u6c42\u65e0\u6cd5\u5f3a\u5236\u6267\u884c\u7684\u7ea6\u5b9a\uff1b\u5b83\u4eec\u4e0e\u6700\u7ec8\u5b57\u6bb5\u7684\u6b63\u786e\u4f7f\u7528\u4e0d\u51b2\u7a81\uff1b\u5b83\u4eec\u4e0d\u4f1a\u629b\u51fa\u4e0d\u5fc5\u8981\u7684\u68c0\u67e5\u5f02\u5e38\uff1b\u800c\u4e14\u4e0d\u9700\u8981\u5f3a\u5236\u7c7b\u578b\u8f6c\u6362\u3002"),(0,l.kt)("p",null,"Furthermore, a copy constructor or factory can take an argument whose type is an interface implemented by the class. For example, by convention all generalpurpose collection implementations provide a constructor whose argument is of type Collection or Map. Interface-based copy constructors and factories,more properly known as conversion constructors and conversion factories, allow the client to choose the implementation type of the copy rather than forcing the client to accept the implementation type of the original. For example, suppose you have a HashSet, s, and you want to copy it as a TreeSet. The clone method can\u2019t offer this functionality, but it\u2019s easy with a conversion constructor:new TreeSet","<",">","(s)."),(0,l.kt)("p",null,"\u6b64\u5916\uff0c\u590d\u5236\u6784\u9020\u51fd\u6570\u6216\u5de5\u5382\u53ef\u4ee5\u63a5\u53d7\u7c7b\u578b\u4e3a\u7c7b\u5b9e\u73b0\u7684\u63a5\u53e3\u7684\u53c2\u6570\u3002\u4f8b\u5982\uff0c\u6309\u7167\u7ea6\u5b9a\uff0c\u6240\u6709\u901a\u7528\u96c6\u5408\u5b9e\u73b0\u90fd\u63d0\u4f9b\u4e00\u4e2a\u6784\u9020\u51fd\u6570\uff0c\u5176\u53c2\u6570\u4e3a collection \u6216 Map \u7c7b\u578b\u3002\u57fa\u4e8e\u63a5\u53e3\u7684\u590d\u5236\u6784\u9020\u51fd\u6570\u548c\u5de5\u5382\uff08\u66f4\u786e\u5207\u5730\u79f0\u4e3a\u8f6c\u6362\u6784\u9020\u51fd\u6570\u548c\u8f6c\u6362\u5de5\u5382\uff09\u5141\u8bb8\u5ba2\u6237\u7aef\u9009\u62e9\u526f\u672c\u7684\u5b9e\u73b0\u7c7b\u578b\uff0c\u800c\u4e0d\u662f\u5f3a\u8feb\u5ba2\u6237\u7aef\u63a5\u53d7\u539f\u59cb\u7684\u5b9e\u73b0\u7c7b\u578b\u3002\u4f8b\u5982\uff0c\u5047\u8bbe\u4f60\u6709\u4e00\u4e2a HashSet s\uff0c\u5e76\u4e14\u5e0c\u671b\u5c06\u5b83\u590d\u5236\u4e3a TreeSet\u3002\u514b\u9686\u65b9\u6cd5\u4e0d\u80fd\u63d0\u4f9b\u8fd9\u79cd\u529f\u80fd\uff0c\u4f46\u662f\u4f7f\u7528\u8f6c\u6362\u6784\u9020\u51fd\u6570\u5f88\u5bb9\u6613\uff1anew TreeSet","<",">","(s)\u3002"),(0,l.kt)("p",null,"Given all the problems associated with Cloneable, new interfaces should not extend it, and new extendable classes should not implement it. While it\u2019s less harmful for final classes to implement Cloneable, this should be viewed as a performance optimization, reserved for the rare cases where it is justified (Item 67). As a rule, copy functionality is best provided by constructors or factories. A notable exception to this rule is arrays, which are best copied with the clone method."),(0,l.kt)("p",null,"\u8003\u8651\u5230\u4e0e Cloneable \u76f8\u5173\u7684\u6240\u6709\u95ee\u9898\uff0c\u65b0\u7684\u63a5\u53e3\u4e0d\u5e94\u8be5\u6269\u5c55\u5b83\uff0c\u65b0\u7684\u53ef\u6269\u5c55\u7c7b\u4e0d\u5e94\u8be5\u5b9e\u73b0\u5b83\u3002\u867d\u7136 final \u7c7b\u5b9e\u73b0 Cloneable \u63a5\u53e3\u7684\u5371\u5bb3\u8981\u5c0f\u4e00\u4e9b\uff0c\u4f46\u8fd9\u5e94\u8be5\u88ab\u89c6\u4e3a\u4e00\u79cd\u6027\u80fd\u4f18\u5316\uff0c\u4ec5\u5728\u6781\u5c11\u6570\u60c5\u51b5\u4e0b\uff08",(0,l.kt)("a",{parentName:"p",href:"./Chapter-9-Item-67-Optimize-judiciously"},"Item-67"),"\uff09\u662f\u5408\u7406\u7684\u3002\u901a\u5e38\uff0c\u590d\u5236\u529f\u80fd\u6700\u597d\u7531\u6784\u9020\u51fd\u6570\u6216\u5de5\u5382\u63d0\u4f9b\u3002\u8fd9\u4e2a\u89c4\u5219\u7684\u4e00\u4e2a\u660e\u663e\u7684\u4f8b\u5916\u662f\u6570\u7ec4\uff0c\u6700\u597d\u4f7f\u7528 clone \u65b9\u6cd5\u6765\u590d\u5236\u6570\u7ec4\u3002"),(0,l.kt)("hr",null),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("a",{parentName:"strong",href:"./Chapter-3-Introduction"},"Back to contents of the chapter\uff08\u8fd4\u56de\u7ae0\u8282\u76ee\u5f55\uff09"))),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Previous Item\uff08\u4e0a\u4e00\u6761\u76ee\uff09\uff1a",(0,l.kt)("a",{parentName:"strong",href:"./Chapter-3-Item-12-Always-override-toString"},"Item 12: Always override toString\uff08\u59cb\u7ec8\u8986\u76d6 toString \u65b9\u6cd5\uff09"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Next Item\uff08\u4e0b\u4e00\u6761\u76ee\uff09\uff1a",(0,l.kt)("a",{parentName:"strong",href:"./Chapter-3-Item-14-Consider-implementing-Comparable"},"Item 14: Consider implementing Comparable\uff08\u8003\u8651\u5b9e\u73b0 Comparable \u63a5\u53e3\uff09")))))}u.isMDXComponent=!0}}]);