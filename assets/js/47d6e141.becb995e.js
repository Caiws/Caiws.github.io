"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[3562],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>d});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var p=a.createContext({}),l=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=l(e.components);return a.createElement(p.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,p=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=l(n),d=o,h=c["".concat(p,".").concat(d)]||c[d]||m[d]||i;return n?a.createElement(h,r(r({ref:t},u),{},{components:n})):a.createElement(h,r({ref:t},u))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=c;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s.mdxType="string"==typeof e?e:o,r[1]=s;for(var l=2;l<i;l++)r[l]=n[l];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},9007:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>r,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>l});var a=n(7462),o=(n(7294),n(3905));const i={},r=void 0,s={unversionedId:"Books/EffectiveJava3/Chapter-6/Chapter-6-Item-38-Emulate-extensible-enums-with-interfaces",id:"Books/EffectiveJava3/Chapter-6/Chapter-6-Item-38-Emulate-extensible-enums-with-interfaces",title:"Chapter-6-Item-38-Emulate-extensible-enums-with-interfaces",description:"Chapter 6. Enums and Annotations\uff08\u679a\u4e3e\u548c\u6ce8\u89e3\uff09",source:"@site/docs/Books/EffectiveJava3/Chapter-6/Chapter-6-Item-38-Emulate-extensible-enums-with-interfaces.md",sourceDirName:"Books/EffectiveJava3/Chapter-6",slug:"/Books/EffectiveJava3/Chapter-6/Chapter-6-Item-38-Emulate-extensible-enums-with-interfaces",permalink:"/docs/Books/EffectiveJava3/Chapter-6/Chapter-6-Item-38-Emulate-extensible-enums-with-interfaces",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Books/EffectiveJava3/Chapter-6/Chapter-6-Item-38-Emulate-extensible-enums-with-interfaces.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Chapter-6-Item-37-Use-EnumMap-instead-of-ordinal-indexing",permalink:"/docs/Books/EffectiveJava3/Chapter-6/Chapter-6-Item-37-Use-EnumMap-instead-of-ordinal-indexing"},next:{title:"Chapter-6-Item-39-Prefer-annotations-to-naming-patterns",permalink:"/docs/Books/EffectiveJava3/Chapter-6/Chapter-6-Item-39-Prefer-annotations-to-naming-patterns"}},p={},l=[{value:"Chapter 6. Enums and Annotations\uff08\u679a\u4e3e\u548c\u6ce8\u89e3\uff09",id:"chapter-6-enums-and-annotations\u679a\u4e3e\u548c\u6ce8\u89e3",level:2},{value:"Item 38: Emulate extensible enums with interfaces\uff08\u4f7f\u7528\u63a5\u53e3\u6a21\u62df\u53ef\u6269\u5c55\u679a\u4e3e\uff09",id:"item-38-emulate-extensible-enums-with-interfaces\u4f7f\u7528\u63a5\u53e3\u6a21\u62df\u53ef\u6269\u5c55\u679a\u4e3e",level:3}],u={toc:l};function m(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"chapter-6-enums-and-annotations\u679a\u4e3e\u548c\u6ce8\u89e3"},"Chapter 6. Enums and Annotations\uff08\u679a\u4e3e\u548c\u6ce8\u89e3\uff09"),(0,o.kt)("h3",{id:"item-38-emulate-extensible-enums-with-interfaces\u4f7f\u7528\u63a5\u53e3\u6a21\u62df\u53ef\u6269\u5c55\u679a\u4e3e"},"Item 38: Emulate extensible enums with interfaces\uff08\u4f7f\u7528\u63a5\u53e3\u6a21\u62df\u53ef\u6269\u5c55\u679a\u4e3e\uff09"),(0,o.kt)("p",null,"In almost all respects, enum types are superior to the typesafe enum pattern described in the first edition of this book ","[Bloch01]",". On the face of it, one exception concerns extensibility, which was possible under the original pattern but is not supported by the language construct. In other words, using the pattern, it was possible to have one enumerated type extend another; using the language feature, it is not. This is no accident. For the most part, extensibility of enums turns out to be a bad idea. It is confusing that elements of an extension type are instances of the base type and not vice versa. There is no good way to enumerate over all of the elements of a base type and its extensions. Finally, extensibility would complicate many aspects of the design and implementation."),(0,o.kt)("p",null,"\u679a\u4e3e\u7c7b\u578b\u51e0\u4e4e\u5728\u6240\u6709\u65b9\u9762\u90fd\u4f18\u4e8e\u672c\u4e66\u7b2c\u4e00\u7248 ","[Bloch01]"," \u4e2d\u63cf\u8ff0\u7684 typesafe \u679a\u4e3e\u6a21\u5f0f\u3002\u4ece\u8868\u9762\u4e0a\u770b\uff0c\u6709\u4e00\u4e2a\u4e0e\u53ef\u6269\u5c55\u6027\u6709\u5173\u7684\u4f8b\u5916\uff0c\u5b83\u5728\u5b57\u8282\u7801\u6a21\u5f0f\u4e0b\u662f\u53ef\u80fd\u7684\uff0c\u4f46\u662f\u8bed\u8a00\u6784\u9020\u4e0d\u652f\u6301\u3002\u6362\u53e5\u8bdd\u8bf4\uff0c\u4f7f\u7528\u5b57\u8282\u7801\u6a21\u5f0f\uff0c\u53ef\u4ee5\u8ba9\u4e00\u4e2a\u679a\u4e3e\u7c7b\u578b\u6269\u5c55\u53e6\u4e00\u4e2a\u679a\u4e3e\u7c7b\u578b\uff1b\u4f46\u4f7f\u7528\u8bed\u8a00\u7279\u6027\uff0c\u5219\u4e0d\u80fd\u8fd9\u6837\u3002\u8fd9\u5e76\u975e\u5076\u7136\u3002\u56e0\u4e3a\u5728\u5927\u591a\u6570\u60c5\u51b5\u4e0b\uff0c\u679a\u4e3e\u7684\u53ef\u6269\u5c55\u6027\u88ab\u8bc1\u660e\u662f\u4e00\u4e2a\u574f\u4e3b\u610f\uff0c\u4e3b\u8981\u5728\u4e8e\uff1a\u6269\u5c55\u7c7b\u578b\u7684\u5143\u7d20\u662f\u57fa\u7c7b\u7684\u5b9e\u4f8b\uff0c\u800c\u57fa\u7c7b\u7684\u5b9e\u4f8b\u5374\u4e0d\u662f\u6269\u5c55\u7c7b\u578b\u7684\u5143\u7d20\u3002\u800c\u4e14\u6ca1\u6709\u4e00\u79cd\u597d\u65b9\u6cd5\u53ef\u4ee5\u679a\u4e3e\u57fa\u7c7b\u53ca\u5176\u6269\u5c55\u7684\u6240\u6709\u5143\u7d20\u3002\u6700\u540e\uff0c\u53ef\u6269\u5c55\u6027\u4f1a\u4f7f\u8bbe\u8ba1\u548c\u5b9e\u73b0\u7684\u8bb8\u591a\u65b9\u9762\u53d8\u5f97\u590d\u6742\u3002"),(0,o.kt)("p",null,"That said, there is at least one compelling use case for extensible enumerated types, which is operation codes, also known as opcodes. An opcode is an enumerated type whose elements represent operations on some machine, such as the Operation type in Item 34, which represents the functions on a simple calculator. Sometimes it is desirable to let the users of an API provide their own operations, effectively extending the set of operations provided by the API."),(0,o.kt)("p",null,"\u4e5f\u5c31\u662f\u8bf4\uff0c\u5bf9\u4e8e\u53ef\u6269\u5c55\u679a\u4e3e\u7c7b\u578b\uff0c\u81f3\u5c11\u6709\u4e00\u4e2a\u4ee4\u4eba\u4fe1\u670d\u7684\u7528\u4f8b\uff0c\u5373\u64cd\u4f5c\u7801\uff0c\u4e5f\u79f0\u4e3a opcodes\u3002\u64cd\u4f5c\u7801\u662f\u4e00\u79cd\u679a\u4e3e\u7c7b\u578b\uff0c\u5176\u5143\u7d20\u8868\u793a\u67d0\u4e9b\u673a\u5668\u4e0a\u7684\u64cd\u4f5c\uff0c\u4f8b\u5982 ",(0,o.kt)("a",{parentName:"p",href:"./Chapter-6-Item-34-Use-enums-instead-of-int-constants"},"Item-34")," \u4e2d\u7684 Operation \u7c7b\uff0c\u5b83\u8868\u793a\u7b80\u5355\u8ba1\u7b97\u5668\u4e0a\u7684\u51fd\u6570\u3002\u6709\u65f6\u5019\uff0c\u6211\u4eec\u5e0c\u671b API \u7684\u7528\u6237\u63d0\u4f9b\u81ea\u5df1\u7684\u64cd\u4f5c\uff0c\u4ece\u800c\u6709\u6548\u5730\u6269\u5c55 API \u63d0\u4f9b\u7684\u64cd\u4f5c\u96c6\u3002"),(0,o.kt)("p",null,"Luckily, there is a nice way to achieve this effect using enum types. The basic idea is to take advantage of the fact that enum types can implement arbitrary interfaces by defining an interface for the opcode type and an enum that is the standard implementation of the interface. For example, here is an extensible version of the Operation type from Item 34:"),(0,o.kt)("p",null,"\u5e78\u8fd0\u7684\u662f\uff0c\u6709\u4e00\u79cd\u5f88\u597d\u7684\u65b9\u6cd5\u53ef\u4ee5\u4f7f\u7528\u679a\u4e3e\u7c7b\u578b\u6765\u5b9e\u73b0\u8fd9\u79cd\u6548\u679c\u3002\u5176\u57fa\u672c\u601d\u60f3\u662f\u5229\u7528\u679a\u4e3e\u7c7b\u578b\u53ef\u4ee5\u5b9e\u73b0\u4efb\u610f\u63a5\u53e3\u8fd9\u4e00\u4e8b\u5b9e\uff0c\u4e3a opcode \u7c7b\u578b\u5b9a\u4e49\u4e00\u4e2a\u63a5\u53e3\uff0c\u5e76\u4e3a\u63a5\u53e3\u7684\u6807\u51c6\u5b9e\u73b0\u5b9a\u4e49\u4e00\u4e2a\u679a\u4e3e\u3002\u4f8b\u5982\uff0c\u4e0b\u9762\u662f ",(0,o.kt)("a",{parentName:"p",href:"./Chapter-6-Item-34-Use-enums-instead-of-int-constants"},"Item-34")," Operation \u7c7b\u7684\u53ef\u6269\u5c55\u7248\u672c\uff1a"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'// Emulated extensible enum using an interface\npublic interface Operation {\n    double apply(double x, double y);\n}\n\npublic enum BasicOperation implements Operation {\n    PLUS("+") {\n        public double apply(double x, double y) { return x + y; }\n    },\n    MINUS("-") {\n        public double apply(double x, double y) { return x - y; }\n    },\n    TIMES("*") {\n        public double apply(double x, double y) { return x * y; }\n    },\n    DIVIDE("/") {\n        public double apply(double x, double y) { return x / y; }\n    };\n\n    private final String symbol;\n\n    BasicOperation(String symbol) {\n        this.symbol = symbol;\n    }\n\n    @Override\n    public String toString() {\n        return symbol;\n    }\n}\n')),(0,o.kt)("p",null,"While the enum type (BasicOperation) is not extensible, the interface type (Operation) is, and it is the interface type that is used to represent operations in APIs. You can define another enum type that implements this interface and use instances of this new type in place of the base type. For example, suppose you want to define an extension to the operation type shown earlier, consisting of the exponentiation and remainder operations. All you have to do is write an enum type that implements the Operation interface:"),(0,o.kt)("p",null,"\u679a\u4e3e\u7c7b\u578b\uff08BasicOperation\uff09\u662f\u4e0d\u53ef\u6269\u5c55\u7684\uff0c\u800c\u63a5\u53e3\u7c7b\u578b\uff08Operation\uff09\u662f\u53ef\u6269\u5c55\u7684\uff0c\u5b83\u662f\u7528\u4e8e\u5728 API \u4e2d\u8868\u793a\u64cd\u4f5c\u7684\u63a5\u53e3\u7c7b\u578b\u3002\u4f60\u53ef\u4ee5\u5b9a\u4e49\u53e6\u4e00\u4e2a\u5b9e\u73b0\u6b64\u63a5\u53e3\u7684\u679a\u4e3e\u7c7b\u578b\uff0c\u5e76\u4f7f\u7528\u6b64\u65b0\u7c7b\u578b\u7684\u5b9e\u4f8b\u4ee3\u66ff\u57fa\u7c7b\u578b\u3002\u4f8b\u5982\uff0c\u5047\u8bbe\u4f60\u60f3\u5b9a\u4e49\u524d\u9762\u663e\u793a\u7684\u64cd\u4f5c\u7c7b\u578b\u7684\u6269\u5c55\uff0c\u5305\u62ec\u6c42\u5e42\u548c\u4f59\u6570\u64cd\u4f5c\u3002\u4f60\u6240\u8981\u505a\u7684\u5c31\u662f\u5199\u4e00\u4e2a\u679a\u4e3e\u7c7b\u578b\uff0c\u5b9e\u73b0\u64cd\u4f5c\u63a5\u53e3\uff1a"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'// Emulated extension enum\npublic enum ExtendedOperation implements Operation {\n    EXP("^") {\n        public double apply(double x, double y) {\n            return Math.pow(x, y);\n        }\n    },\n    REMAINDER("%") {\n        public double apply(double x, double y) {\n            return x % y;\n        }\n    };\n\n    private final String symbol;\n\n    ExtendedOperation(String symbol) {\n        this.symbol = symbol;\n    }\n\n    @Override\n    public String toString() {\n        return symbol;\n    }\n}\n')),(0,o.kt)("p",null,"You can now use your new operations anywhere you could use the basic operations, provided that APIs are written to take the interface type (Operation), not the implementation (BasicOperation). Note that you don\u2019t have to declare the abstract apply method in the enum as you do in a nonextensible enum with instance-specific method implementations (page 162). This is because the abstract method (apply) is a member of the interface (Operation)."),(0,o.kt)("p",null,"\u73b0\u5728\u53ef\u4ee5\u5728\u4efb\u4f55\u53ef\u4ee5\u4f7f\u7528 Operation \u7684\u5730\u65b9\u4f7f\u7528\u65b0 Operation\uff0c\u524d\u63d0\u662f\u7f16\u5199\u7684 API \u91c7\u7528\u63a5\u53e3\u7c7b\u578b\uff08Operation\uff09\uff0c\u800c\u4e0d\u662f\u5b9e\u73b0\uff08BasicOperation\uff09\u3002\u6ce8\u610f\uff0c\u4e0d\u5fc5\u50cf\u5728\u5177\u6709\u7279\u5b9a\u4e8e\u5b9e\u4f8b\u7684\u65b9\u6cd5\u5b9e\u73b0\u7684\u975e\u53ef\u6269\u5c55\u679a\u4e3e\u4e2d\u90a3\u6837\u5728\u679a\u4e3e\u4e2d\u58f0\u660e\u62bd\u8c61 apply \u65b9\u6cd5\uff08\u7b2c 162 \u9875\uff09\u3002\u8fd9\u662f\u56e0\u4e3a\u62bd\u8c61\u65b9\u6cd5\uff08apply\uff09\u662f\u63a5\u53e3\uff08Operation\uff09\u7684\u6210\u5458\u3002"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"\u8bd1\u6ce8\uff1a\u793a\u4f8b\u5982\u4e0b")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"public static void main(String[] args) {\n    Operation op = BasicOperation.DIVIDE;\n    System.out.println(op.apply(15, 3));\n    op=ExtendedOperation.EXP;\n    System.out.println(op.apply(2,5));\n}\n")),(0,o.kt)("p",null,"Not only is it possible to pass a single instance of an \u201cextension enum\u201d anywhere a \u201cbase enum\u201d is expected, but it is possible to pass in an entire extension enum type and use its elements in addition to or instead of those of the base type. For example, here is a version of the test program on page 163 that exercises all of the extended operations defined previously:"),(0,o.kt)("p",null,"\u4e0d\u4ec5\u53ef\u4ee5\u5728\u9700\u8981\u300c\u57fa\u679a\u4e3e\u300d\u7684\u4efb\u4f55\u5730\u65b9\u4f20\u9012\u300c\u6269\u5c55\u679a\u4e3e\u300d\u7684\u5355\u4e2a\u5b9e\u4f8b\uff0c\u8fd8\u53ef\u4ee5\u4f20\u5165\u6574\u4e2a\u6269\u5c55\u679a\u4e3e\u7c7b\u578b\uff0c\u5e76\u5728\u57fa\u7c7b\u578b\u7684\u5143\u7d20\u4e4b\u5916\u4f7f\u7528\u6216\u66ff\u4ee3\u57fa\u7c7b\u578b\u7684\u5143\u7d20\u3002\u4f8b\u5982\uff0c\u8fd9\u91cc\u662f 163 \u9875\u6d4b\u8bd5\u7a0b\u5e8f\u7684\u4e00\u4e2a\u7248\u672c\uff0c\u5b83\u6267\u884c\u4e86\u524d\u9762\u5b9a\u4e49\u7684\u6240\u6709\u6269\u5c55\u64cd\u4f5c\uff1a"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'public static void main(String[] args) {\n    double x = Double.parseDouble(args[0]);\n    double y = Double.parseDouble(args[1]);\n    test(ExtendedOperation.class, x, y);\n}\n\nprivate static <T extends Enum<T> & Operation> void test(Class<T> opEnumType, double x, double y) {\n    for (Operation op : opEnumType.getEnumConstants())\n        System.out.printf("%f %s %f = %f%n",x, op, y, op.apply(x, y));\n}\n')),(0,o.kt)("p",null,"Note that the class literal for the extended operation type (ExtendedOperation.class) is passed from main to test to describe the set of extended operations. The class literal serves as a bounded type token (Item 33). The admittedly complex declaration for the opEnumType parameter (",(0,o.kt)("inlineCode",{parentName:"p"},"<T extends Enum<T> & Operation> Class<T>"),") ensures that the Class object represents both an enum and a subtype of Operation, which is exactly what is required to iterate over the elements and perform the operation associated with each one."),(0,o.kt)("p",null,"\u6ce8\u610f\uff0c\u6269\u5c55 Operation \u7c7b\u578b\uff08ExtendedOperation.class\uff09\u7684 class \u5b57\u9762\u91cf\u662f\u4ece main \u4f20\u9012\u5230 test \u7684\uff0c\u4ee5\u63cf\u8ff0\u6269\u5c55 Operation \u7c7b\u578b\u7684 Set\u3002class \u5b57\u9762\u91cf\u7528\u4f5c\u6709\u754c\u7c7b\u578b\u6807\u8bb0\uff08",(0,o.kt)("a",{parentName:"p",href:"./Chapter-5-Item-33-Consider-typesafe-heterogeneous-containers"},"Item-33"),"\uff09\u3002\u8bda\u7136\uff0copEnumType \u53c2\u6570\u7684\u590d\u6742\u58f0\u660e\uff08",(0,o.kt)("inlineCode",{parentName:"p"},"<T extends Enum<T> & Operation> Class<T>"),"\uff09\u786e\u4fdd\u7c7b\u5bf9\u8c61\u540c\u65f6\u8868\u793a\u679a\u4e3e\u548c Operation \u7684\u5b50\u7c7b\u578b\uff0c\u800c\u8fd9\u6b63\u662f\u904d\u5386\u5143\u7d20\u5e76\u6267\u884c\u4e0e\u6bcf\u4e2a\u5143\u7d20\u76f8\u5173\u7684\u64cd\u4f5c\u6240\u5fc5\u9700\u7684\u3002"),(0,o.kt)("p",null,"A second alternative is to pass a ",(0,o.kt)("inlineCode",{parentName:"p"},"Collection<? extends Operation>"),", which is a bounded wildcard type (Item 31), instead of passing a class object:"),(0,o.kt)("p",null,"\u7b2c\u4e8c\u4e2a\u9009\u62e9\u662f\u4f20\u9012\u4e00\u4e2a ",(0,o.kt)("inlineCode",{parentName:"p"},"Collection<? extends Operation>"),"\uff0c\u5b83\u662f\u4e00\u4e2a\u6709\u754c\u901a\u914d\u7b26\u7c7b\u578b\uff08",(0,o.kt)("a",{parentName:"p",href:"./Chapter-5-Item-31-Use-bounded-wildcards-to-increase-API-flexibility"},"Item-31"),"\uff09\uff0c\u800c\u4e0d\u662f\u4f20\u9012\u4e00\u4e2a\u7c7b\u5bf9\u8c61\uff1a"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'public static void main(String[] args) {\n    double x = Double.parseDouble(args[0]);\n    double y = Double.parseDouble(args[1]);\n    test(Arrays.asList(ExtendedOperation.values()), x, y);\n}\n\nprivate static void test(Collection<? extends Operation> opSet,double x, double y) {\n    for (Operation op : opSet)\n        System.out.printf("%f %s %f = %f%n",x, op, y, op.apply(x, y));\n}\n')),(0,o.kt)("p",null,"The resulting code is a bit less complex, and the test method is a bit more flexible: it allows the caller to combine operations from multiple implementation types. On the other hand, you forgo the ability to use EnumSet (Item 36) and EnumMap (Item 37) on the specified operations."),(0,o.kt)("p",null,"\u751f\u6210\u7684\u4ee3\u7801\u7a0d\u5fae\u4e0d\u90a3\u4e48\u590d\u6742\uff0ctest \u65b9\u6cd5\u7a0d\u5fae\u7075\u6d3b\u4e00\u4e9b\uff1a\u5b83\u5141\u8bb8\u8c03\u7528\u8005\u7ec4\u5408\u6765\u81ea\u591a\u4e2a\u5b9e\u73b0\u7c7b\u578b\u7684\u64cd\u4f5c\u3002\u53e6\u4e00\u65b9\u9762\uff0c\u653e\u5f03\u4e86\u5728\u6307\u5b9a\u64cd\u4f5c\u4e0a\u4f7f\u7528 EnumSet\uff08",(0,o.kt)("a",{parentName:"p",href:"./Chapter-6-Item-36-Use-EnumSet-instead-of-bit-fields"},"Item-36"),"\uff09\u548c EnumMap\uff08",(0,o.kt)("a",{parentName:"p",href:"./Chapter-6-Item-37-Use-EnumMap-instead-of-ordinal-indexing"},"Item-37"),"\uff09\u7684\u80fd\u529b\u3002"),(0,o.kt)("p",null,"Both programs shown previously will produce this output when run with command line arguments 4 and 2:"),(0,o.kt)("p",null,"\u5728\u8fd0\u884c\u547d\u4ee4\u884c\u53c2\u6570 4 \u548c 2 \u65f6\uff0c\u524d\u9762\u663e\u793a\u7684\u4e24\u4e2a\u7a0b\u5e8f\u90fd\u5c06\u4ea7\u751f\u8fd9\u4e2a\u8f93\u51fa\uff1a"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"4.000000 ^ 2.000000 = 16.000000\n4.000000 % 2.000000 = 0.000000\n")),(0,o.kt)("p",null,"A minor disadvantage of the use of interfaces to emulate extensible enums is that implementations cannot be inherited from one enum type to another. If the implementation code does not rely on any state, it can be placed in the interface, using default implementations (Item 20). In the case of our Operation example, the logic to store and retrieve the symbol associated with an operation must be duplicated in BasicOperation and ExtendedOperation. In this case it doesn\u2019t matter because very little code is duplicated. If there were a larger amount of shared functionality, you could encapsulate it in a helper class or a static helper method to eliminate the code duplication."),(0,o.kt)("p",null,"\u4f7f\u7528\u63a5\u53e3\u6765\u6a21\u62df\u53ef\u6269\u5c55\u679a\u4e3e\u7684\u4e00\u4e2a\u5c0f\u7f3a\u70b9\u662f\u5b9e\u73b0\u4e0d\u80fd\u4ece\u4e00\u4e2a\u679a\u4e3e\u7c7b\u578b\u7ee7\u627f\u5230\u53e6\u4e00\u4e2a\u679a\u4e3e\u7c7b\u578b\u3002\u5982\u679c\u5b9e\u73b0\u4ee3\u7801\u4e0d\u4f9d\u8d56\u4e8e\u4efb\u4f55\u72b6\u6001\uff0c\u5219\u53ef\u4ee5\u4f7f\u7528\u9ed8\u8ba4\u5b9e\u73b0\uff08",(0,o.kt)("a",{parentName:"p",href:"./Chapter-4-Item-20-Prefer-interfaces-to-abstract-classes"},"Item-20"),"\uff09\u5c06\u5176\u653e\u7f6e\u5728\u63a5\u53e3\u4e2d\u3002\u5728\u6211\u4eec\u7684 Operation \u793a\u4f8b\u4e2d\uff0c\u5b58\u50a8\u548c\u68c0\u7d22\u4e0e\u64cd\u4f5c\u76f8\u5173\u7684\u7b26\u53f7\u7684\u903b\u8f91\u5fc5\u987b\u5728 BasicOperation \u548c ExtendedOperation \u4e2d\u590d\u5236\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u8fd9\u5e76\u4e0d\u91cd\u8981\uff0c\u56e0\u4e3a\u590d\u5236\u7684\u4ee3\u7801\u975e\u5e38\u5c11\u3002\u5982\u679c\u6709\u5927\u91cf\u7684\u5171\u4eab\u529f\u80fd\uff0c\u53ef\u4ee5\u5c06\u5176\u5c01\u88c5\u5728 helper \u7c7b\u6216\u9759\u6001 helper \u65b9\u6cd5\u4e2d\uff0c\u4ee5\u6d88\u9664\u4ee3\u7801\u91cd\u590d\u3002"),(0,o.kt)("p",null,"The pattern described in this item is used in the Java libraries. For example, the java.nio.file.LinkOption enum type implements the CopyOption and OpenOption interfaces."),(0,o.kt)("p",null,"\u6b64\u9879\u4e2d\u63cf\u8ff0\u7684\u6a21\u5f0f\u5728 Java \u5e93\u4e2d\u4f7f\u7528\u3002\u4f8b\u5982\uff0c",(0,o.kt)("inlineCode",{parentName:"p"},"java.nio.file.LinkOption")," \u679a\u4e3e\u7c7b\u578b\u5b9e\u73b0 CopyOption \u548c OpenOption \u63a5\u53e3\u3002"),(0,o.kt)("p",null,"In summary, ",(0,o.kt)("strong",{parentName:"p"},"while you cannot write an extensible enum type, you can emulate it by writing an interface to accompany a basic enum type that implements the interface.")," This allows clients to write their own enums (or other types) that implement the interface. Instances of these types can then be used wherever instances of the basic enum type can be used, assuming APIs are written in terms of the interface."),(0,o.kt)("p",null,"\u603b\u4e4b\uff0c\u867d\u7136\u4f60\u4e0d\u80fd\u7f16\u5199\u53ef\u6269\u5c55\u679a\u4e3e\u7c7b\u578b\uff0c\u4f46\u662f\u4f60\u53ef\u4ee5\u901a\u8fc7\u7f16\u5199\u63a5\u53e3\u6765\u6a21\u62df\u5b83\uff0c\u4ee5\u4fbf\u4e0e\u5b9e\u73b0\u8be5\u63a5\u53e3\u7684\u57fa\u672c\u679a\u4e3e\u7c7b\u578b\u4e00\u8d77\u4f7f\u7528\u3002\u8fd9\u5141\u8bb8\u5ba2\u6237\u7aef\u7f16\u5199\u81ea\u5df1\u7684\u679a\u4e3e\uff08\u6216\u5176\u4ed6\u7c7b\u578b\uff09\u6765\u5b9e\u73b0\u63a5\u53e3\u3002\u5047\u8bbe API \u662f\u6839\u636e\u63a5\u53e3\u7f16\u5199\u7684\uff0c\u90a3\u4e48\u8fd9\u4e9b\u7c7b\u578b\u7684\u5b9e\u4f8b\u53ef\u4ee5\u5728\u4efb\u4f55\u53ef\u4ee5\u4f7f\u7528\u57fa\u672c\u679a\u4e3e\u7c7b\u578b\u7684\u5b9e\u4f8b\u7684\u5730\u65b9\u4f7f\u7528\u3002"),(0,o.kt)("hr",null),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("a",{parentName:"strong",href:"./Chapter-6-Introduction"},"Back to contents of the chapter\uff08\u8fd4\u56de\u7ae0\u8282\u76ee\u5f55\uff09"))),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Previous Item\uff08\u4e0a\u4e00\u6761\u76ee\uff09\uff1a",(0,o.kt)("a",{parentName:"strong",href:"./Chapter-6-Item-37-Use-EnumMap-instead-of-ordinal-indexing"},"Item 37: Use EnumMap instead of ordinal indexing\uff08\u4f7f\u7528 EnumMap \u66ff\u6362\u5e8f\u6570\u7d22\u5f15\uff09"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Next Item\uff08\u4e0b\u4e00\u6761\u76ee\uff09\uff1a",(0,o.kt)("a",{parentName:"strong",href:"./Chapter-6-Item-39-Prefer-annotations-to-naming-patterns"},"Item 39: Prefer annotations to naming patterns\uff08\u6ce8\u89e3\u4f18\u4e8e\u547d\u540d\u6a21\u5f0f\uff09")))))}m.isMDXComponent=!0}}]);