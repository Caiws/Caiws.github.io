"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[9976],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>m});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function r(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},c=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,s=e.originalType,l=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),u=p(a),m=i,d=u["".concat(l,".").concat(m)]||u[m]||h[m]||s;return a?n.createElement(d,o(o({ref:t},c),{},{components:a})):n.createElement(d,o({ref:t},c))}));function m(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var s=a.length,o=new Array(s);o[0]=u;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:i,o[1]=r;for(var p=2;p<s;p++)o[p]=a[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},8420:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>p});var n=a(7462),i=(a(7294),a(3905));const s={},o=void 0,r={unversionedId:"Books/EffectiveJava3/Chapter-5/Chapter-5-Item-33-Consider-typesafe-heterogeneous-containers",id:"Books/EffectiveJava3/Chapter-5/Chapter-5-Item-33-Consider-typesafe-heterogeneous-containers",title:"Chapter-5-Item-33-Consider-typesafe-heterogeneous-containers",description:"Chapter 5. Generics\uff08\u6cdb\u578b\uff09",source:"@site/docs/Books/EffectiveJava3/Chapter-5/Chapter-5-Item-33-Consider-typesafe-heterogeneous-containers.md",sourceDirName:"Books/EffectiveJava3/Chapter-5",slug:"/Books/EffectiveJava3/Chapter-5/Chapter-5-Item-33-Consider-typesafe-heterogeneous-containers",permalink:"/docs/Books/EffectiveJava3/Chapter-5/Chapter-5-Item-33-Consider-typesafe-heterogeneous-containers",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Books/EffectiveJava3/Chapter-5/Chapter-5-Item-33-Consider-typesafe-heterogeneous-containers.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Chapter-5-Item-32-Combine-generics-and-varargs-judiciously",permalink:"/docs/Books/EffectiveJava3/Chapter-5/Chapter-5-Item-32-Combine-generics-and-varargs-judiciously"},next:{title:"Chapter-6-Introduction",permalink:"/docs/Books/EffectiveJava3/Chapter-6/Chapter-6-Introduction"}},l={},p=[{value:"Chapter 5. Generics\uff08\u6cdb\u578b\uff09",id:"chapter-5-generics\u6cdb\u578b",level:2},{value:"Item 33: Consider typesafe heterogeneous containers\uff08\u8003\u8651\u7c7b\u578b\u5b89\u5168\u7684\u5f02\u6784\u5bb9\u5668\uff09",id:"item-33-consider-typesafe-heterogeneous-containers\u8003\u8651\u7c7b\u578b\u5b89\u5168\u7684\u5f02\u6784\u5bb9\u5668",level:3}],c={toc:p};function h(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"chapter-5-generics\u6cdb\u578b"},"Chapter 5. Generics\uff08\u6cdb\u578b\uff09"),(0,i.kt)("h3",{id:"item-33-consider-typesafe-heterogeneous-containers\u8003\u8651\u7c7b\u578b\u5b89\u5168\u7684\u5f02\u6784\u5bb9\u5668"},"Item 33: Consider typesafe heterogeneous containers\uff08\u8003\u8651\u7c7b\u578b\u5b89\u5168\u7684\u5f02\u6784\u5bb9\u5668\uff09"),(0,i.kt)("p",null,"Common uses of generics include collections, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"Set<E>")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Map<K,V>"),", and single-element containers, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadLocal<T>")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"AtomicReference<T>"),". In all of these uses, it is the container that is parameterized. This limits you to a fixed number of type parameters per container. Normally that is exactly what you want. A Set has a single type parameter, representing its element type; a Map has two, representing its key and value types; and so forth."),(0,i.kt)("p",null,"\u96c6\u5408\u662f\u6cdb\u578b\u7684\u5e38\u89c1\u5e94\u7528\u4e4b\u4e00\uff0c\u5982 ",(0,i.kt)("inlineCode",{parentName:"p"},"Set<E>")," \u548c ",(0,i.kt)("inlineCode",{parentName:"p"},"Map<K,V>"),"\uff0c\u4ee5\u53ca\u5355\u5143\u7d20\u5bb9\u5668\uff0c\u5982 ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadLocal<T>")," \u548c ",(0,i.kt)("inlineCode",{parentName:"p"},"AtomicReference<T>"),"\u3002\u5728\u6240\u6709\u8fd9\u4e9b\u5e94\u7528\u4e2d\uff0c\u90fd\u662f\u53c2\u6570\u5316\u7684\u5bb9\u5668\u3002\u8fd9\u5c06\u6bcf\u4e2a\u5bb9\u5668\u7684\u7c7b\u578b\u53c2\u6570\u9650\u5236\u4e3a\u56fa\u5b9a\u6570\u91cf\u3002\u901a\u5e38\u8fd9\u6b63\u662f\u4f60\u60f3\u8981\u7684\u3002Set \u53ea\u6709\u4e00\u4e2a\u7c7b\u578b\u53c2\u6570\uff0c\u8868\u793a\u5176\u5143\u7d20\u7c7b\u578b\uff1bMap \u6709\u4e24\u4e2a\uff0c\u8868\u793a",(0,i.kt)("inlineCode",{parentName:"p"},"\u952e"),"\u548c",(0,i.kt)("inlineCode",{parentName:"p"},"\u503c"),"\u7684\u7c7b\u578b\uff1b\u5982\u6b64\u7b49\u7b49\u3002"),(0,i.kt)("p",null,"Sometimes, however, you need more flexibility. For example, a database row can have arbitrarily many columns, and it would be nice to be able to access all of them in a typesafe manner. Luckily, there is an easy way to achieve this effect. The idea is to parameterize the key instead of the container. Then present the parameterized key to the container to insert or retrieve a value. The generic type system is used to guarantee that the type of the value agrees with its key."),(0,i.kt)("p",null,"\u7136\u800c\uff0c\u6709\u65f6\u4f60\u9700\u8981\u66f4\u5927\u7684\u7075\u6d3b\u6027\u3002\u4f8b\u5982\uff0c\u4e00\u4e2a\u6570\u636e\u5e93\u884c\u53ef\u4ee5\u6709\u4efb\u610f\u591a\u5217\uff0c\u80fd\u591f\u4ee5\u7c7b\u578b\u5b89\u5168\u7684\u65b9\u5f0f\u8bbf\u95ee\u6240\u6709\u8fd9\u4e9b\u5217\u662f\u5f88\u597d\u7684\u3002\u5e78\u8fd0\u7684\u662f\uff0c\u6709\u4e00\u79cd\u7b80\u5355\u7684\u65b9\u6cd5\u53ef\u4ee5\u8fbe\u5230\u8fd9\u79cd\u6548\u679c\u3002\u5176\u601d\u60f3\u662f\u53c2\u6570\u5316",(0,i.kt)("inlineCode",{parentName:"p"},"\u952e"),"\u800c\u4e0d\u662f\u5bb9\u5668\u3002\u7136\u540e\u5411\u5bb9\u5668\u63d0\u4f9b\u53c2\u6570\u5316",(0,i.kt)("inlineCode",{parentName:"p"},"\u952e"),"\u4ee5\u63d2\u5165\u6216\u68c0\u7d22",(0,i.kt)("inlineCode",{parentName:"p"},"\u503c"),"\u3002\u6cdb\u578b\u7c7b\u578b\u7cfb\u7edf\u7528\u4e8e\u786e\u4fdd",(0,i.kt)("inlineCode",{parentName:"p"},"\u503c"),"\u7684\u7c7b\u578b\u4e0e",(0,i.kt)("inlineCode",{parentName:"p"},"\u952e"),"\u4e00\u81f4\u3002"),(0,i.kt)("p",null,"As a simple example of this approach, consider a Favorites class that allows its clients to store and retrieve a favorite instance of arbitrarily many types. The Class object for the type will play the part of the parameterized key. The reason this works is that class Class is generic. The type of a class literal is not simply Class, but ",(0,i.kt)("inlineCode",{parentName:"p"},"Class<T>"),". For example, String.class is of type ",(0,i.kt)("inlineCode",{parentName:"p"},"Class<String>"),", and Integer.class is of type ",(0,i.kt)("inlineCode",{parentName:"p"},"Class<Integer>"),". When a class literal is passed among methods to communicate both compiletime and runtime type information, it is called a type token ","[Bracha04]","."),(0,i.kt)("p",null,"\u4f5c\u4e3a\u8fd9\u79cd\u65b9\u6cd5\u7684\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u8003\u8651\u4e00\u4e2a Favorites \u7c7b\uff0c\u5b83\u5141\u8bb8\u5ba2\u6237\u7aef\u5b58\u50a8\u548c\u68c0\u7d22\u4efb\u610f\u591a\u79cd\u7c7b\u578b\u7684 Favorites \u5b9e\u4f8b\u3002Class \u7c7b\u7684\u5bf9\u8c61\u5c06\u626e\u6f14\u53c2\u6570\u5316",(0,i.kt)("inlineCode",{parentName:"p"},"\u952e"),"\u7684\u89d2\u8272\u3002\u8fd9\u6837\u505a\u7684\u539f\u56e0\u662f Class \u7c7b\u662f\u6cdb\u578b\u7684\u3002Class \u5bf9\u8c61\u7684\u7c7b\u578b\u4e0d\u4ec5\u4ec5\u662f Class\uff0c\u800c\u662f ",(0,i.kt)("inlineCode",{parentName:"p"},"Class<T>"),"\u3002\u4f8b\u5982\uff0cString.class \u7684\u7c7b\u578b\u4e3a ",(0,i.kt)("inlineCode",{parentName:"p"},"Class<String>"),"\u3001Integer.class \u7684\u7c7b\u578b\u4e3a ",(0,i.kt)("inlineCode",{parentName:"p"},"Class<Integer>"),"\u3002\u5728\u4f20\u9012\u7f16\u8bd1\u65f6\u548c\u8fd0\u884c\u65f6\u7c7b\u578b\u4fe1\u606f\u7684\u65b9\u6cd5\u4e4b\u95f4\u4f20\u9012\u7c7b Class \u5bf9\u8c61\u65f6\uff0c\u5b83\u88ab\u79f0\u4e3a\u7c7b\u578b\u6807\u8bb0","[Bracha04]","\u3002"),(0,i.kt)("p",null,"The API for the Favorites class is simple. It looks just like a simple map, except that the key is parameterized instead of the map. The client presents a Class object when setting and getting favorites. Here is the API:"),(0,i.kt)("p",null,"Favorites \u7c7b\u7684 API \u5f88\u7b80\u5355\u3002\u5b83\u770b\u8d77\u6765\u5c31\u50cf\u4e00\u4e2a\u7b80\u5355\u7684 Map\uff0c\u53ea\u4e0d\u8fc7",(0,i.kt)("inlineCode",{parentName:"p"},"\u952e"),"\u662f\u53c2\u6570\u5316\u7684\uff0c\u800c\u4e0d\u662f\u6574\u4e2a Map\u3002\u5ba2\u6237\u7aef\u5728\u8bbe\u7f6e\u548c\u83b7\u53d6 Favorites \u5b9e\u4f8b\u65f6\u663e\u793a\u4e00\u4e2a Class \u5bf9\u8c61\u3002\u4ee5\u4e0b\u662f API:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// Typesafe heterogeneous container pattern - API\npublic class Favorites {\n    public <T> void putFavorite(Class<T> type, T instance);\n    public <T> T getFavorite(Class<T> type);\n}\n")),(0,i.kt)("p",null,"Here is a sample program that exercises the Favorites class, storing, retrieving, and printing a favorite String, Integer, and Class instance:"),(0,i.kt)("p",null,"\u4e0b\u9762\u662f\u4e00\u4e2a\u793a\u4f8b\u7a0b\u5e8f\uff0c\u5b83\u6f14\u793a\u4e86 Favorites \u7c7b\u3001\u5b58\u50a8\u3001\u68c0\u7d22\u548c\u6253\u5370 Favorites \u5b57\u7b26\u4e32\u3001\u6574\u6570\u548c Class \u5b9e\u4f8b\uff1a"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'// Typesafe heterogeneous container pattern - client\npublic static void main(String[] args) {\n    Favorites f = new Favorites();\n    f.putFavorite(String.class, "Java");\n    f.putFavorite(Integer.class, 0xcafebabe);\n    f.putFavorite(Class.class, Favorites.class);\n    String favoriteString = f.getFavorite(String.class);\n    int favoriteInteger = f.getFavorite(Integer.class);\n    Class<?> favoriteClass = f.getFavorite(Class.class);\n    System.out.printf("%s %x %s%n", favoriteString,favoriteInteger, favoriteClass.getName());\n}\n')),(0,i.kt)("p",null,"As you would expect, this program prints Java cafebabe Favorites. Note, incidentally, that Java\u2019s printf method differs from C\u2019s in that you should use %n where you\u2019d use \\n in C. The %n generates the applicable platform-specific line separator, which is \\n on many but not all platforms."),(0,i.kt)("p",null,"\u5982\u4f60\u6240\u6599\uff0c\u8fd9\u4e2a\u7a0b\u5e8f\u6253\u5370 Java cafebabe Favorites\u3002\u987a\u4fbf\u63d0\u9192\u4e00\u4e0b\uff0cJava \u7684 printf \u65b9\u6cd5\u4e0e C \u7684\u4e0d\u540c\u4e4b\u5904\u5728\u4e8e\uff0c\u4f60\u5e94\u8be5\u5728 C \u4e2d\u4f7f\u7528 \\n \u7684\u5730\u65b9\u6539\u7528 %n\u3002"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"\u8bd1\u6ce8\uff1a",(0,i.kt)("inlineCode",{parentName:"strong"},"favoriteClass.getName()")," \u7684\u6253\u5370\u7ed3\u679c\u4e0e Favorites \u7c7b\u6240\u5728\u5305\u540d\u6709\u5173\uff0c\u7ed3\u679c\u5e94\u4e3a\uff1a\u5305\u540d.Favorites")),(0,i.kt)("p",null,"A Favorites instance is typesafe: it will never return an Integer when you ask it for a String. It is also heterogeneous: unlike an ordinary map, all the keys are of different types. Therefore, we call Favorites a typesafe heterogeneous container."),(0,i.kt)("p",null,"Favorites \u7684\u5b9e\u4f8b\u662f\u7c7b\u578b\u5b89\u5168\u7684\uff1a\u5f53\u4f60\u5411\u5b83\u8bf7\u6c42\u4e00\u4e2a String \u7c7b\u578b\u65f6\uff0c\u5b83\u6c38\u8fdc\u4e0d\u4f1a\u8fd4\u56de\u4e00\u4e2a Integer \u7c7b\u578b\u3002\u5b83\u4e5f\u662f\u5f02\u6784\u7684\uff1a\u4e0e\u666e\u901a Map \u4e0d\u540c\uff0c\u6240\u6709",(0,i.kt)("inlineCode",{parentName:"p"},"\u952e"),"\u90fd\u662f\u4e0d\u540c\u7c7b\u578b\u7684\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u5c06 Favorites \u79f0\u4e3a\u4e00\u4e2a\u7c7b\u578b\u5b89\u5168\u5f02\u6784\u5bb9\u5668\u3002"),(0,i.kt)("p",null,"The implementation of Favorites is surprisingly tiny. Here it is, in its entirety:"),(0,i.kt)("p",null,"Favorites \u7684\u5b9e\u73b0\u975e\u5e38\u7b80\u77ed\u3002\u4e0b\u9762\u662f\u5168\u90e8\u5185\u5bb9\uff1a"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// Typesafe heterogeneous container pattern - implementation\npublic class Favorites {\n  private Map<Class<?>, Object> favorites = new HashMap<>();\n\n  public <T> void putFavorite(Class<T> type, T instance) {\n    favorites.put(Objects.requireNonNull(type), instance);\n  }\n\n  public <T> T getFavorite(Class<T> type) {\n    return type.cast(favorites.get(type));\n  }\n}\n")),(0,i.kt)("p",null,"There are a few subtle things going on here. Each Favorites instance is backed by a private ",(0,i.kt)("inlineCode",{parentName:"p"},"Map<Class<?>, Object>")," called favorites. You might think that you couldn\u2019t put anything into this Map because of the unbounded wildcard type, but the truth is quite the opposite. The thing to notice is that the wildcard type is nested: it\u2019s not the type of the map that\u2019s a wildcard type but the type of its key. This means that every key can have a different parameterized type: one can be ",(0,i.kt)("inlineCode",{parentName:"p"},"Class<String>"),", the next ",(0,i.kt)("inlineCode",{parentName:"p"},"Class<Integer>"),", and so on. That\u2019s where the heterogeneity comes from."),(0,i.kt)("p",null,"\u8fd9\u91cc\u53d1\u751f\u4e86\u4e00\u4e9b\u5fae\u5999\u7684\u4e8b\u60c5\u3002\u6bcf\u4e2a Favorites \u5b9e\u4f8b\u90fd\u7531\u4e00\u4e2a\u540d\u4e3a favorites \u7684\u79c1\u6709 ",(0,i.kt)("inlineCode",{parentName:"p"},"Map<Class<?>, Object>")," \u652f\u6301\u3002\u4f60\u53ef\u80fd\u8ba4\u4e3a\u7531\u4e8e\u901a\u914d\u7b26\u7c7b\u578b\u662f\u65e0\u754c\u7684\uff0c\u6240\u4ee5\u65e0\u6cd5\u5c06\u4efb\u4f55\u5185\u5bb9\u653e\u5165\u6b64\u6620\u5c04\u4e2d\uff0c\u4f46\u4e8b\u5b9e\u6070\u6070\u76f8\u53cd\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u901a\u914d\u7b26\u7c7b\u578b\u662f\u5d4c\u5957\u7684\uff1a\u901a\u914d\u7b26\u7c7b\u578b\u4e0d\u662f Map \u7684\u7c7b\u578b\uff0c\u800c\u662f",(0,i.kt)("inlineCode",{parentName:"p"},"\u952e"),"\u7684\u7c7b\u578b\u3002\u8fd9\u610f\u5473\u7740\u6bcf\u4e2a",(0,i.kt)("inlineCode",{parentName:"p"},"\u952e"),"\u90fd\u53ef\u4ee5\u6709\u4e0d\u540c\u7684\u53c2\u6570\u5316\u7c7b\u578b\uff1a\u4e00\u4e2a\u53ef\u4ee5\u662f ",(0,i.kt)("inlineCode",{parentName:"p"},"Class<String>"),"\uff0c\u4e0b\u4e00\u4e2a\u662f ",(0,i.kt)("inlineCode",{parentName:"p"},"Class<Integer>"),"\uff0c\u7b49\u7b49\u3002\u8fd9\u5c31\u662f\u5f02\u6784\u7684\u539f\u7406\u3002"),(0,i.kt)("p",null,"The next thing to notice is that the value type of the favorites Map is simply Object. In other words, the Map does not guarantee the type relationship between keys and values, which is that every value is of the type represented by its key. In fact, Java\u2019s type system is not powerful enough to express this. But we know that it\u2019s true, and we take advantage of it when the time comes to retrieve a favorite."),(0,i.kt)("p",null,"\u63a5\u4e0b\u6765\u8981\u6ce8\u610f\u7684\u662f favorites \u7684",(0,i.kt)("inlineCode",{parentName:"p"},"\u503c"),"\u7c7b\u578b\u4ec5\u4ec5\u662f Object\u3002\u6362\u53e5\u8bdd\u8bf4\uff0cMap \u4e0d\u4fdd\u8bc1",(0,i.kt)("inlineCode",{parentName:"p"},"\u952e"),"\u548c",(0,i.kt)("inlineCode",{parentName:"p"},"\u503c"),"\u4e4b\u95f4\u7684\u7c7b\u578b\u5173\u7cfb\uff0c\u5373\u6bcf\u4e2a",(0,i.kt)("inlineCode",{parentName:"p"},"\u503c"),"\u90fd\u662f\u5176",(0,i.kt)("inlineCode",{parentName:"p"},"\u952e"),"\u6240\u8868\u793a\u7684\u7c7b\u578b\u3002\u5b9e\u9645\u4e0a\uff0cJava \u7684\u7c7b\u578b\u7cfb\u7edf\u8fd8\u6ca1\u6709\u5f3a\u5927\u5230\u8db3\u4ee5\u8868\u8fbe\u8fd9\u4e00\u70b9\u3002\u4f46\u662f\u6211\u4eec\u77e5\u9053\u8fd9\u662f\u4e8b\u5b9e\uff0c\u5f53\u9700\u8981\u68c0\u7d22\u4e00\u4e2a favorite \u65f6\uff0c\u6211\u4eec\u4f1a\u5229\u7528\u5b83\u3002"),(0,i.kt)("p",null,"The putFavorite implementation is trivial: it simply puts into favorites a mapping from the given Class object to the given favorite instance. As noted, this discards the \u201ctype linkage\u201d between the key and the value; it loses the knowledge that the value is an instance of the key. But that\u2019s OK, because the getFavorites method can and does reestablish this linkage."),(0,i.kt)("p",null,"putFavorite \u7684\u5b9e\u73b0\u5f88\u7b80\u5355\uff1a\u5b83\u53ea\u662f\u5c06\u4ece\u7ed9\u5b9a Class \u5bf9\u8c61\u5230\u7ed9\u5b9a Favorites \u5b9e\u4f8b\u7684\u653e\u5165 favorites \u4e2d\u3002\u5982\u524d\u6240\u8ff0\uff0c\u8fd9\u5c06\u4e22\u5f03",(0,i.kt)("inlineCode",{parentName:"p"},"\u952e"),"\u548c",(0,i.kt)("inlineCode",{parentName:"p"},"\u503c"),"\u4e4b\u95f4\u7684\u300c\u7c7b\u578b\u5173\u8054\u300d\uff1b\u5c06\u65e0\u6cd5\u786e\u5b9a",(0,i.kt)("inlineCode",{parentName:"p"},"\u503c"),"\u662f",(0,i.kt)("inlineCode",{parentName:"p"},"\u952e"),"\u7684\u5b9e\u4f8b\u3002\u4f46\u8fd9\u6ca1\u5173\u7cfb\uff0c\u56e0\u4e3a getFavorites \u65b9\u6cd5\u53ef\u4ee5\u91cd\u65b0\u5efa\u7acb\u8fd9\u4e2a\u5173\u8054\u3002"),(0,i.kt)("p",null,"The implementation of getFavorite is trickier than that of putFavorite. First, it gets from the favorites map the value corresponding to the given Class object. This is the correct object reference to return, but it has the wrong compile-time type: it is Object (the value type of the favorites map) and we need to return a T. So, the getFavorite implementation dynamically casts the object reference to the type represented by the Class object, using Class\u2019s cast method."),(0,i.kt)("p",null,"getFavorite \u7684\u5b9e\u73b0\u6bd4 putFavorite \u7684\u5b9e\u73b0\u66f4\u590d\u6742\u3002\u9996\u5148\uff0c\u5b83\u4ece favorites \u4e2d\u83b7\u53d6\u4e0e\u7ed9\u5b9a Class \u5bf9\u8c61\u5bf9\u5e94\u7684",(0,i.kt)("inlineCode",{parentName:"p"},"\u503c"),"\u3002\u8fd9\u662f\u6b63\u786e\u7684\u5bf9\u8c61\u5f15\u7528\u8fd4\u56de\uff0c\u4f46\u5b83\u6709\u9519\u8bef\u7684\u7f16\u8bd1\u65f6\u7c7b\u578b\uff1a\u5b83\u662f Object\uff08favorites \u7684",(0,i.kt)("inlineCode",{parentName:"p"},"\u503c"),"\u7c7b\u578b\uff09\uff0c\u6211\u4eec\u9700\u8981\u8fd4\u56de\u4e00\u4e2a T\u3002\u56e0\u6b64\uff0cgetFavorite \u7684\u5b9e\u73b0\u901a\u8fc7\u4f7f\u7528 Class \u7684 cast \u65b9\u6cd5\uff0c\u5c06\u5bf9\u8c61\u5f15\u7528\u7c7b\u578b\u52a8\u6001\u8f6c\u5316\u4e3a\u6240\u4ee3\u8868\u7684 Class \u5bf9\u8c61\u3002"),(0,i.kt)("p",null,"The cast method is the dynamic analogue of Java\u2019s cast operator. It simply checks that its argument is an instance of the type represented by the Class object. If so, it returns the argument; otherwise it throws a ClassCastException. We know that the cast invocation in getFavorite won\u2019t throw ClassCastException, assuming the client code compiled cleanly. That is to say, we know that the values in the favorites map always match the types of their keys."),(0,i.kt)("p",null,"cast \u65b9\u6cd5\u662f Java \u7684 cast \u8fd0\u7b97\u7b26\u7684\u52a8\u6001\u6a21\u62df\u3002\u5b83\u53ea\u662f\u68c0\u67e5\u5b83\u7684\u53c2\u6570\u662f\u5426\u662f\u7c7b\u5bf9\u8c61\u8868\u793a\u7684\u7c7b\u578b\u7684\u5b9e\u4f8b\u3002\u5982\u679c\u662f\uff0c\u5219\u8fd4\u56de\u53c2\u6570\uff1b\u5426\u5219\u5b83\u5c06\u629b\u51fa ClassCastException\u3002\u6211\u4eec\u77e5\u9053 getFavorite \u4e2d\u7684\u5f3a\u5236\u8f6c\u6362\u8c03\u7528\u4e0d\u4f1a\u629b\u51fa ClassCastException\uff0c\u5047\u8bbe\u5ba2\u6237\u7aef\u4ee3\u7801\u5df2\u6b63\u786e\u5730\u7f16\u8bd1\u3002\u4e5f\u5c31\u662f\u8bf4\uff0c\u6211\u4eec\u77e5\u9053 favorites \u4e2d\u7684",(0,i.kt)("inlineCode",{parentName:"p"},"\u503c"),"\u603b\u662f\u4e0e\u5176",(0,i.kt)("inlineCode",{parentName:"p"},"\u952e"),"\u7684\u7c7b\u578b\u5339\u914d\u3002"),(0,i.kt)("p",null,"So what does the cast method do for us, given that it simply returns its argument? The signature of the cast method takes full advantage of the fact that class Class is generic. Its return type is the type parameter of the Class object:"),(0,i.kt)("p",null,"\u5982\u679c cast \u65b9\u6cd5\u53ea\u662f\u8fd4\u56de\u5b83\u7684\u53c2\u6570\uff0c\u90a3\u4e48\u5b83\u4f1a\u4e3a\u6211\u4eec\u505a\u4ec0\u4e48\u5462\uff1fcast \u65b9\u6cd5\u7684\u7b7e\u540d\u5145\u5206\u5229\u7528\u4e86 Class \u7c7b\u662f\u6cdb\u578b\u7684\u8fd9\u4e00\u4e8b\u5b9e\u3002\u5176\u8fd4\u56de\u7c7b\u578b\u4e3a Class \u5bf9\u8c61\u7684\u7c7b\u578b\u53c2\u6570\uff1a"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"public class Class<T> {\n    T cast(Object obj);\n}\n")),(0,i.kt)("p",null,"This is precisely what\u2019s needed by the getFavorite method. It is what allows us to make Favorites typesafe without resorting to an unchecked cast to T."),(0,i.kt)("p",null,"\u8fd9\u6b63\u662f getFavorite \u65b9\u6cd5\u6240\u9700\u8981\u7684\u3002\u5b83\u4f7f\u6211\u4eec\u80fd\u591f\u4f7f Favorites \u7c7b\u578b\u5b89\u5168\uff0c\u800c\u4e0d\u9700\u8981\u5bf9 T \u8fdb\u884c unchecked \u7684\u8f6c\u6362\u3002"),(0,i.kt)("p",null,"There are two limitations to the Favorites class that are worth noting. First, a malicious client could easily corrupt the type safety of a Favorites instance, by using a Class object in its raw form. But the resulting client code would generate an unchecked warning when it was compiled. This is no different from a normal collection implementations such as HashSet and HashMap. You can easily put a String into a ",(0,i.kt)("inlineCode",{parentName:"p"},"HashSet<Integer>")," by using the raw type HashSet (Item 26). That said, you can have runtime type safety if you\u2019re willing to pay for it. The way to ensure that Favorites never violates its type invariant is to have the putFavorite method check that instance is actually an instance of the type represented by type, and we already know how to do this. Just use a dynamic cast:"),(0,i.kt)("p",null,"Favorites \u7c7b\u6709\u4e24\u4e2a",(0,i.kt)("inlineCode",{parentName:"p"},"\u503c"),"\u5f97\u6ce8\u610f\u7684\u9650\u5236\u3002\u9996\u5148\uff0c\u6076\u610f\u5ba2\u6237\u7aef\u5f88\u5bb9\u6613\u901a\u8fc7\u4f7f\u7528\u539f\u59cb\u5f62\u5f0f\u7684\u7c7b\u5bf9\u8c61\u7834\u574f Favorites \u5b9e\u4f8b\u7684\u7c7b\u578b\u5b89\u5168\u3002\u4f46\u662f\u751f\u6210\u7684\u5ba2\u6237\u7aef\u4ee3\u7801\u5728\u7f16\u8bd1\u65f6\u5c06\u751f\u6210\u4e00\u4e2a unchecked \u8b66\u544a\u3002\u8fd9\u4e0e\u666e\u901a\u7684\u96c6\u5408\u5b9e\u73b0\uff08\u5982 HashSet \u548c HashMap\uff09\u6ca1\u6709\u4ec0\u4e48\u4e0d\u540c\u3002\u901a\u8fc7\u4f7f\u7528\u539f\u59cb\u7c7b\u578b HashSet\uff08",(0,i.kt)("a",{parentName:"p",href:"./Chapter-5-Item-26-Do-not-use-raw-types"},"Item-26"),"\uff09\uff0c\u53ef\u4ee5\u8f7b\u677e\u5730\u5c06 String \u7c7b\u578b\u653e\u5165 ",(0,i.kt)("inlineCode",{parentName:"p"},"HashSet<Integer>")," \u4e2d\u3002\u4e5f\u5c31\u662f\u8bf4\uff0c\u5982\u679c\u4f60\u613f\u610f\u4ed8\u51fa\u4ee3\u4ef7\u7684\u8bdd\uff0c\u4f60\u53ef\u4ee5\u62e5\u6709\u8fd0\u884c\u65f6\u7c7b\u578b\u5b89\u5168\u3002\u786e\u4fdd Favorites \u4e0d\u4f1a\u8fdd\u53cd\u5176\u7c7b\u578b\u4e0d\u53d8\u91cf\u7684\u65b9\u6cd5\u662f\u8ba9 putFavorite \u65b9\u6cd5\u68c0\u67e5\u5b9e\u4f8b\u662f\u5426\u662f type \u8868\u793a\u7684\u7c7b\u578b\u7684\u5b9e\u4f8b\uff0c\u6211\u4eec\u5df2\u7ecf\u77e5\u9053\u5982\u4f55\u505a\u5230\u8fd9\u4e00\u70b9\u3002\u53ea\u9700\u4f7f\u7528\u52a8\u6001\u8f6c\u6362\uff1a"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// Achieving runtime type safety with a dynamic cast\npublic <T> void putFavorite(Class<T> type, T instance) {\n    favorites.put(type, type.cast(instance));\n}\n")),(0,i.kt)("p",null,"There are collection wrappers in java.util.Collections that play the same trick. They are called checkedSet, checkedList, checkedMap, and so forth. Their static factories take a Class object (or two) in addition to a collection (or map). The static factories are generic methods, ensuring that the compile-time types of the Class object and the collection match. The wrappers add reification to the collections they wrap. For example, the wrapper throws a ClassCastException at runtime if someone tries to put a Coin into your ",(0,i.kt)("inlineCode",{parentName:"p"},"Collection<Stamp>"),". These wrappers are useful for tracking down client code that adds an incorrectly typed element to a collection, in an application that mixes generic and raw types."),(0,i.kt)("p",null,"java.util.Collections \u4e2d\u7684\u96c6\u5408\u5305\u88c5\u5668\u4e5f\u5177\u6709\u76f8\u540c\u7684\u529f\u80fd\u3002\u5b83\u4eec\u88ab\u79f0\u4e3a checkedSet\u3001checkedList\u3001checkedMap\uff0c\u7b49\u7b49\u3002\u9664\u4e86\u96c6\u5408\uff08\u6216 Map\uff09\u5916\uff0c\u5b83\u4eec\u7684\u9759\u6001\u5de5\u5382\u8fd8\u63a5\u53d7\u4e00\u4e2a\uff08\u6216\u4e24\u4e2a\uff09Class \u5bf9\u8c61\u3002\u9759\u6001\u5de5\u5382\u662f\u901a\u7528\u65b9\u6cd5\uff0c\u786e\u4fdd Class \u5bf9\u8c61\u548c\u96c6\u5408\u7684\u7f16\u8bd1\u65f6\u7c7b\u578b\u5339\u914d\u3002\u5305\u88c5\u5668\u5c06\u5177\u4f53\u5316\u6dfb\u52a0\u5230\u5b83\u4eec\u5305\u88c5\u7684\u96c6\u5408\u4e2d\u3002\u4f8b\u5982\uff0c\u5982\u679c\u6709\u4eba\u8bd5\u56fe\u5c06 Coin \u653e\u5165 ",(0,i.kt)("inlineCode",{parentName:"p"},"Collection<Stamp>")," \u4e2d\uff0c\u5305\u88c5\u5668\u5c06\u5728\u8fd0\u884c\u65f6\u629b\u51fa ClassCastException\u3002\u5728\u6df7\u5408\u4e86\u6cdb\u578b\u7c7b\u578b\u548c\u539f\u59cb\u7c7b\u578b\u7684\u5e94\u7528\u7a0b\u5e8f\u4e2d\uff0c\u8fd9\u4e9b\u5305\u88c5\u5668\u5bf9\u8ddf\u8e2a\u5c06\u7c7b\u578b\u9519\u8bef\u7684\u5143\u7d20\u6dfb\u52a0\u5230\u96c6\u5408\u4e2d\u7684\u5ba2\u6237\u7aef\u4ee3\u7801\u975e\u5e38\u6709\u7528\u3002"),(0,i.kt)("p",null,"The second limitation of the Favorites class is that it cannot be used on a non-reifiable type (Item 28). In other words, you can store your favorite String or String[], but not your favorite ",(0,i.kt)("inlineCode",{parentName:"p"},"List<String>"),". If you try to store your favorite ",(0,i.kt)("inlineCode",{parentName:"p"},"List<String>"),", your program won\u2019t compile. The reason is that you can\u2019t get a Class object for ",(0,i.kt)("inlineCode",{parentName:"p"},"List<String>"),". The class literal ",(0,i.kt)("inlineCode",{parentName:"p"},"List<String>.class")," is a syntax error, and it\u2019s a good thing, too. ",(0,i.kt)("inlineCode",{parentName:"p"},"List<String>")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"List<Integer>")," share a single Class object, which is List.class. It would wreak havoc with the internals of a Favorites object if the \u201ctype literals\u201d ",(0,i.kt)("inlineCode",{parentName:"p"},"List<String>.class")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"List<Integer>.class")," were legal and returned the same object reference. There is no entirely satisfactory workaround for this limitation."),(0,i.kt)("p",null,"Favorites \u7c7b\u7684\u7b2c\u4e8c\u4e2a\u9650\u5236\u662f\u5b83\u4e0d\u80fd\u7528\u4e8e\u4e0d\u53ef\u5177\u4f53\u5316\u7684\u7c7b\u578b\uff08",(0,i.kt)("a",{parentName:"p",href:"./Chapter-5-Item-28-Prefer-lists-to-arrays"},"Item-28"),"\uff09\u3002\u6362\u53e5\u8bdd\u8bf4\uff0c\u4f60\u53ef\u4ee5\u5b58\u50a8\u7684 Favorites \u5b9e\u4f8b\u7c7b\u578b\u4e3a String \u7c7b\u578b\u6216 String[]\uff0c\u4f46\u4e0d\u80fd\u5b58\u50a8 ",(0,i.kt)("inlineCode",{parentName:"p"},"List<String>"),"\u3002\u539f\u56e0\u662f\u4f60\u4e0d\u80fd\u4e3a ",(0,i.kt)("inlineCode",{parentName:"p"},"List<String>")," \u83b7\u53d6 Class \u5bf9\u8c61\uff0c",(0,i.kt)("inlineCode",{parentName:"p"},"List<String>.class")," \u662f\u4e00\u4e2a\u8bed\u6cd5\u9519\u8bef\uff0c\u8fd9\u4e5f\u662f\u4e00\u4ef6\u597d\u4e8b\u3002",(0,i.kt)("inlineCode",{parentName:"p"},"List<String>")," \u548c ",(0,i.kt)("inlineCode",{parentName:"p"},"List<Integer>")," \u5171\u4eab\u4e00\u4e2a Class \u5bf9\u8c61\uff0c\u5373 List.class\u3002\u5982\u679c\u300c\u5b57\u9762\u7c7b\u578b\u300d",(0,i.kt)("inlineCode",{parentName:"p"},"List<String>.class")," \u548c ",(0,i.kt)("inlineCode",{parentName:"p"},"List<Integer>.class")," \u662f\u5408\u6cd5\u7684\uff0c\u5e76\u4e14\u8fd4\u56de\u76f8\u540c\u7684\u5bf9\u8c61\u5f15\u7528\uff0c\u90a3\u4e48\u5b83\u5c06\u4e25\u91cd\u7834\u574f Favorites \u5bf9\u8c61\u7684\u5185\u90e8\u7ed3\u6784\u3002\u5bf9\u4e8e\u8fd9\u4e2a\u9650\u5236\uff0c\u6ca1\u6709\u5b8c\u5168\u4ee4\u4eba\u6ee1\u610f\u7684\u89e3\u51b3\u65b9\u6848\u3002"),(0,i.kt)("p",null,"The type tokens used by Favorites are unbounded: getFavorite and put-Favorite accept any Class object. Sometimes you may need to limit the types that can be passed to a method. This can be achieved with a bounded type token, which is simply a type token that places a bound on what type can be represented, using a bounded type parameter (Item 30) or a bounded wildcard (Item 31)."),(0,i.kt)("p",null,"Favorites \u4f7f\u7528\u7684\u7c7b\u578b\u6807\u8bb0\u662f\u65e0\u754c\u7684\uff1agetFavorite \u548c put-Favorite \u63a5\u53d7\u4efb\u4f55 Class \u5bf9\u8c61\u3002\u6709\u65f6\u4f60\u53ef\u80fd\u9700\u8981\u9650\u5236\u53ef\u4ee5\u4f20\u9012\u7ed9\u65b9\u6cd5\u7684\u7c7b\u578b\u3002\u8fd9\u53ef\u4ee5\u901a\u8fc7\u6709\u754c\u7c7b\u578b\u6807\u8bb0\u6765\u5b9e\u73b0\uff0c\u5b83\u53ea\u662f\u4e00\u4e2a\u7c7b\u578b\u6807\u8bb0\uff0c\u4f7f\u7528\u6709\u754c\u7c7b\u578b\u53c2\u6570\uff08",(0,i.kt)("a",{parentName:"p",href:"./Chapter-5-Item-30-Favor-generic-methods"},"Item-30"),"\uff09\u6216\u6709\u754c\u901a\u914d\u7b26\uff08",(0,i.kt)("a",{parentName:"p",href:"./Chapter-5-Item-31-Use-bounded-wildcards-to-increase-API-flexibility"},"Item-31"),"\uff09\u5bf9\u53ef\u4ee5\u8868\u793a\u7684\u7c7b\u578b\u8fdb\u884c\u7ed1\u5b9a\u3002"),(0,i.kt)("p",null,"The annotations API (Item 39) makes extensive use of bounded type tokens. For example, here is the method to read an annotation at runtime. This method comes from the AnnotatedElement interface, which is implemented by the reflective types that represent classes, methods, fields, and other program elements:"),(0,i.kt)("p",null,"annotation API\uff08",(0,i.kt)("a",{parentName:"p",href:"./Chapter-6-Item-39-Prefer-annotations-to-naming-patterns"},"Item-39"),"\uff09\u5e7f\u6cdb\u4f7f\u7528\u4e86\u6709\u754c\u7c7b\u578b\u6807\u8bb0\u3002\u4f8b\u5982\uff0c\u4e0b\u9762\u662f\u5728\u8fd0\u884c\u65f6\u8bfb\u53d6\u6ce8\u91ca\u7684\u65b9\u6cd5\u3002\u8fd9\u4e2a\u65b9\u6cd5\u6765\u81ea AnnotatedElement \u63a5\u53e3\uff0c\u5b83\u662f\u7531\u8868\u793a\u7c7b\u3001\u65b9\u6cd5\u3001\u5b57\u6bb5\u548c\u5176\u4ed6\u7a0b\u5e8f\u5143\u7d20\u7684\u53cd\u5c04\u7c7b\u578b\u5b9e\u73b0\u7684\uff1a"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"public <T extends Annotation>\n    T getAnnotation(Class<T> annotationType);\n")),(0,i.kt)("p",null,"The argument, annotationType, is a bounded type token representing an annotation type. The method returns the element\u2019s annotation of that type, if it has one, or null, if it doesn\u2019t. In essence, an annotated element is a typesafe heterogeneous container whose keys are annotation types."),(0,i.kt)("p",null,"\u53c2\u6570 annotationType \u662f\u8868\u793a\u6ce8\u91ca\u7c7b\u578b\u7684\u6709\u754c\u7c7b\u578b\u6807\u8bb0\u3002\u8be5\u65b9\u6cd5\u8fd4\u56de\u8be5\u7c7b\u578b\u7684\u5143\u7d20\u6ce8\u91ca\uff08\u5982\u679c\u6709\u7684\u8bdd\uff09\uff0c\u6216\u8005\u8fd4\u56de null\uff08\u5982\u679c\u6ca1\u6709\u7684\u8bdd\uff09\u3002\u672c\u8d28\u4e0a\uff0c\u5e26\u6ce8\u91ca\u7684\u5143\u7d20\u662f\u4e00\u4e2a\u7c7b\u578b\u5b89\u5168\u7684\u5f02\u6784\u5bb9\u5668\uff0c\u5176",(0,i.kt)("inlineCode",{parentName:"p"},"\u952e"),"\u662f\u6ce8\u91ca\u7c7b\u578b\u3002"),(0,i.kt)("p",null,"Suppose you have an object of type ",(0,i.kt)("inlineCode",{parentName:"p"},"Class<?>")," and you want to pass it to a method that requires a bounded type token, such as getAnnotation. You could cast the object to ",(0,i.kt)("inlineCode",{parentName:"p"},"Class<? extends Annotation>"),", but this cast is unchecked, so it would generate a compile-time warning (Item 27). Luckily, class Class provides an instance method that performs this sort of cast safely (and dynamically). The method is called asSubclass, and it casts the Class object on which it is called to represent a subclass of the class represented by its argument. If the cast succeeds, the method returns its argument; if it fails, it throws a ClassCastException."),(0,i.kt)("p",null,"\u5047\u8bbe\u4f60\u6709\u4e00\u4e2a ",(0,i.kt)("inlineCode",{parentName:"p"},"Class<?>")," \u7c7b\u578b\u7684\u5bf9\u8c61\uff0c\u5e76\u4e14\u5e0c\u671b\u5c06\u5176\u4f20\u9012\u7ed9\u4e00\u4e2a\u9700\u8981\u6709\u754c\u7c7b\u578b\u4ee4\u724c\uff08\u4f8b\u5982 getAnnotation\uff09\u7684\u65b9\u6cd5\u3002\u4f60\u53ef\u4ee5\u5c06\u5bf9\u8c61\u5f3a\u5236\u8f6c\u6362\u4e3a ",(0,i.kt)("inlineCode",{parentName:"p"},"Class<? extends Annotation>"),"\uff0c\u4f46\u662f\u8fd9\u4e2a\u5f3a\u5236\u8f6c\u6362\u662f\u672a\u9009\u4e2d\u7684\uff0c\u56e0\u6b64\u5b83\u5c06\u751f\u6210\u4e00\u4e2a\u7f16\u8bd1\u65f6\u8b66\u544a\uff08",(0,i.kt)("a",{parentName:"p",href:"./Chapter-5-Item-27-Eliminate-unchecked-warnings"},"Item-27"),"\uff09\u3002\u5e78\u8fd0\u7684\u662f\uff0cclass \u7c7b\u63d0\u4f9b\u4e86\u4e00\u4e2a\u5b9e\u4f8b\u65b9\u6cd5\uff0c\u53ef\u4ee5\u5b89\u5168\u5730\uff08\u52a8\u6001\u5730\uff09\u6267\u884c\u8fd9\u79cd\u7c7b\u578b\u7684\u5f3a\u5236\u8f6c\u6362\u3002\u8be5\u65b9\u6cd5\u79f0\u4e3a asSubclass\uff0c\u5b83\u5c06\u7c7b\u5bf9\u8c61\u5f3a\u5236\u8f6c\u6362\u4e3a\u5b83\u6240\u8c03\u7528\u7684\u7c7b\u5bf9\u8c61\uff0c\u4ee5\u8868\u793a\u7531\u5176\u53c2\u6570\u8868\u793a\u7684\u7c7b\u7684\u5b50\u7c7b\u3002\u5982\u679c\u8f6c\u6362\u6210\u529f\uff0c\u5219\u8be5\u65b9\u6cd5\u8fd4\u56de\u5176\u53c2\u6570\uff1b\u5982\u679c\u5931\u8d25\uff0c\u5219\u629b\u51fa ClassCastException\u3002"),(0,i.kt)("p",null,"Here\u2019s how you use the asSubclass method to read an annotation whose type is unknown at compile time. This method compiles without error or warning:"),(0,i.kt)("p",null,"\u4e0b\u9762\u662f\u5982\u4f55\u4f7f\u7528 asSubclass \u65b9\u6cd5\u8bfb\u53d6\u5728\u7f16\u8bd1\u65f6\u7c7b\u578b\u672a\u77e5\u7684\u6ce8\u91ca\u3002\u8fd9\u4e2a\u65b9\u6cd5\u7f16\u8bd1\u6ca1\u6709\u9519\u8bef\u6216\u8b66\u544a\uff1a"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// Use of asSubclass to safely cast to a bounded type token\nstatic Annotation getAnnotation(AnnotatedElement element,String annotationTypeName) {\n    Class<?> annotationType = null; // Unbounded type token\n    try {\n        annotationType = Class.forName(annotationTypeName);\n    } catch (Exception ex) {\n        throw new IllegalArgumentException(ex);\n    }\n    return element.getAnnotation(annotationType.asSubclass(Annotation.class));\n}\n")),(0,i.kt)("p",null,"In summary, the normal use of generics, exemplified by the collections APIs, restricts you to a fixed number of type parameters per container. You can get around this restriction by placing the type parameter on the key rather than the container. You can use Class objects as keys for such typesafe heterogeneous containers. A Class object used in this fashion is called a type token. You can also use a custom key type. For example, you could have a DatabaseRow type representing a database row (the container), and a generic type ",(0,i.kt)("inlineCode",{parentName:"p"},"Column<T>")," as its key."),(0,i.kt)("p",null,"\u603b\u4e4b\uff0c\u4ee5\u96c6\u5408\u7684 API \u4e3a\u4f8b\u7684\u6cdb\u578b\u5728\u6b63\u5e38\u4f7f\u7528\u65f6\u5c06\u6bcf\u4e2a\u5bb9\u5668\u7684\u7c7b\u578b\u53c2\u6570\u9650\u5236\u4e3a\u56fa\u5b9a\u6570\u91cf\u3002\u4f60\u53ef\u4ee5\u901a\u8fc7\u5c06\u7c7b\u578b\u53c2\u6570\u653e\u7f6e\u5728",(0,i.kt)("inlineCode",{parentName:"p"},"\u952e"),"\u4e0a\u800c\u4e0d\u662f\u5bb9\u5668\u4e0a\u6765\u7ed5\u8fc7\u8fd9\u4e2a\u9650\u5236\u3002\u4f60\u53ef\u4ee5\u4f7f\u7528 Class \u5bf9\u8c61\u4f5c\u4e3a\u6b64\u7c7b\u7c7b\u578b\u5b89\u5168\u5f02\u6784\u5bb9\u5668\u7684",(0,i.kt)("inlineCode",{parentName:"p"},"\u952e"),"\u3002\u4ee5\u8fd9\u79cd\u65b9\u5f0f\u4f7f\u7528\u7684 Class \u5bf9\u8c61\u79f0\u4e3a\u7c7b\u578b\u6807\u8bb0\u3002\u8fd8\u53ef\u4ee5\u4f7f\u7528\u81ea\u5b9a\u4e49",(0,i.kt)("inlineCode",{parentName:"p"},"\u952e"),"\u7c7b\u578b\u3002\u4f8b\u5982\uff0c\u53ef\u4ee5\u4f7f\u7528 DatabaseRow \u7c7b\u578b\u8868\u793a\u6570\u636e\u5e93\u884c\uff08\u5bb9\u5668\uff09\uff0c\u5e76\u4f7f\u7528\u6cdb\u578b\u7c7b\u578b ",(0,i.kt)("inlineCode",{parentName:"p"},"Column<T>")," \u4f5c\u4e3a\u5b83\u7684",(0,i.kt)("inlineCode",{parentName:"p"},"\u952e"),"\u3002"),(0,i.kt)("hr",null),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("a",{parentName:"strong",href:"./Chapter-5-Introduction"},"Back to contents of the chapter\uff08\u8fd4\u56de\u7ae0\u8282\u76ee\u5f55\uff09"))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Previous Item\uff08\u4e0a\u4e00\u6761\u76ee\uff09\uff1a",(0,i.kt)("a",{parentName:"strong",href:"./Chapter-5-Item-32-Combine-generics-and-varargs-judiciously"},"Item 32: Combine generics and varargs judiciously\uff08\u660e\u667a\u5730\u5408\u7528\u6cdb\u578b\u548c\u53ef\u53d8\u53c2\u6570\uff09"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Next Item\uff08\u4e0b\u4e00\u6761\u76ee\uff09\uff1a",(0,i.kt)("a",{parentName:"strong",href:"./Chapter-6-Introduction"},"Chapter 6 Introduction\uff08\u7ae0\u8282\u4ecb\u7ecd\uff09")))))}h.isMDXComponent=!0}}]);