"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[6059],{3905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>p});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},u=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),m=c(a),p=r,d=m["".concat(l,".").concat(p)]||m[p]||h[p]||i;return a?n.createElement(d,o(o({ref:t},u),{},{components:a})):n.createElement(d,o({ref:t},u))}));function p(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var c=2;c<i;c++)o[c]=a[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},1492:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var n=a(7462),r=(a(7294),a(3905));const i={},o=void 0,s={unversionedId:"Books/EffectiveJava3/Chapter-2/Chapter-2-Item-8-Avoid-finalizers-and-cleaners",id:"Books/EffectiveJava3/Chapter-2/Chapter-2-Item-8-Avoid-finalizers-and-cleaners",title:"Chapter-2-Item-8-Avoid-finalizers-and-cleaners",description:"Chapter 2. Creating and Destroying Objects\uff08\u521b\u5efa\u548c\u9500\u6bc1\u5bf9\u8c61\uff09",source:"@site/docs/Books/EffectiveJava3/Chapter-2/Chapter-2-Item-8-Avoid-finalizers-and-cleaners.md",sourceDirName:"Books/EffectiveJava3/Chapter-2",slug:"/Books/EffectiveJava3/Chapter-2/Chapter-2-Item-8-Avoid-finalizers-and-cleaners",permalink:"/docs/Books/EffectiveJava3/Chapter-2/Chapter-2-Item-8-Avoid-finalizers-and-cleaners",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Books/EffectiveJava3/Chapter-2/Chapter-2-Item-8-Avoid-finalizers-and-cleaners.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Chapter-2-Item-7-Eliminate-obsolete-object-references",permalink:"/docs/Books/EffectiveJava3/Chapter-2/Chapter-2-Item-7-Eliminate-obsolete-object-references"},next:{title:"Chapter-2-Item-9-Prefer-try-with-resources-to-try-finally",permalink:"/docs/Books/EffectiveJava3/Chapter-2/Chapter-2-Item-9-Prefer-try-with-resources-to-try-finally"}},l={},c=[{value:"Chapter 2. Creating and Destroying Objects\uff08\u521b\u5efa\u548c\u9500\u6bc1\u5bf9\u8c61\uff09",id:"chapter-2-creating-and-destroying-objects\u521b\u5efa\u548c\u9500\u6bc1\u5bf9\u8c61",level:2},{value:"Item 8: Avoid finalizers and cleaners\uff08\u907f\u514d\u4f7f\u7528\u7ec8\u7ed3\u5668\u548c\u6e05\u9664\u5668\uff09",id:"item-8-avoid-finalizers-and-cleaners\u907f\u514d\u4f7f\u7528\u7ec8\u7ed3\u5668\u548c\u6e05\u9664\u5668",level:3}],u={toc:c};function h(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"chapter-2-creating-and-destroying-objects\u521b\u5efa\u548c\u9500\u6bc1\u5bf9\u8c61"},"Chapter 2. Creating and Destroying Objects\uff08\u521b\u5efa\u548c\u9500\u6bc1\u5bf9\u8c61\uff09"),(0,r.kt)("h3",{id:"item-8-avoid-finalizers-and-cleaners\u907f\u514d\u4f7f\u7528\u7ec8\u7ed3\u5668\u548c\u6e05\u9664\u5668"},"Item 8: Avoid finalizers and cleaners\uff08\u907f\u514d\u4f7f\u7528\u7ec8\u7ed3\u5668\u548c\u6e05\u9664\u5668\uff09"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Finalizers are unpredictable, often dangerous, and generally unnecessary.")," Their use can cause erratic behavior, poor performance, and portability problems. Finalizers have a few valid uses, which we\u2019ll cover later in this item, but as a rule, you should avoid them. As of Java 9, finalizers have been deprecated, but they are still being used by the Java libraries. The Java 9 replacement for finalizers is cleaners. ",(0,r.kt)("strong",{parentName:"p"},"Cleaners are less dangerous than finalizers, but still unpredictable, slow, and generally unnecessary.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u7ec8\u7ed3\u5668\u662f\u4e0d\u53ef\u9884\u6d4b\u7684\uff0c\u901a\u5e38\u662f\u5371\u9669\u7684\uff0c\u4e5f\u662f\u4e0d\u5fc5\u8981\u7684\u3002")," \u5b83\u4eec\u7684\u4f7f\u7528\u53ef\u80fd\u5bfc\u81f4\u4e0d\u7a33\u5b9a\u7684\u884c\u4e3a\u3001\u7cdf\u7cd5\u7684\u6027\u80fd\u548c\u53ef\u79fb\u690d\u6027\u95ee\u9898\u3002\u7ec8\u7ed3\u5668\u6709\u4e00\u4e9b\u6709\u6548\u7684\u7528\u9014\uff0c\u6211\u4eec\u5c06\u5728\u540e\u9762\u7684\u6587\u7ae0\u4e2d\u4ecb\u7ecd\uff0c\u4f46\u662f\u4f5c\u4e3a\u89c4\u5219\uff0c\u4f60\u5e94\u8be5\u907f\u514d\u4f7f\u7528\u5b83\u4eec\u3002\u5728 Java 9 \u4e2d\uff0c\u7ec8\u7ed3\u5668\u5df2\u7ecf\u88ab\u5f03\u7528\uff0c\u4f46\u662f Java \u5e93\u4ecd\u7136\u5728\u4f7f\u7528\u5b83\u4eec\u3002Java 9 \u66ff\u4ee3\u7ec8\u7ed3\u5668\u7684\u662f\u6e05\u9664\u5668\u3002",(0,r.kt)("strong",{parentName:"p"},"\u6e05\u9664\u5668\u7684\u5371\u9669\u6bd4\u7ec8\u7ed3\u5668\u5c0f\uff0c\u4f46\u4ecd\u7136\u4e0d\u53ef\u9884\u6d4b\u3001\u7f13\u6162\uff0c\u800c\u4e14\u901a\u5e38\u662f\u4e0d\u5fc5\u8981\u7684\u3002")),(0,r.kt)("p",null,"C++ programmers are cautioned not to think of finalizers or cleaners as Java\u2019s analogue of C++ destructors. In C++, destructors are the normal way to reclaim the resources associated with an object, a necessary counterpart to constructors.In Java, the garbage collector reclaims the storage associated with an object when it becomes unreachable, requiring no special effort on the part of the programmer. C++ destructors are also used to reclaim other nonmemory resources. In Java, a try-with-resources or try-finally block is used for this purpose (Item 9)."),(0,r.kt)("p",null,"c++ \u7a0b\u5e8f\u5458\u88ab\u544a\u8beb\u4e0d\u8981\u628a\u7ec8\u7ed3\u5668\u6216\u6e05\u9664\u5668\u5f53\u6210 Java \u7684 c++ \u6790\u6784\u51fd\u6570\u3002\u5728 c++ \u4e2d\uff0c\u6790\u6784\u51fd\u6570\u662f\u56de\u6536\u4e0e\u5bf9\u8c61\u76f8\u5173\u8054\u7684\u8d44\u6e90\u7684\u5e38\u7528\u65b9\u6cd5\uff0c\u5bf9\u8c61\u662f\u6784\u9020\u51fd\u6570\u7684\u5fc5\u8981\u5bf9\u7b49\u7269\u3002\u5728 Java \u4e2d\uff0c\u5f53\u5bf9\u8c61\u53d8\u5f97\u4e0d\u53ef\u8bbf\u95ee\u65f6\uff0c\u5783\u573e\u6536\u96c6\u5668\u5c06\u56de\u6536\u4e0e\u4e4b\u5173\u8054\u7684\u5b58\u50a8\uff0c\u65e0\u9700\u7a0b\u5e8f\u5458\u8fdb\u884c\u4efb\u4f55\u7279\u6b8a\u5de5\u4f5c\u3002c++ \u6790\u6784\u51fd\u6570\u8fd8\u7528\u4e8e\u56de\u6536\u5176\u4ed6\u975e\u5185\u5b58\u8d44\u6e90\u3002\u5728 Java \u4e2d\uff0c\u4f7f\u7528\u5e26\u6709\u8d44\u6e90\u7684 try-with-resources \u6216 try-finally \u5757\u7528\u4e8e\u6b64\u76ee\u7684\uff08",(0,r.kt)("a",{parentName:"p",href:"./Chapter-2-Item-9-Prefer-try-with-resources-to-try-finally"},"Item-9"),"\uff09\u3002"),(0,r.kt)("p",null,"One shortcoming of finalizers and cleaners is that there is no guarantee they\u2019ll be executed promptly ","[JLS, 12.6]",". It can take arbitrarily long between the time that an object becomes unreachable and the time its finalizer or cleaner runs.This means that you should never do anything time-critical in a finalizer or cleaner. For example, it is a grave error to depend on a finalizer or cleaner to close files because open file descriptors are a limited resource. If many files are left open as a result of the system\u2019s tardiness in running finalizers or cleaners, a program may fail because it can no longer open files."),(0,r.kt)("p",null,"\u7ec8\u7ed3\u5668\u548c\u6e05\u9664\u5668\u7684\u4e00\u4e2a\u7f3a\u70b9\u662f\u4e0d\u80fd\u4fdd\u8bc1\u5b83\u4eec\u4f1a\u88ab\u7acb\u5373\u6267\u884c ","[JLS, 12.6]","\u3002\u5f53\u5bf9\u8c61\u53d8\u5f97\u4e0d\u53ef\u8bbf\u95ee\uff0c\u7ec8\u7ed3\u5668\u6216\u6e05\u9664\u5668\u5bf9\u5b83\u8fdb\u884c\u64cd\u4f5c\u7684\u65f6\u95f4\u662f\u4e0d\u786e\u5b9a\u7684\u3002\u8fd9\u610f\u5473\u7740\u6c38\u8fdc\u4e0d\u5e94\u8be5\u5728\u7ec8\u7ed3\u5668\u6216\u6e05\u9664\u5668\u4e2d\u6267\u884c\u4efb\u4f55\u5bf9\u65f6\u95f4\u8981\u6c42\u5f88\u4e25\u683c\u7684\u64cd\u4f5c\u3002\u4f8b\u5982\uff0c\u4f9d\u8d56\u7ec8\u7ed3\u5668\u6216\u6e05\u9664\u5668\u5173\u95ed\u6587\u4ef6\u5c31\u662f\u4e00\u4e2a\u4e25\u91cd\u9519\u8bef\uff0c\u56e0\u4e3a\u6253\u5f00\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u662f\u6709\u9650\u7684\u8d44\u6e90\u3002\u5982\u679c\u7531\u4e8e\u7cfb\u7edf\u5728\u8fd0\u884c\u7ec8\u7ed3\u5668\u6216\u6e05\u9664\u5668\u7684\u5ef6\u8fdf\u5bfc\u81f4\u8bb8\u591a\u6587\u4ef6\u5904\u4e8e\u6253\u5f00\u72b6\u6001\uff0c\u7a0b\u5e8f\u53ef\u80fd\u4f1a\u8fd0\u884c\u5931\u8d25\uff0c\u56e0\u4e3a\u5b83\u4e0d\u80fd\u518d\u6253\u5f00\u5176\u4ed6\u6587\u4ef6\u3002"),(0,r.kt)("p",null,"The promptness with which finalizers and cleaners are executed is primarily a function of the garbage collection algorithm, which varies widely across implementations. The behavior of a program that depends on the promptness of finalizer or cleaner execution may likewise vary. It is entirely possible that such a program will run perfectly on the JVM on which you test it and then fail miserably on the one favored by your most important customer."),(0,r.kt)("p",null,"\u7ec8\u7ed3\u5668\u548c\u6e05\u9664\u5668\u6267\u884c\u7684\u5feb\u901f\u6027\u4e3b\u8981\u662f\u5783\u573e\u6536\u96c6\u7b97\u6cd5\u7684\u529f\u80fd\uff0c\u5728\u4e0d\u540c\u7684\u5b9e\u73b0\u4e2d\u5b58\u5728\u5f88\u5927\u5dee\u5f02\u3002\u4f9d\u8d56\u4e8e\u7ec8\u7ed3\u5668\u7684\u53ca\u65f6\u6027\u6216\u66f4\u6e05\u6670\u7684\u6267\u884c\u7684\u7a0b\u5e8f\u7684\u884c\u4e3a\u53ef\u80fd\u4e5f\u4f1a\u53d1\u751f\u53d8\u5316\u3002\u8fd9\u6837\u7684\u7a0b\u5e8f\u5b8c\u5168\u6709\u53ef\u80fd\u5728\u6d4b\u8bd5\u5b83\u7684 JVM \u4e0a\u5b8c\u7f8e\u5730\u8fd0\u884c\uff0c\u7136\u540e\u5728\u6700\u91cd\u8981\u7684\u5ba2\u6237\u559c\u6b22\u7684 JVM \u4e0a\u60b2\u60e8\u5730\u5931\u8d25\u3002"),(0,r.kt)("p",null,"Tardy finalization is not just a theoretical problem. Providing a finalizer for a class can arbitrarily delay reclamation of its instances. A colleague debugged a long-running GUI application that was mysteriously dying with an OutOfMemoryError. Analysis revealed that at the time of its death, the application had thousands of graphics objects on its finalizer queue just waiting to be finalized and reclaimed. Unfortunately, the finalizer thread was running at a lower priority than another application thread, so objects weren\u2019t getting finalized at the rate they became eligible for finalization. The language specification makes no guarantees as to which thread will execute finalizers, so there is no portable way to prevent this sort of problem other than to refrain from using finalizers. Cleaners are a bit better than finalizers in this regard because class authors have control over their own cleaner threads, but cleaners still run in the background, under the control of the garbage collector, so there can be no guarantee of prompt cleaning."),(0,r.kt)("p",null,"\u59d7\u59d7\u6765\u8fdf\u7684\u5b9a\u7a3f\u4e0d\u4ec5\u4ec5\u662f\u4e00\u4e2a\u7406\u8bba\u4e0a\u7684\u95ee\u9898\u3002\u4e3a\u7c7b\u63d0\u4f9b\u7ec8\u7ed3\u5668\u53ef\u4ee5\u4efb\u610f\u5ef6\u8fdf\u5176\u5b9e\u4f8b\u7684\u56de\u6536\u3002\u4e00\u4f4d\u540c\u4e8b\u8c03\u8bd5\u4e86\u4e00\u4e2a\u957f\u671f\u8fd0\u884c\u7684 GUI \u5e94\u7528\u7a0b\u5e8f\uff0c\u8be5\u5e94\u7528\u7a0b\u5e8f\u795e\u79d8\u5730\u7ec8\u7ed3\u4e8e OutOfMemoryError \u9519\u8bef\u3002\u5206\u6790\u663e\u793a\uff0c\u5728\u5e94\u7528\u7a0b\u5e8f\u7ec8\u7ed3\u7684\u65f6\u5019\uff0c\u7ec8\u7ed3\u5668\u961f\u5217\u4e0a\u6709\u6570\u5343\u4e2a\u56fe\u5f62\u5bf9\u8c61\u7b49\u5f85\u6700\u7ec8\u5b8c\u6210\u548c\u56de\u6536\u3002\u4e0d\u5e78\u7684\u662f\uff0c\u7ec8\u7ed3\u5668\u7ebf\u7a0b\u8fd0\u884c\u7684\u4f18\u5148\u7ea7\u4f4e\u4e8e\u53e6\u4e00\u4e2a\u5e94\u7528\u7a0b\u5e8f\u7ebf\u7a0b\uff0c\u56e0\u6b64\u5bf9\u8c61\u4e0d\u80fd\u4ee5\u9002\u5408\u7ec8\u7ed3\u5668\u7684\u901f\u5ea6\u5b8c\u6210\u3002\u8bed\u8a00\u89c4\u8303\u6ca1\u6709\u4fdd\u8bc1\u54ea\u4e2a\u7ebf\u7a0b\u5c06\u6267\u884c\u7ec8\u7ed3\u5668\uff0c\u56e0\u6b64\u9664\u4e86\u907f\u514d\u4f7f\u7528\u7ec8\u7ed3\u5668\u4e4b\u5916\uff0c\u6ca1\u6709\u5176\u4ed6\u53ef\u79fb\u690d\u7684\u65b9\u6cd5\u6765\u9632\u6b62\u8fd9\u7c7b\u95ee\u9898\u3002\u5728\u8fd9\u65b9\u9762\uff0c\u6e05\u6d01\u5668\u6bd4\u7ec8\u7ed3\u5668\u8981\u597d\u4e00\u4e9b\uff0c\u56e0\u4e3a\u7c7b\u4f5c\u8005\u53ef\u4ee5\u81ea\u5df1\u63a7\u5236\u662f\u5426\u6e05\u7406\u7ebf\u7a0b\uff0c\u4f46\u662f\u6e05\u6d01\u5668\u4ecd\u7136\u5728\u540e\u53f0\u8fd0\u884c\uff0c\u5728\u5783\u573e\u6536\u96c6\u5668\u7684\u63a7\u5236\u4e0b\u8fd0\u884c\uff0c\u6240\u4ee5\u4e0d\u80fd\u4fdd\u8bc1\u53ca\u65f6\u6e05\u7406\u3002"),(0,r.kt)("p",null,"Not only does the specification provide no guarantee that finalizers or cleaners will run promptly; it provides no guarantee that they\u2019ll run at all. It is entirely possible, even likely, that a program terminates without running them on some objects that are no longer reachable. As a consequence, you should never depend on a finalizer or cleaner to update persistent state. For example,depending on a finalizer or cleaner to release a persistent lock on a shared resource such as a database is a good way to bring your entire distributed system to a grinding halt."),(0,r.kt)("p",null,"\u8be5\u89c4\u8303\u4e0d\u4ec5\u4e0d\u80fd\u4fdd\u8bc1\u7ec8\u7ed3\u5668\u6216\u6e05\u6d01\u5242\u80fd\u53ca\u65f6\u8fd0\u884c\uff1b\u5b83\u5e76\u4e0d\u80fd\u4fdd\u8bc1\u5b83\u4eec\u80fd\u8fd0\u884c\u3002\u5b8c\u5168\u6709\u53ef\u80fd\uff0c\u751a\u81f3\u5f88\u6709\u53ef\u80fd\uff0c\u7a0b\u5e8f\u5728\u67d0\u4e9b\u4e0d\u518d\u53ef\u8bbf\u95ee\u7684\u5bf9\u8c61\u4e0a\u8fd0\u884c\u800c\u7ec8\u6b62\u3002\u56e0\u6b64\uff0c\u6c38\u8fdc\u4e0d\u5e94\u8be5\u4f9d\u8d56\u7ec8\u7ed3\u5668\u6216\u6e05\u9664\u5668\u6765\u66f4\u65b0\u6301\u4e45\u72b6\u6001\u3002\u4f8b\u5982\uff0c\u4f9d\u8d56\u7ec8\u7ed3\u5668\u6216\u6e05\u9664\u5668\u6765\u91ca\u653e\u5171\u4eab\u8d44\u6e90\uff08\u5982\u6570\u636e\u5e93\uff09\u4e0a\u7684\u6301\u4e45\u9501\uff0c\u662f\u8ba9\u6574\u4e2a\u5206\u5e03\u5f0f\u7cfb\u7edf\u505c\u6b62\u5de5\u4f5c\u7684\u597d\u65b9\u6cd5\u3002"),(0,r.kt)("p",null,"Don\u2019t be seduced by the methods System.gc and System.runFinalization. They may increase the odds of finalizers or cleaners getting executed, but they don\u2019t guarantee it. Two methods once claimed to make this guarantee: System.runFinalizersOnExit and its evil twin, Runtime.runFinalizersOnExit. These methods are fatally flawed and have been deprecated for decades ","[ThreadStop]","."),(0,r.kt)("p",null,"\u4e0d\u8981\u88ab System.gc \u548c System.runFinalization \u7684\u65b9\u6cd5\u6240\u8bf1\u60d1\u3002\u5b83\u4eec\u53ef\u80fd\u4f1a\u589e\u52a0\u7ec8\u7ed3\u5668\u6216\u6e05\u9664\u5668\u88ab\u8fd0\u884c\u7684\u51e0\u7387\uff0c\u4f46\u5b83\u4eec\u4e0d\u80fd\u4fdd\u8bc1\u4e00\u5b9a\u8fd0\u884c\u3002\u66fe\u7ecf\u6709\u4e24\u79cd\u65b9\u6cd5\u58f0\u79f0\u53ef\u4ee5\u4fdd\u8bc1\u8fd9\u4e00\u70b9\uff1aSystem.runFinalizersOnExit \u548c\u5b83\u7684\u5b6a\u751f\u5144\u5f1f Runtime.runFinalizersOnExit\u3002\u8fd9\u4e9b\u65b9\u6cd5\u5b58\u5728\u81f4\u547d\u7684\u7f3a\u9677\uff0c\u5e76\u4e14\u5df2\u7ecf\u88ab\u5e9f\u5f03\u4e86\u51e0\u5341\u5e74","[ThreadStop]","\u3002"),(0,r.kt)("p",null,"Another problem with finalizers is that an uncaught exception thrown during finalization is ignored, and finalization of that object terminates ","[JLS, 12.6]",".Uncaught exceptions can leave other objects in a corrupt state. If another thread attempts to use such a corrupted object, arbitrary nondeterministic behavior may result. Normally, an uncaught exception will terminate the thread and print a stack trace, but not if it occurs in a finalizer\u2014it won\u2019t even print a warning.Cleaners do not have this problem because a library using a cleaner has control over its thread."),(0,r.kt)("p",null,"\u7ec8\u7ed3\u5668\u7684\u53e6\u4e00\u4e2a\u95ee\u9898\u662f\uff0c\u5728\u7ec8\u7ed3\u671f\u95f4\u629b\u51fa\u7684\u672a\u6355\u83b7\u5f02\u5e38\u88ab\u5ffd\u7565\uff0c\u8be5\u5bf9\u8c61\u7684\u7ec8\u7ed3\u7ec8\u6b62 ","[JLS, 12.6]","\u3002\u672a\u6355\u83b7\u7684\u5f02\u5e38\u53ef\u80fd\u4f1a\u4f7f\u5176\u4ed6\u5bf9\u8c61\u5904\u4e8e\u635f\u574f\u72b6\u6001\u3002\u5982\u679c\u53e6\u4e00\u4e2a\u7ebf\u7a0b\u8bd5\u56fe\u4f7f\u7528\u8fd9\u6837\u4e00\u4e2a\u635f\u574f\u7684\u5bf9\u8c61\uff0c\u53ef\u80fd\u4f1a\u5bfc\u81f4\u4efb\u610f\u7684\u4e0d\u786e\u5b9a\u6027\u884c\u4e3a\u3002\u6b63\u5e38\u60c5\u51b5\u4e0b\uff0c\u672a\u6355\u83b7\u7684\u5f02\u5e38\u5c06\u7ec8\u6b62\u7ebf\u7a0b\u5e76\u6253\u5370\u5806\u6808\u8ddf\u8e2a\uff0c\u4f46\u5982\u679c\u5728\u7ec8\u7ed3\u5668\u4e2d\u51fa\u73b0\uff0c\u5219\u4e0d\u4f1a\u6253\u5370\u8b66\u544a\u3002\u6e05\u9664\u5668\u6ca1\u6709\u8fd9\u4e2a\u95ee\u9898\uff0c\u56e0\u4e3a\u4f7f\u7528\u6e05\u9664\u5668\u7684\u5e93\u53ef\u4ee5\u63a7\u5236\u5b83\u7684\u7ebf\u7a0b\u3002"),(0,r.kt)("p",null,"There is a severe performance penalty for using finalizers and cleaners.On my machine, the time to create a simple AutoCloseable object, to close it using try-with-resources, and to have the garbage collector reclaim it is about 12 ns. Using a finalizer instead increases the time to 550 ns. In other words, it is about 50 times slower to create and destroy objects with finalizers. This is primarily because finalizers inhibit efficient garbage collection. Cleaners are comparable in speed to finalizers if you use them to clean all instances of the class (about 500 ns per instance on my machine), but cleaners are much faster if you use them only as a safety net, as discussed below. Under these circumstances, creating, cleaning, and destroying an object takes about 66 ns on my machine, which means you pay a factor of five (not fifty) for the insurance of a safety net if you don\u2019t use it."),(0,r.kt)("p",null,"\u4f7f\u7528\u7ec8\u7ed3\u5668\u548c\u6e05\u9664\u5668\u4f1a\u4e25\u91cd\u5f71\u54cd\u6027\u80fd\u3002\u5728\u6211\u7684\u673a\u5668\u4e0a\uff0c\u521b\u5efa\u4e00\u4e2a\u7b80\u5355\u7684 AutoCloseable \u5bf9\u8c61\uff0c\u4f7f\u7528 try-with-resources \u5173\u95ed\u5b83\u4ee5\u53ca\u8ba9\u5783\u573e\u6536\u96c6\u5668\u56de\u6536\u5b83\u7684\u65f6\u95f4\u5927\u7ea6\u662f 12ns\u3002\u76f8\u53cd\uff0c\u4f7f\u7528\u7ec8\u7ed3\u5668\u5c06\u65f6\u95f4\u589e\u52a0\u5230 550ns\u3002\u6362\u53e5\u8bdd\u8bf4\uff0c\u4f7f\u7528\u7ec8\u7ed3\u5668\u521b\u5efa\u548c\u9500\u6bc1\u5bf9\u8c61\u5927\u7ea6\u8981\u6162 50 \u500d\u3002\u8fd9\u4e3b\u8981\u662f\u56e0\u4e3a\u7ec8\u7ed3\u5668\u6291\u5236\u4e86\u6709\u6548\u7684\u5783\u573e\u6536\u96c6\u3002\u5982\u679c\u4f7f\u7528\u6e05\u9664\u5668\u6e05\u9664\u7684\u6240\u6709\u5b9e\u4f8b\uff08\u5728\u6211\u7684\u673a\u5668\u4e0a\u6bcf\u4e2a\u5b9e\u4f8b\u5927\u7ea6 500ns\uff09\uff0c\u90a3\u4e48\u6e05\u9664\u5668\u7684\u901f\u5ea6\u4e0e\u7ec8\u7ed3\u5668\u76f8\u5f53\uff0c\u4f46\u662f\u5982\u679c\u53ea\u5c06\u5b83\u4eec\u4f5c\u4e3a\u5b89\u5168\u7f51\u6765\u4f7f\u7528\uff0c\u6e05\u9664\u5668\u7684\u901f\u5ea6\u8981\u5feb\u5f97\u591a\uff0c\u5982\u4e0b\u6240\u8ff0\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u5728\u6211\u7684\u673a\u5668\u4e0a\u521b\u5efa\u3001\u6e05\u7406\u548c\u9500\u6bc1\u4e00\u4e2a\u5bf9\u8c61\u9700\u8981\u82b1\u8d39 66ns \u7684\u65f6\u95f4\uff0c\u8fd9\u610f\u5473\u7740\u5982\u679c\u4f60\u4e0d\u4f7f\u7528\u5b83\uff0c\u4f60\u9700\u8981\u591a\u51fa\u4e94\u500d\uff08\u800c\u4e0d\u662f\u4e94\u5341\u500d\uff09\u7684\u4fdd\u969c\u6210\u672c\u3002"),(0,r.kt)("p",null,"Finalizers have a serious security problem: they open your class up to finalizer attacks. The idea behind a finalizer attack is simple: If an exception is thrown from a constructor or its serialization equivalents\u2014the readObject and readResolve methods (Chapter 12)\u2014the finalizer of a malicious subclass can run on the partially constructed object that should have \u201cdied on the vine.\u201d This finalizer can record a reference to the object in a static field,preventing it from being garbage collected. Once the malformed object has been recorded, it is a simple matter to invoke arbitrary methods on this object that should never have been allowed to exist in the first place. Throwing an exception from a constructor should be sufficient to prevent an object from coming into existence; in the presence of finalizers, it is not. Such attacks can have dire consequences. Final classes are immune to finalizer attacks because no one can write a malicious subclass of a final class. To protect nonfinal classes from finalizer attacks, write a final finalize method that does nothing."),(0,r.kt)("p",null,"\u7ec8\u7ed3\u5668\u6709\u4e00\u4e2a\u4e25\u91cd\u7684\u5b89\u5168\u95ee\u9898\uff1a\u5b83\u4eec\u4f1a\u8ba9\u4f60\u7684\u7c7b\u53d7\u5230\u7ec8\u7ed3\u5668\u653b\u51fb\u3002\u7ec8\u7ed3\u5668\u653b\u51fb\u80cc\u540e\u7684\u601d\u60f3\u5f88\u7b80\u5355\uff1a\u5982\u679c\u4ece\u6784\u9020\u51fd\u6570\u6216\u5b83\u7684\u5e8f\u5217\u5316\u7b49\u4ef7\u7269\uff08readObject \u548c readResolve \u65b9\u6cd5\uff08",(0,r.kt)("a",{parentName:"p",href:"./Chapter-3-Item-12-Always-override-toString"},"Item-12"),"\uff09\uff09\u629b\u51fa\u4e00\u4e2a\u5f02\u5e38\uff0c\u6076\u610f\u5b50\u7c7b\u7684\u7ec8\u7ed3\u5668\u5c31\u53ef\u4ee5\u8fd0\u884c\u5728\u90e8\u5206\u6784\u9020\u7684\u5bf9\u8c61\u4e0a\uff0c\u800c\u8fd9\u4e2a\u5bf9\u8c61\u672c\u6765\u5e94\u8be5\u300c\u80ce\u6b7b\u8179\u4e2d\u300d\u3002\u8fd9\u4e2a\u7ec8\u7ed3\u5668\u53ef\u4ee5\u5728\u9759\u6001\u5b57\u6bb5\u4e2d\u8bb0\u5f55\u5bf9\u5bf9\u8c61\u7684\u5f15\u7528\uff0c\u9632\u6b62\u5b83\u88ab\u5783\u573e\u6536\u96c6\u3002\u4e00\u65e6\u8bb0\u5f55\u4e86\u7578\u5f62\u5bf9\u8c61\uff0c\u5c31\u5f88\u5bb9\u6613\u5728\u8fd9\u4e2a\u5bf9\u8c61\u4e0a\u8c03\u7528\u672c\u6765\u5c31\u4e0d\u5e94\u8be5\u5b58\u5728\u7684\u4efb\u610f\u65b9\u6cd5\u3002\u4ece\u6784\u9020\u51fd\u6570\u629b\u51fa\u5f02\u5e38\u5e94\u8be5\u8db3\u4ee5\u9632\u6b62\u5bf9\u8c61\u7684\u51fa\u73b0\uff1b\u5728\u6709\u7ec8\u7ed3\u5668\u7684\u60c5\u51b5\u4e0b\uff0c\u5c31\u4e0d\u662f\u8fd9\u6837\u4e86\u3002\u8fd9\u6837\u7684\u653b\u51fb\u53ef\u80fd\u4f1a\u9020\u6210\u53ef\u6015\u7684\u540e\u679c\u3002\u6700\u7ec8\u7c7b\u5bf9\u7ec8\u7ed3\u5668\u653b\u51fb\u514d\u75ab\uff0c\u56e0\u4e3a\u6ca1\u6709\u4eba\u80fd\u591f\u7f16\u5199\u6700\u7ec8\u7c7b\u7684\u6076\u610f\u5b50\u7c7b\u3002\u4e3a\u4e86\u4fdd\u62a4\u975e\u6700\u7ec8\u7c7b\u4e0d\u53d7\u7ec8\u7ed3\u5668\u653b\u51fb\uff0c\u7f16\u5199\u4e00\u4e2a\u4e0d\u6267\u884c\u4efb\u4f55\u64cd\u4f5c\u7684\u6700\u7ec8\u7ec8\u7ed3\u65b9\u6cd5\u3002"),(0,r.kt)("p",null,"So what should you do instead of writing a finalizer or cleaner for a class whose objects encapsulate resources that require termination, such as files or threads? Just have your class implement AutoCloseable, and require its clients to invoke the close method on each instance when it is no longer needed, typically using try-with-resources to ensure termination even in the face of exceptions (Item 9). One detail worth mentioning is that the instance must keep track of whether it has been closed: the close method must record in a field that the object is no longer valid, and other methods must check this field and throw an IllegalStateException if they are called after the object has been closed."),(0,r.kt)("p",null,"\u90a3\u4e48\uff0c\u5982\u679c\u4e00\u4e2a\u7c7b\u7684\u5bf9\u8c61\u5c01\u88c5\u4e86\u9700\u8981\u7ec8\u6b62\u7684\u8d44\u6e90\uff0c\u4f8b\u5982\u6587\u4ef6\u6216\u7ebf\u7a0b\uff0c\u90a3\u4e48\u5e94\u8be5\u505a\u4ec0\u4e48\uff0c\u800c\u4e0d\u662f\u4e3a\u5b83\u7f16\u5199\u7ec8\u7ed3\u5668\u6216\u6e05\u9664\u5668\u5462\uff1f\u53ea\u6709\u4f60\u7684\u7c7b\u5b9e\u73b0 AutoCloseable\uff0c\u8981\u6c42\u5176\u5ba2\u6237\u7aef\u6bcf\u4e2a\u5b9e\u4f8b\u5728\u4e0d\u518d\u9700\u8981\u65f6\u8c03\u7528\u5173\u95ed\u65b9\u6cd5\uff0c\u901a\u5e38\u4f7f\u7528 try-with-resources \u786e\u4fdd\u7ec8\u6b62\uff0c\u5373\u4f7f\u9762\u5bf9\u5f02\u5e38\uff08",(0,r.kt)("a",{parentName:"p",href:"./Chapter-2-Item-9-Prefer-try-with-resources-to-try-finally"},"Item-9"),"\uff09\u3002\u4e00\u4e2a\u503c\u5f97\u4e00\u63d0\u7684\u7ec6\u8282\u662f\u5b9e\u4f8b\u5fc5\u987b\u8ddf\u8e2a\u662f\u5426\u5df2\u7ecf\u5173\u95ed\uff1aclose \u65b9\u6cd5\u5fc5\u987b\u5728\u5b57\u6bb5\u4e2d\u8bb0\u5f55\u5bf9\u8c61\u4e0d\u518d\u6709\u6548\uff0c\u5176\u4ed6\u65b9\u6cd5\u5fc5\u987b\u68c0\u67e5\u8fd9\u4e2a\u5b57\u6bb5\uff0c\u5982\u679c\u5728\u5bf9\u8c61\u5173\u95ed\u540e\u8c03\u7528\u5b83\u4eec\uff0c\u5219\u5fc5\u987b\u629b\u51fa\u4e00\u4e2a IllegalStateException\u3002"),(0,r.kt)("p",null,"So what, if anything, are cleaners and finalizers good for? They have perhaps two legitimate uses. One is to act as a safety net in case the owner of a resource neglects to call its close method. While there\u2019s no guarantee that the cleaner or finalizer will run promptly (or at all), it is better to free the resource late than never if the client fails to do so. If you\u2019re considering writing such a safety-net finalizer, think long and hard about whether the protection is worth the cost.Some Java library classes, such as FileInputStream,FileOutputStream, ThreadPoolExecutor, and java.sql.Connection, have finalizers that serve as safety nets."),(0,r.kt)("p",null,"\u90a3\u4e48\uff0c\u6e05\u9664\u5668\u548c\u7ec8\u7ed3\u5668\u6709\u4ec0\u4e48\u7528\u5462\uff1f\u5b83\u4eec\u53ef\u80fd\u6709\u4e24\u79cd\u5408\u6cd5\u7528\u9014\u3002\u4e00\u79cd\u662f\u5145\u5f53\u4e00\u4e2a\u5b89\u5168\u7f51\uff0c\u4ee5\u9632\u8d44\u6e90\u7684\u6240\u6709\u8005\u5ffd\u7565\u8c03\u7528\u5b83\u7684 close \u65b9\u6cd5\u3002\u867d\u7136\u4e0d\u80fd\u4fdd\u8bc1\u6e05\u9664\u5668\u6216\u7ec8\u7ed3\u5668\u5c06\u7acb\u5373\u8fd0\u884c\uff08\u6216\u6839\u672c\u4e0d\u8fd0\u884c\uff09\uff0c\u4f46\u5982\u679c\u5ba2\u6237\u7aef\u6ca1\u6709\u8fd9\u6837\u505a\uff0c\u6700\u597d\u662f\u5ef6\u8fdf\u91ca\u653e\u8d44\u6e90\u3002\u5982\u679c\u4f60\u6b63\u5728\u8003\u8651\u7f16\u5199\u8fd9\u6837\u4e00\u4e2a\u5b89\u5168\u7f51\u7edc\u7ec8\u7ed3\u5668\uff0c\u90a3\u5c31\u597d\u597d\u8003\u8651\u4e00\u4e0b\u8fd9\u79cd\u4fdd\u62a4\u662f\u5426\u503c\u5f97\u3002\u4e00\u4e9b Java \u5e93\u7c7b\uff0c\u5982 FileInputStream\u3001FileOutputStream\u3001ThreadPoolExecutor \u548c java.sql.Connection\uff0c\u90fd\u6709\u7ec8\u7ed3\u5668\u4f5c\u4e3a\u5b89\u5168\u7f51\u3002"),(0,r.kt)("p",null,"A second legitimate use of cleaners concerns objects with native peers. A native peer is a native (non-Java) object to which a normal object delegates via native methods. Because a native peer is not a normal object, the garbage collector doesn\u2019t know about it and can\u2019t reclaim it when its Java peer is reclaimed. A cleaner or finalizer may be an appropriate vehicle for this task,assuming the performance is acceptable and the native peer holds no critical resources. If the performance is unacceptable or the native peer holds resources that must be reclaimed promptly, the class should have a close method, as described earlier."),(0,r.kt)("p",null,"\u6e05\u6d01\u5668\u7684\u7b2c\u4e8c\u4e2a\u5408\u6cd5\u4f7f\u7528\u6d89\u53ca\u5230\u4e0e\u672c\u673a\u5bf9\u7b49\u4f53\u7684\u5bf9\u8c61\u3002\u672c\u673a\u5bf9\u7b49\u70b9\u662f\u666e\u901a\u5bf9\u8c61\u901a\u8fc7\u672c\u673a\u65b9\u6cd5\u59d4\u6258\u7ed9\u7684\u672c\u673a\uff08\u975e java\uff09\u5bf9\u8c61\u3002\u56e0\u4e3a\u672c\u673a\u5bf9\u7b49\u70b9\u4e0d\u662f\u4e00\u4e2a\u6b63\u5e38\u7684\u5bf9\u8c61\uff0c\u5783\u573e\u6536\u96c6\u5668\u4e0d\u77e5\u9053\u5b83\uff0c\u5e76\u4e14\u4e0d\u80fd\u5728\u56de\u6536 Java \u5bf9\u7b49\u70b9\u65f6\u56de\u6536\u5b83\u3002\u5982\u679c\u6027\u80fd\u662f\u53ef\u63a5\u53d7\u7684\uff0c\u5e76\u4e14\u672c\u673a\u5bf9\u7b49\u4f53\u4e0d\u6301\u6709\u4efb\u4f55\u5173\u952e\u8d44\u6e90\uff0c\u90a3\u4e48\u66f4\u6e05\u6d01\u6216\u7ec8\u7ed3\u5668\u53ef\u80fd\u662f\u5b8c\u6210\u8fd9\u9879\u4efb\u52a1\u7684\u5408\u9002\u5de5\u5177\u3002\u5982\u679c\u6027\u80fd\u4e0d\u53ef\u63a5\u53d7\uff0c\u6216\u8005\u672c\u673a\u5bf9\u7b49\u4f53\u6301\u6709\u5fc5\u987b\u7acb\u5373\u56de\u6536\u7684\u8d44\u6e90\uff0c\u5219\u7c7b\u5e94\u8be5\u5177\u6709\u524d\u9762\u63cf\u8ff0\u7684\u5173\u95ed\u65b9\u6cd5\u3002"),(0,r.kt)("p",null,"Cleaners are a bit tricky to use. Below is a simple Room class demonstrating the facility. Let\u2019s assume that rooms must be cleaned before they are reclaimed.The Room class implements AutoCloseable; the fact that its automatic cleaning safety net uses a cleaner is merely an implementation detail. Unlike finalizers, cleaners do not pollute a class\u2019s public API:"),(0,r.kt)("p",null,"\u6e05\u9664\u5668\u7684\u4f7f\u7528\u6709\u4e9b\u68d8\u624b\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u7684 Room \u7c7b\uff0c\u5c55\u793a\u4e86\u8fd9\u4e2a\u8bbe\u65bd\u3002\u8ba9\u6211\u4eec\u5047\u8bbe\u623f\u95f4\u5728\u56de\u6536\u4e4b\u524d\u5fc5\u987b\u88ab\u6e05\u7406\u3002Room \u7c7b\u5b9e\u73b0\u4e86 AutoCloseable\uff1b\u5b83\u7684\u81ea\u52a8\u6e05\u6d17\u5b89\u5168\u7f51\u4f7f\u7528\u4e86\u6e05\u9664\u5668\uff0c\u8fd9\u53ea\u662f\u4e00\u4e2a\u5b9e\u73b0\u7ec6\u8282\u3002\u4e0e\u7ec8\u7ed3\u5668\u4e0d\u540c\uff0c\u6e05\u9664\u5668\u4e0d\u4f1a\u6c61\u67d3\u7c7b\u7684\u516c\u5171 API\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'import sun.misc.Cleaner;\n\n// An autocloseable class using a cleaner as a safety net\npublic class Room implements AutoCloseable {\n    private static final Cleaner cleaner = Cleaner.create();\n\n    // Resource that requires cleaning. Must not refer to Room!\n    private static class State implements Runnable {\n        int numJunkPiles; // Number of junk piles in this room\n\n        State(int numJunkPiles) {\n            this.numJunkPiles = numJunkPiles;\n        }\n\n        // Invoked by close method or cleaner\n        @Override\n        public void run() {\n            System.out.println("Cleaning room");\n            numJunkPiles = 0;\n        }\n    }\n\n    // The state of this room, shared with our cleanable\n    private final State state;\n    // Our cleanable. Cleans the room when it\u2019s eligible for gc\n    private final Cleaner.Cleanable cleanable;\n\n    public Room(int numJunkPiles) {\n        state = new State(numJunkPiles);\n        cleanable = cleaner.register(this, state);\n    }\n\n    @Override\n    public void close() {\n        cleanable.clean();\n    }\n}\n')),(0,r.kt)("p",null,"The static nested State class holds the resources that are required by the cleaner to clean the room. In this case, it is simply the numJunkPiles field,which represents the amount of mess in the room. More realistically, it might be a final long that contains a pointer to a native peer. State implements Runnable, and its run method is called at most once, by the Cleanable that we get when we register our State instance with our cleaner in the Room constructor. The call to the run method will be triggered by one of two things:Usually it is triggered by a call to Room\u2019s close method calling Cleanable\u2019s clean method. If the client fails to call the close method by the time a Room instance is eligible for garbage collection, the cleaner will (hopefully) call State\u2019s run method."),(0,r.kt)("p",null,"\u9759\u6001\u5d4c\u5957 State \u7c7b\u6301\u6709\u6e05\u6d01\u5668\u6e05\u6d01\u623f\u95f4\u6240\u9700\u7684\u8d44\u6e90\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u5b83\u4ec5\u4ec5\u662f numJunkPiles \u5b57\u6bb5\uff0c\u8868\u793a\u623f\u95f4\u7684\u6df7\u4e71\u7a0b\u5ea6\u3002\u66f4\u5b9e\u9645\u5730\u8bf4\uff0c\u5b83\u53ef\u80fd\u662f\u6700\u540e\u4e00\u4e2a\u5305\u542b\u6307\u5411\u672c\u673a\u5bf9\u7b49\u70b9\u7684 long \u6307\u9488\u3002State \u5b9e\u73b0\u4e86 Runnable\uff0c\u5b83\u7684\u8fd0\u884c\u65b9\u6cd5\u6700\u591a\u88ab\u8c03\u7528\u4e00\u6b21\uff0c\u7531\u6211\u4eec\u5728 Room \u6784\u9020\u5668\u4e2d\u5411 cleaner \u5b9e\u4f8b\u6ce8\u518c\u72b6\u6001\u5b9e\u4f8b\u65f6\u5f97\u5230\u7684 Cleanable \u8c03\u7528\u3002\u5bf9 run \u65b9\u6cd5\u7684\u8c03\u7528\u5c06\u7531\u4ee5\u4e0b\u4e24\u79cd\u65b9\u6cd5\u4e4b\u4e00\u89e6\u53d1\uff1a\u901a\u5e38\u662f\u901a\u8fc7\u8c03\u7528 Room \u7684 close \u65b9\u6cd5\u6765\u89e6\u53d1\uff0c\u8c03\u7528 Cleanable \u7684 clean \u65b9\u6cd5\u3002\u5982\u679c\u5f53\u4e00\u4e2a Room \u5b9e\u4f8b\u6709\u8d44\u683c\u8fdb\u884c\u5783\u573e\u6536\u96c6\u65f6\uff0c\u5ba2\u6237\u7aef\u6ca1\u6709\u8c03\u7528 close \u65b9\u6cd5\uff0c\u90a3\u4e48\u6e05\u9664\u5668\u5c06\u8c03\u7528 State \u7684 run \u65b9\u6cd5\uff08\u5e0c\u671b\u5982\u6b64\uff09\u3002"),(0,r.kt)("p",null,"It is critical that a State instance does not refer to its Room instance. If it did, it would create a circularity that would prevent the Room instance from becoming eligible for garbage collection (and from being automatically cleaned).Therefore, State must be a static nested class because nonstatic nested classes contain references to their enclosing instances (Item 24). It is similarly inadvisable to use a lambda because they can easily capture references to enclosing objects."),(0,r.kt)("p",null,"\u72b6\u6001\u5b9e\u4f8b\u4e0d\u5f15\u7528\u5176 Room \u5b9e\u4f8b\u662f\u975e\u5e38\u91cd\u8981\u7684\u3002\u5982\u679c\u5b83\u8fd9\u6837\u505a\u4e86\uff0c\u5b83\u5c06\u521b\u5efa\u4e00\u4e2a\u5faa\u73af\uff0c\u4ee5\u9632\u6b62 Room \u5b9e\u4f8b\u6709\u8d44\u683c\u8fdb\u884c\u5783\u573e\u6536\u96c6\uff08\u4ee5\u53ca\u81ea\u52a8\u6e05\u7406\uff09\u3002\u56e0\u6b64\uff0c\u72b6\u6001\u5fc5\u987b\u662f\u4e00\u4e2a\u9759\u6001\u5d4c\u5957\u7c7b\uff0c\u56e0\u4e3a\u975e\u9759\u6001\u5d4c\u5957\u7c7b\u5305\u542b\u5bf9\u5176\u5c01\u95ed\u5b9e\u4f8b\u7684\u5f15\u7528\uff08",(0,r.kt)("a",{parentName:"p",href:"./Chapter-4-Item-24-Favor-static-member-classes-over-nonstatic"},"Item-24"),"\uff09\u3002\u540c\u6837\u4e0d\u5efa\u8bae\u4f7f\u7528 lambda\uff0c\u56e0\u4e3a\u5b83\u4eec\u53ef\u4ee5\u5f88\u5bb9\u6613\u5730\u6355\u83b7\u5bf9\u5305\u56f4\u5bf9\u8c61\u7684\u5f15\u7528\u3002"),(0,r.kt)("p",null,"As we said earlier, Room\u2019s cleaner is used only as a safety net. If clients surround all Room instantiations in try-with-resource blocks, automatic cleaning will never be required. This well-behaved client demonstrates that behavior:"),(0,r.kt)("p",null,"\u5c31\u50cf\u6211\u4eec\u4e4b\u524d\u8bf4\u7684\uff0cRoom \u7c7b\u7684\u6e05\u9664\u5668\u53ea\u662f\u7528\u4f5c\u5b89\u5168\u7f51\u3002\u5982\u679c\u5ba2\u6237\u7aef\u5c06\u6240\u6709 Room \u5b9e\u4f8b\u5305\u56f4\u5728\u5e26\u6709\u8d44\u6e90\u7684 try \u5757\u4e2d\uff0c\u5219\u6c38\u8fdc\u4e0d\u9700\u8981\u81ea\u52a8\u6e05\u7406\u3002\u8fd9\u4f4d\u8868\u73b0\u826f\u597d\u7684\u5ba2\u6237\u7aef\u5c55\u793a\u4e86\u8fd9\u79cd\u505a\u6cd5\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'public class Adult {\n    public static void main(String[] args) {\n        try (Room myRoom = new Room(7)) {\n            System.out.println("Goodbye");\n        }\n    }\n}\n')),(0,r.kt)("p",null,"As you\u2019d expect, running the Adult program prints Goodbye, followed by Cleaning room. But what about this ill-behaved program, which never cleans its room?"),(0,r.kt)("p",null,"\u5982\u4f60\u6240\u6599\uff0c\u8fd0\u884c Adult \u7a0b\u5e8f\u6253\u5370\u300cGoodbye\u300d\uff0c\u7136\u540e\u662f\u6253\u626b\u623f\u95f4\u3002\u4f46\u8fd9\u4e2a\u4ece\u4e0d\u6253\u626b\u623f\u95f4\u7684\u4e0d\u5b88\u89c4\u77e9\u7684\u7a0b\u5e8f\u600e\u4e48\u529e\uff1f"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'public class Teenager {\n    public static void main(String[] args) {\n        new Room(99);\n        System.out.println("Peace out");\n    }\n}\n')),(0,r.kt)("p",null,"You might expect it to print Peace out, followed by Cleaning room, but on my machine, it never prints Cleaning room; it just exits. This is the unpredictability we spoke of earlier. The Cleaner spec says, \u201cThe behavior of cleaners during System.exit is implementation specific. No guarantees are made relating to whether cleaning actions are invoked or not.\u201d While the spec does not say it, the same holds true for normal program exit. On my machine,adding the line System.gc() to Teenager\u2019s main method is enough to make it print Cleaning room prior to exit, but there\u2019s no guarantee that you\u2019ll see the same behavior on your machine.In summary, don\u2019t use cleaners, or in releases prior to Java 9, finalizers,except as a safety net or to terminate noncritical native resources. Even then,beware the indeterminacy and performance consequences."),(0,r.kt)("p",null,"\u4f60\u53ef\u80fd\u671f\u671b\u5b83\u6253\u5370\u51fa\u300cPeace out\u300d\uff0c\u7136\u540e\u6253\u626b\u623f\u95f4\uff0c\u4f46\u5728\u6211\u7684\u673a\u5668\u4e0a\uff0c\u5b83\u4ece\u4e0d\u6253\u626b\u623f\u95f4\uff1b\u5b83\u53ea\u662f\u9000\u51fa\u3002\u8fd9\u5c31\u662f\u6211\u4eec\u4e4b\u524d\u63d0\u5230\u7684\u4e0d\u53ef\u9884\u6d4b\u6027\u3002Cleaner \u89c4\u8303\u8bf4\uff1a\u300c\u5728 System.exit \u4e2d\uff0c\u6e05\u6d01\u5668\u7684\u884c\u4e3a\u662f\u7279\u5b9a\u4e8e\u5b9e\u73b0\u7684\u3002\u4e0d\u4fdd\u8bc1\u6e05\u7406\u64cd\u4f5c\u662f\u5426\u88ab\u8c03\u7528\u3002\u300d\u867d\u7136\u89c4\u8303\u6ca1\u6709\u8bf4\u660e\uff0c\u4f46\u5bf9\u4e8e\u666e\u901a\u7a0b\u5e8f\u9000\u51fa\u6765\u8bf4\u4e5f\u662f\u4e00\u6837\u3002\u5728\u6211\u7684\u673a\u5668\u4e0a\uff0c\u5c06 System.gc() \u6dfb\u52a0\u5230 Teenager \u7684\u4e3b\u8981\u65b9\u6cd5\u4e2d\u5c31\u8db3\u4ee5\u8ba9\u5b83\u5728\u9000\u51fa\u4e4b\u524d\u6253\u626b\u623f\u95f4\uff0c\u4f46\u4e0d\u80fd\u4fdd\u8bc1\u5728\u5176\u4ed6\u673a\u5668\u4e0a\u770b\u5230\u76f8\u540c\u7684\u884c\u4e3a\u3002\u603b\u4e4b\uff0c\u4e0d\u8981\u4f7f\u7528\u6e05\u6d01\u5668\uff0c\u6216\u8005\u5728 Java 9 \u4e4b\u524d\u7684\u7248\u672c\u4e2d\u4f7f\u7528\u7ec8\u7ed3\u5668\uff0c\u9664\u975e\u662f\u4f5c\u4e3a\u5b89\u5168\u7f51\u6216\u7ec8\u6b62\u975e\u5173\u952e\u7684\u672c\u673a\u8d44\u6e90\u3002\u5373\u4fbf\u5982\u6b64\uff0c\u4e5f\u8981\u5c0f\u5fc3\u4e0d\u786e\u5b9a\u6027\u548c\u6027\u80fd\u540e\u679c\u3002"),(0,r.kt)("hr",null),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"./Chapter-2-Introduction"},"Back to contents of the chapter\uff08\u8fd4\u56de\u7ae0\u8282\u76ee\u5f55\uff09"))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Previous Item\uff08\u4e0a\u4e00\u6761\u76ee\uff09\uff1a",(0,r.kt)("a",{parentName:"strong",href:"./Chapter-2-Item-7-Eliminate-obsolete-object-references"},"Item 7: Eliminate obsolete object references\uff08\u6392\u9664\u8fc7\u65f6\u7684\u5bf9\u8c61\u5f15\u7528\uff09"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Next Item\uff08\u4e0b\u4e00\u6761\u76ee\uff09\uff1a",(0,r.kt)("a",{parentName:"strong",href:"./Chapter-2-Item-9-Prefer-try-with-resources-to-try-finally"},"Item 9: Prefer try with resources to try finally\uff08\u4f7f\u7528 try-with-resources \u4f18\u4e8e try-finally\uff09")))))}h.isMDXComponent=!0}}]);