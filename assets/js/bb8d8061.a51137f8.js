"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[8408],{3905:(e,t,a)=>{a.d(t,{Zo:()=>m,kt:()=>d});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},m=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,m=i(e,["components","mdxType","originalType","parentName"]),u=c(a),d=r,h=u["".concat(l,".").concat(d)]||u[d]||p[d]||o;return a?n.createElement(h,s(s({ref:t},m),{},{components:a})):n.createElement(h,s({ref:t},m))}));function d(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,s=new Array(o);s[0]=u;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var c=2;c<o;c++)s[c]=a[c];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},1959:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var n=a(7462),r=(a(7294),a(3905));const o={},s=void 0,i={unversionedId:"Books/EffectiveJava3/Chapter-7/Chapter-7-Item-42-Prefer-lambdas-to-anonymous-classes",id:"Books/EffectiveJava3/Chapter-7/Chapter-7-Item-42-Prefer-lambdas-to-anonymous-classes",title:"Chapter-7-Item-42-Prefer-lambdas-to-anonymous-classes",description:"Chapter 7. Lambdas and Streams\uff08\u03bb \u8868\u8fbe\u5f0f\u548c\u6d41\uff09",source:"@site/docs/Books/EffectiveJava3/Chapter-7/Chapter-7-Item-42-Prefer-lambdas-to-anonymous-classes.md",sourceDirName:"Books/EffectiveJava3/Chapter-7",slug:"/Books/EffectiveJava3/Chapter-7/Chapter-7-Item-42-Prefer-lambdas-to-anonymous-classes",permalink:"/docs/Books/EffectiveJava3/Chapter-7/Chapter-7-Item-42-Prefer-lambdas-to-anonymous-classes",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Books/EffectiveJava3/Chapter-7/Chapter-7-Item-42-Prefer-lambdas-to-anonymous-classes.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Chapter-7-Introduction",permalink:"/docs/Books/EffectiveJava3/Chapter-7/Chapter-7-Introduction"},next:{title:"Chapter-7-Item-43-Prefer-method-references-to-lambdas",permalink:"/docs/Books/EffectiveJava3/Chapter-7/Chapter-7-Item-43-Prefer-method-references-to-lambdas"}},l={},c=[{value:"Chapter 7. Lambdas and Streams\uff08\u03bb \u8868\u8fbe\u5f0f\u548c\u6d41\uff09",id:"chapter-7-lambdas-and-streams\u03bb-\u8868\u8fbe\u5f0f\u548c\u6d41",level:2},{value:"Item 42: Prefer lambdas to anonymous classes\uff08\u03bb \u8868\u8fbe\u5f0f\u4f18\u4e8e\u533f\u540d\u7c7b\uff09",id:"item-42-prefer-lambdas-to-anonymous-classes\u03bb-\u8868\u8fbe\u5f0f\u4f18\u4e8e\u533f\u540d\u7c7b",level:3}],m={toc:c};function p(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"chapter-7-lambdas-and-streams\u03bb-\u8868\u8fbe\u5f0f\u548c\u6d41"},"Chapter 7. Lambdas and Streams\uff08\u03bb \u8868\u8fbe\u5f0f\u548c\u6d41\uff09"),(0,r.kt)("h3",{id:"item-42-prefer-lambdas-to-anonymous-classes\u03bb-\u8868\u8fbe\u5f0f\u4f18\u4e8e\u533f\u540d\u7c7b"},"Item 42: Prefer lambdas to anonymous classes\uff08\u03bb \u8868\u8fbe\u5f0f\u4f18\u4e8e\u533f\u540d\u7c7b\uff09"),(0,r.kt)("p",null,"Historically, interfaces (or, rarely, abstract classes) with a single abstract method were used as function types. Their instances, known as function objects, represent functions or actions. Since JDK 1.1 was released in 1997, the primary means of creating a function object was the anonymous class (Item 24). Here\u2019s a code snippet to sort a list of strings in order of length, using an anonymous class to create the sort\u2019s comparison function (which imposes the sort order):"),(0,r.kt)("p",null,"\u5728\u5386\u53f2\u4e0a\uff0c\u5e26\u6709\u5355\u4e2a\u62bd\u8c61\u65b9\u6cd5\u7684\u63a5\u53e3\uff08\u6216\u8005\u62bd\u8c61\u7c7b\uff0c\u4f46\u8fd9\u79cd\u60c5\u51b5\u5f88\u5c11\uff09\u88ab\u7528\u4f5c\u51fd\u6570\u7c7b\u578b\u3002\u5b83\u4eec\u7684\u5b9e\u4f8b\uff08\u79f0\u4e3a\u51fd\u6570\u5bf9\u8c61\uff09\u8868\u793a\u51fd\u6570\u6216\u64cd\u4f5c\u3002\u81ea\u4ece JDK 1.1 \u5728 1997 \u5e74\u53d1\u5e03\u4ee5\u6765\uff0c\u521b\u5efa\u51fd\u6570\u5bf9\u8c61\u7684\u4e3b\u8981\u65b9\u6cd5\u5c31\u662f\u533f\u540d\u7c7b\uff08",(0,r.kt)("a",{parentName:"p",href:"./Chapter-4-Item-24-Favor-static-member-classes-over-nonstatic"},"Item-24"),"\uff09\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u6309\u957f\u5ea6\u5bf9\u5b57\u7b26\u4e32\u5217\u8868\u8fdb\u884c\u6392\u5e8f\u7684\u4ee3\u7801\u7247\u6bb5\uff0c\u4f7f\u7528\u4e00\u4e2a\u533f\u540d\u7c7b\u6765\u521b\u5efa\u6392\u5e8f\u7684\u6bd4\u8f83\u51fd\u6570\uff08\u5b83\u5f3a\u5236\u6267\u884c\u6392\u5e8f\u987a\u5e8f\uff09\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"// Anonymous class instance as a function object - obsolete!\nCollections.sort(words, new Comparator<String>() {\n    public int compare(String s1, String s2) {\n        return Integer.compare(s1.length(), s2.length());\n    }\n});\n")),(0,r.kt)("p",null,"Anonymous classes were adequate for the classic objected-oriented design patterns requiring function objects, notably the Strategy pattern ","[Gamma95]",". The Comparator interface represents an abstract strategy for sorting; the anonymous class above is a concrete strategy for sorting strings. The verbosity of anonymous classes, however, made functional programming in Java an unappealing prospect."),(0,r.kt)("p",null,"\u533f\u540d\u7c7b\u5bf9\u4e8e\u9700\u8981\u51fd\u6570\u5bf9\u8c61\u7684\u5178\u578b\u9762\u5411\u5bf9\u8c61\u8bbe\u8ba1\u6a21\u5f0f\u6765\u8bf4\u5df2\u7ecf\u8db3\u591f\u4e86\uff0c\u5c24\u5176\u662f\u7b56\u7565\u6a21\u5f0f ","[Gamma95]","\u3002Comparator \u63a5\u53e3\u8868\u793a\u6392\u5e8f\u7684\u62bd\u8c61\u7b56\u7565\uff1b\u4e0a\u8ff0\u533f\u540d\u7c7b\u662f\u5bf9\u5b57\u7b26\u4e32\u6392\u5e8f\u7684\u4e00\u79cd\u5177\u4f53\u7b56\u7565\u3002\u7136\u800c\uff0c\u533f\u540d\u7c7b\u7684\u5197\u957f\u4f7f\u51fd\u6570\u5f0f\u7f16\u7a0b\u5728 Java \u4e2d\u53d8\u5f97\u6beb\u65e0\u5438\u5f15\u529b\u3002"),(0,r.kt)("p",null,"In Java 8, the language formalized the notion that interfaces with a single abstract method are special and deserve special treatment. These interfaces are now known as functional interfaces, and the language allows you to create instances of these interfaces using lambda expressions, or lambdas for short. Lambdas are similar in function to anonymous classes, but far more concise. Here\u2019s how the code snippet above looks with the anonymous class replaced by a lambda. The boilerplate is gone, and the behavior is clearly evident:"),(0,r.kt)("p",null,"\u5728 Java 8 \u4e2d\u5b98\u65b9\u5316\u4e86\u4e00\u4e2a\u6982\u5ff5\uff0c\u5373\u5177\u6709\u5355\u4e2a\u62bd\u8c61\u65b9\u6cd5\u7684\u63a5\u53e3\u662f\u7279\u6b8a\u7684\uff0c\u5e94\u8be5\u5f97\u5230\u7279\u6b8a\u5904\u7406\u3002\u8fd9\u4e9b\u63a5\u53e3\u73b0\u5728\u88ab\u79f0\u4e3a\u51fd\u6570\u5f0f\u63a5\u53e3\uff0c\u5141\u8bb8\u4f7f\u7528 lambda \u8868\u8fbe\u5f0f\u521b\u5efa\u8fd9\u4e9b\u63a5\u53e3\u7684\u5b9e\u4f8b\u3002Lambda \u8868\u8fbe\u5f0f\u5728\u529f\u80fd\u4e0a\u7c7b\u4f3c\u4e8e\u533f\u540d\u7c7b\uff0c\u4f46\u662f\u66f4\u52a0\u7b80\u6d01\u3002\u4e0b\u9762\u7684\u4ee3\u7801\u7247\u6bb5\uff0c\u533f\u540d\u7c7b\u88ab lambda \u8868\u8fbe\u5f0f\u66ff\u6362\u3002\u5df2\u7ecf\u6ca1\u6709\u4e86\u539f\u6709\u523b\u677f\u7684\u6837\u5b50\uff0c\u610f\u56fe\u975e\u5e38\u660e\u663e\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"// Lambda expression as function object (replaces anonymous class)\nCollections.sort(words,(s1, s2) -> Integer.compare(s1.length(), s2.length()));\n")),(0,r.kt)("p",null,"Note that the types of the lambda (",(0,r.kt)("inlineCode",{parentName:"p"},"Comparator<String>"),"), of its parameters (s1 and s2, both String), and of its return value (int) are not present in the code. The compiler deduces these types from context, using a process known as type inference. In some cases, the compiler won\u2019t be able to determine the types, and you\u2019ll have to specify them. The rules for type inference are complex: they take up an entire chapter in the JLS ","[JLS, 18]",". Few programmers understand these rules in detail, but that\u2019s OK. ",(0,r.kt)("strong",{parentName:"p"},"Omit the types of all lambda parameters unless their presence makes your program clearer.")," If the compiler generates an error telling you it can\u2019t infer the type of a lambda parameter, then specify it. Sometimes you may have to cast the return value or the entire lambda expression, but this is rare."),(0,r.kt)("p",null,"\u6ce8\u610f\uff0clambda \u8868\u8fbe\u5f0f\uff08",(0,r.kt)("inlineCode",{parentName:"p"},"Comparator<String>"),"\uff09\u3001\u5b83\u7684\u53c2\u6570\uff08s1 \u548c s2\uff0c\u90fd\u662f\u5b57\u7b26\u4e32\uff09\u53ca\u5176\u8fd4\u56de\u503c\uff08int\uff09\u7684\u7c7b\u578b\u5728\u4ee3\u7801\u4e2d\u4e0d\u5b58\u5728\u3002\u7f16\u8bd1\u5668\u4f7f\u7528\u79f0\u4e3a\u7c7b\u578b\u63a8\u65ad\u7684\u8fc7\u7a0b\u4ece\u4e0a\u4e0b\u6587\u4e2d\u63a8\u65ad\u8fd9\u4e9b\u7c7b\u578b\u3002\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u7f16\u8bd1\u5668\u65e0\u6cd5\u786e\u5b9a\u7c7b\u578b\uff0c\u4f60\u5fc5\u987b\u663e\u5f0f\u6307\u5b9a\u5b83\u4eec\u3002\u7c7b\u578b\u63a8\u65ad\u7684\u89c4\u5219\u5f88\u590d\u6742\uff1a\u5b83\u4eec\u5728 JLS \u4e2d\u5360\u4e86\u6574\u6574\u4e00\u7ae0 ","[JLS, 18]","\u3002\u5f88\u5c11\u6709\u7a0b\u5e8f\u5458\u80fd\u8be6\u7ec6\u7406\u89e3\u8fd9\u4e9b\u89c4\u5219\uff0c\u4f46\u8fd9\u6ca1\u6709\u5173\u7cfb\u3002",(0,r.kt)("strong",{parentName:"p"},"\u7701\u7565\u6240\u6709 lambda \u8868\u8fbe\u5f0f\u53c2\u6570\u7684\u7c7b\u578b\uff0c\u9664\u975e\u5b83\u4eec\u7684\u5b58\u5728\u4f7f\u4f60\u7684\u7a0b\u5e8f\u66f4\u6e05\u6670\u3002")," \u5982\u679c\u7f16\u8bd1\u5668\u751f\u6210\u4e00\u4e2a\u9519\u8bef\uff0c\u544a\u8bc9\u4f60\u5b83\u4e0d\u80fd\u63a8\u65ad lambda \u8868\u8fbe\u5f0f\u53c2\u6570\u7684\u7c7b\u578b\uff0c\u90a3\u4e48\u5c31\u663e\u5f0f\u6307\u5b9a\u5b83\u3002\u6709\u65f6\u4f60\u53ef\u80fd\u5fc5\u987b\u5f3a\u5236\u8f6c\u6362\u8fd4\u56de\u503c\u6216\u6574\u4e2a lambda \u8868\u8fbe\u5f0f\uff0c\u4f46\u8fd9\u79cd\u60c5\u51b5\u5f88\u5c11\u89c1\u3002"),(0,r.kt)("p",null,"One caveat should be added concerning type inference. Item 26 tells you not to use raw types, Item 29 tells you to favor generic types, and Item 30 tells you to favor generic methods. This advice is doubly important when you\u2019re using lambdas, because the compiler obtains most of the type information that allows it to perform type inference from generics. If you don\u2019t provide this information, the compiler will be unable to do type inference, and you\u2019ll have to specify types manually in your lambdas, which will greatly increase their verbosity. By way of example, the code snippet above won\u2019t compile if the variable words is declared to be of the raw type List instead of the parameterized type ",(0,r.kt)("inlineCode",{parentName:"p"},"List<String>"),"."),(0,r.kt)("p",null,"\u5173\u4e8e\u7c7b\u578b\u63a8\u65ad\uff0c\u6709\u4e9b\u8b66\u544a\u5e94\u8be5\u88ab\u63d0\u53ca\u3002",(0,r.kt)("a",{parentName:"p",href:"./Chapter-5-Item-26-Do-not-use-raw-types"},"Item-26")," \u544a\u8bc9\u4f60\u4e0d\u8981\u4f7f\u7528\u539f\u59cb\u7c7b\u578b\uff0c",(0,r.kt)("a",{parentName:"p",href:"./Chapter-5-Item-29-Favor-generic-types"},"Item-29")," \u544a\u8bc9\u4f60\u8981\u4f18\u5148\u4f7f\u7528\u6cdb\u578b\uff0c",(0,r.kt)("a",{parentName:"p",href:"./Chapter-5-Item-30-Favor-generic-methods"},"Item-30")," \u544a\u8bc9\u4f60\u8981\u4f18\u5148\u4f7f\u7528\u6cdb\u578b\u65b9\u6cd5\u3002\u5728\u4f7f\u7528 lambda \u8868\u8fbe\u5f0f\u65f6\uff0c\u8fd9\u4e9b\u5efa\u8bae\u5c24\u5176\u91cd\u8981\uff0c\u56e0\u4e3a\u7f16\u8bd1\u5668\u83b7\u5f97\u4e86\u5141\u8bb8\u5b83\u4ece\u6cdb\u578b\u4e2d\u6267\u884c\u7c7b\u578b\u63a8\u65ad\u7684\u5927\u90e8\u5206\u7c7b\u578b\u4fe1\u606f\u3002\u5982\u679c\u4e0d\u63d0\u4f9b\u6b64\u4fe1\u606f\uff0c\u7f16\u8bd1\u5668\u5c06\u65e0\u6cd5\u8fdb\u884c\u7c7b\u578b\u63a8\u65ad\uff0c\u5e76\u4e14\u5fc5\u987b\u5728 lambda \u8868\u8fbe\u5f0f\u4e2d\u624b\u52a8\u6307\u5b9a\u7c7b\u578b\uff0c\u8fd9\u5c06\u5927\u5927\u589e\u52a0\u5b83\u4eec\u7684\u5197\u957f\u3002\u4e3e\u4f8b\u6765\u8bf4\uff0c\u5982\u679c\u53d8\u91cf\u58f0\u660e\u4e3a\u539f\u59cb\u7c7b\u578b List \u800c\u4e0d\u662f\u53c2\u6570\u5316\u7c7b\u578b ",(0,r.kt)("inlineCode",{parentName:"p"},"List<String>"),"\uff0c\u90a3\u4e48\u4e0a\u9762\u7684\u4ee3\u7801\u7247\u6bb5\u5c06\u65e0\u6cd5\u7f16\u8bd1\u3002"),(0,r.kt)("p",null,"Incidentally, the comparator in the snippet can be made even more succinct if a comparator construction method is used in place of a lambda (Items 14. 43):"),(0,r.kt)("p",null,"\u987a\u4fbf\u8bf4\u4e00\u4e0b\uff0c\u5982\u679c\u4f7f\u7528 comparator \u6784\u9020\u65b9\u6cd5\u4ee3\u66ff lambda \u8868\u8fbe\u5f0f\uff08",(0,r.kt)("a",{parentName:"p",href:"./Chapter-3-Item-14-Consider-implementing-Comparable"},"Item-14"),"\uff09\uff0c\u90a3\u4e48\u4ee3\u7801\u7247\u6bb5\u53ef\u4ee5\u53d8\u5f97\u66f4\u52a0\u7b80\u6d01\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Collections.sort(words, comparingInt(String::length));\n")),(0,r.kt)("p",null,"In fact, the snippet can be made still shorter by taking advantage of the sort method that was added to the List interface in Java 8:"),(0,r.kt)("p",null,"\u4e8b\u5b9e\u4e0a\uff0c\u901a\u8fc7 Java 8 \u4e2d\u6dfb\u52a0\u5230 List \u63a5\u53e3\u7684 sort \u65b9\u6cd5\uff0c\u53ef\u4ee5\u4f7f\u4ee3\u7801\u7247\u6bb5\u53d8\u5f97\u66f4\u77ed\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"words.sort(comparingInt(String::length));\n")),(0,r.kt)("p",null,"The addition of lambdas to the language makes it practical to use function objects where it would not previously have made sense. For example, consider the Operation enum type in Item 34. Because each enum required different behavior for its apply method, we used constant-specific class bodies and overrode the apply method in each enum constant. To refresh your memory, here is the code:"),(0,r.kt)("p",null,"\u5728\u8bed\u8a00\u4e2d\u6dfb\u52a0 lambda \u8868\u8fbe\u5f0f\u4f7f\u5f97\u5728\u4ee5\u524d\u6ca1\u6709\u610f\u4e49\u7684\u5730\u65b9\u4f7f\u7528\u51fd\u6570\u5bf9\u8c61\u53d8\u5f97\u5b9e\u9645\u3002\u4f8b\u5982\uff0c\u8003\u8651 ",(0,r.kt)("a",{parentName:"p",href:"./Chapter-6-Item-34-Use-enums-instead-of-int-constants"},"Item-34")," \u4e2d\u7684\u64cd\u4f5c\u679a\u4e3e\u7c7b\u578b\u3002\u56e0\u4e3a\u6bcf\u4e2a\u679a\u4e3e\u7684 apply \u65b9\u6cd5\u9700\u8981\u4e0d\u540c\u7684\u884c\u4e3a\uff0c\u6240\u4ee5\u6211\u4eec\u4f7f\u7528\u7279\u5b9a\u4e8e\u5e38\u91cf\u7684\u7c7b\u4f53\u5e76\u8986\u76d6\u6bcf\u4e2a\u679a\u4e3e\u5e38\u91cf\u4e2d\u7684 apply \u65b9\u6cd5\u3002\u4e3a\u4e86\u5524\u9192\u4f60\u7684\u8bb0\u5fc6\uff0c\u4ee5\u4e0b\u662f\u4ee3\u7801\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'// Enum type with constant-specific class bodies & data (Item 34)\npublic enum Operation {\n    PLUS("+") {\n        public double apply(double x, double y) { return x + y; }\n    },\n    MINUS("-") {\n        public double apply(double x, double y) { return x - y; }\n    },\n    TIMES("*") {\n        public double apply(double x, double y) { return x * y; }\n    },\n    DIVIDE("/") {\n        public double apply(double x, double y) { return x / y; }\n    };\n\n    private final String symbol;\n\n    Operation(String symbol) { this.symbol = symbol; }\n\n    @Override\n    public String toString() { return symbol; }\n\n    public abstract double apply(double x, double y);\n}\n')),(0,r.kt)("p",null,"Item 34 says that enum instance fields are preferable to constant-specific class bodies. Lambdas make it easy to implement constant-specific behavior using the former instead of the latter. Merely pass a lambda implementing each enum constant\u2019s behavior to its constructor. The constructor stores the lambda in an instance field, and the apply method forwards invocations to the lambda. The resulting code is simpler and clearer than the original version:"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"./Chapter-6-Item-34-Use-enums-instead-of-int-constants"},"Item-34")," \u6307\u51fa\uff0c\u679a\u4e3e\u5b9e\u4f8b\u5b57\u6bb5\u6bd4\u7279\u5b9a\u4e8e\u5e38\u91cf\u7684\u7c7b\u4f53\u66f4\u53ef\u53d6\u3002Lambda \u8868\u8fbe\u5f0f\u4f7f\u5f97\u4f7f\u7528\u524d\u8005\u53d6\u4ee3\u540e\u8005\u6765\u5b9e\u73b0\u7279\u5b9a\u4e8e\u5e38\u91cf\u7684\u884c\u4e3a\u53d8\u5f97\u5bb9\u6613\u3002\u53ea\u9700\u5c06\u5b9e\u73b0\u6bcf\u4e2a\u679a\u4e3e\u5e38\u91cf\u7684\u884c\u4e3a\u7684 lambda \u8868\u8fbe\u5f0f\u4f20\u9012\u7ed9\u5b83\u7684\u6784\u9020\u51fd\u6570\u3002\u6784\u9020\u51fd\u6570\u5c06 lambda \u8868\u8fbe\u5f0f\u5b58\u50a8\u5728\u5b9e\u4f8b\u5b57\u6bb5\u4e2d\uff0capply \u65b9\u6cd5\u5c06\u8c03\u7528\u8f6c\u53d1\u7ed9 lambda \u8868\u8fbe\u5f0f\u3002\u751f\u6210\u7684\u4ee3\u7801\u6bd4\u539f\u59cb\u7248\u672c\u66f4\u7b80\u5355\u3001\u66f4\u6e05\u6670\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'// Enum with function object fields & constant-specific behavior\npublic enum Operation {\n    PLUS ("+", (x, y) -> x + y),\n    MINUS ("-", (x, y) -> x - y),\n    TIMES ("*", (x, y) -> x * y),\n    DIVIDE("/", (x, y) -> x / y);\n\n    private final String symbol;\n\n    private final DoubleBinaryOperator op;\n\n    Operation(String symbol, DoubleBinaryOperator op) {\n        this.symbol = symbol;\n        this.op = op;\n    }\n\n    @Override public String toString() { return symbol; }\n\n    public double apply(double x, double y) {\n        return op.applyAsDouble(x, y);\n    }\n}\n')),(0,r.kt)("p",null,"Note that we\u2019re using the DoubleBinaryOperator interface for the lambdas that represent the enum constant\u2019s behavior. This is one of the many predefined functional interfaces in java.util.function (Item 44). It represents a function that takes two double arguments and returns a double result."),(0,r.kt)("p",null,"\u6ce8\u610f\uff0c\u6211\u4eec\u5bf9\u8868\u793a\u679a\u4e3e\u5e38\u91cf\u884c\u4e3a\u7684 lambda \u8868\u8fbe\u5f0f\u4f7f\u7528\u4e86 DoubleBinaryOperator \u63a5\u53e3\u3002\u8fd9\u662f ",(0,r.kt)("inlineCode",{parentName:"p"},"java.util.function")," \uff08",(0,r.kt)("a",{parentName:"p",href:"./Chapter-7-Item-44-Favor-the-use-of-standard-functional-interfaces"},"Item-44"),"\uff09\u4e2d\u8bb8\u591a\u9884\u5b9a\u4e49\u7684\u51fd\u6570\u5f0f\u63a5\u53e3\u4e4b\u4e00\u3002\u5b83\u8868\u793a\u4e00\u4e2a\u51fd\u6570\uff0c\u8be5\u51fd\u6570\u63a5\u6536\u4e24\u4e2a double \u7c7b\u578b\u53c2\u6570\uff0c\u5e76\u4e14\u8fd4\u56de\u503c\u4e5f\u4e3a double \u7c7b\u578b\u3002"),(0,r.kt)("p",null,"Looking at the lambda-based Operation enum, you might think constantspecific method bodies have outlived their usefulness, but this is not the case. Unlike methods and classes, ",(0,r.kt)("strong",{parentName:"p"},"lambdas lack names and documentation; if a computation isn\u2019t self-explanatory, or exceeds a few lines, don\u2019t put it in a lambda.")," One line is ideal for a lambda, and three lines is a reasonable maximum. If you violate this rule, it can cause serious harm to the readability of your programs. If a lambda is long or difficult to read, either find a way to simplify it or refactor your program to eliminate it. Also, the arguments passed to enum constructors are evaluated in a static context. Thus, lambdas in enum constructors can\u2019t access instance members of the enum. Constant-specific class bodies are still the way to go if an enum type has constant-specific behavior that is difficult to understand, that can\u2019t be implemented in a few lines, or that requires access to instance fields or methods."),(0,r.kt)("p",null,"\u67e5\u770b\u57fa\u4e8e lambda \u8868\u8fbe\u5f0f\u7684\u64cd\u4f5c enum\uff0c\u4f60\u53ef\u80fd\u4f1a\u8ba4\u4e3a\u7279\u5b9a\u4e8e\u5e38\u91cf\u7684\u65b9\u6cd5\u4f53\u5df2\u7ecf\u8fc7\u65f6\u4e86\uff0c\u4f46\u4e8b\u5b9e\u5e76\u975e\u5982\u6b64\u3002\u4e0e\u65b9\u6cd5\u548c\u7c7b\u4e0d\u540c\uff0c",(0,r.kt)("strong",{parentName:"p"},"lambda \u8868\u8fbe\u5f0f\u7f3a\u5c11\u540d\u79f0\u548c\u6587\u6863\uff1b\u5982\u679c\u4e00\u4e2a\u7b97\u6cd5\u5e76\u975e\u4e0d\u8a00\u81ea\u660e\uff0c\u6216\u8005\u6709\u5f88\u591a\u884c\u4ee3\u7801\uff0c\u4e0d\u8981\u628a\u5b83\u653e\u5728 lambda \u8868\u8fbe\u5f0f\u4e2d\u3002")," \u4e00\u884c\u662f\u7406\u60f3\u7684\uff0c\u4e09\u884c\u662f\u5408\u7406\u7684\u6700\u5927\u503c\u3002\u5982\u679c\u4f60\u8fdd\u53cd\u4e86\u8fd9\u4e00\u89c4\u5219\uff0c\u5c31\u4f1a\u4e25\u91cd\u635f\u5bb3\u7a0b\u5e8f\u7684\u53ef\u8bfb\u6027\u3002\u5982\u679c lambda \u8868\u8fbe\u5f0f\u5f88\u957f\u6216\u8005\u5f88\u96be\u8bfb\uff0c\u8981\u4e48\u627e\u5230\u4e00\u79cd\u65b9\u6cd5\u6765\u7b80\u5316\u5b83\uff0c\u8981\u4e48\u91cd\u6784\u4f60\u7684\u7a0b\u5e8f\u3002\u6b64\u5916\uff0c\u4f20\u9012\u7ed9 enum \u6784\u9020\u51fd\u6570\u7684\u53c2\u6570\u5728\u9759\u6001\u4e0a\u4e0b\u6587\u4e2d\u8ba1\u7b97\u3002\u56e0\u6b64\uff0cenum \u6784\u9020\u51fd\u6570\u4e2d\u7684 lambda \u8868\u8fbe\u5f0f\u4e0d\u80fd\u8bbf\u95ee\u679a\u4e3e\u7684\u5b9e\u4f8b\u6210\u5458\u3002\u5982\u679c\u679a\u4e3e\u7c7b\u578b\u5177\u6709\u96be\u4ee5\u7406\u89e3\u7684\u7279\u5b9a\u4e8e\u5e38\u91cf\u7684\u884c\u4e3a\uff0c\u65e0\u6cd5\u5728\u51e0\u884c\u4ee3\u7801\u4e2d\u5b9e\u73b0\uff0c\u6216\u8005\u9700\u8981\u8bbf\u95ee\u5b9e\u4f8b\u5b57\u6bb5\u6216\u65b9\u6cd5\uff0c\u5219\u4ecd\u7136\u9700\u8981\u7279\u5b9a\u4e8e\u5e38\u91cf\u7684\u7c7b\u3002"),(0,r.kt)("p",null,"Likewise, you might think that anonymous classes are obsolete in the era of lambdas. This is closer to the truth, but there are a few things you can do with anonymous classes that you can\u2019t do with lambdas. Lambdas are limited to functional interfaces. If you want to create an instance of an abstract class, you can do it with an anonymous class, but not a lambda. Similarly, you can use anonymous classes to create instances of interfaces with multiple abstract methods. Finally, a lambda cannot obtain a reference to itself. In a lambda, the this keyword refers to the enclosing instance, which is typically what you want. In an anonymous class, the this keyword refers to the anonymous class instance. If you need access to the function object from within its body, then you must use an anonymous class."),(0,r.kt)("p",null,"\u540c\u6837\uff0c\u4f60\u53ef\u80fd\u8ba4\u4e3a\u533f\u540d\u7c7b\u5728 lambda \u8868\u8fbe\u5f0f\u65f6\u4ee3\u5df2\u7ecf\u8fc7\u65f6\u4e86\u3002\u8fd9\u66f4\u63a5\u8fd1\u4e8b\u5b9e\uff0c\u4f46\u662f\u6709\u4e00\u4e9b\u533f\u540d\u7c7b\u53ef\u4ee5\u505a\u7684\u4e8b\u60c5\u662f lambda \u8868\u8fbe\u5f0f\u4e0d\u80fd\u505a\u7684\u3002Lambda \u8868\u8fbe\u5f0f\u4ec5\u9650\u4e8e\u51fd\u6570\u5f0f\u63a5\u53e3\u3002\u5982\u679c\u60f3\u521b\u5efa\u62bd\u8c61\u7c7b\u7684\u5b9e\u4f8b\uff0c\u53ef\u4ee5\u4f7f\u7528\u533f\u540d\u7c7b\uff0c\u4f46\u4e0d\u80fd\u4f7f\u7528 lambda \u8868\u8fbe\u5f0f\u3002\u7c7b\u4f3c\u5730\uff0c\u4f60\u53ef\u4ee5\u4f7f\u7528\u533f\u540d\u7c7b\u6765\u521b\u5efa\u5177\u6709\u591a\u4e2a\u62bd\u8c61\u65b9\u6cd5\u7684\u63a5\u53e3\u5b9e\u4f8b\u3002\u6700\u540e\uff0clambda \u8868\u8fbe\u5f0f\u65e0\u6cd5\u83b7\u5f97\u5bf9\u81ea\u8eab\u7684\u5f15\u7528\u3002\u5728 lambda \u8868\u8fbe\u5f0f\u4e2d\uff0cthis \u5173\u952e\u5b57\u6307\u7684\u662f\u5c01\u95ed\u5b9e\u4f8b\uff0c\u8fd9\u901a\u5e38\u662f\u4f60\u60f3\u8981\u7684\u3002\u5728\u533f\u540d\u7c7b\u4e2d\uff0cthis \u5173\u952e\u5b57\u5f15\u7528\u533f\u540d\u7c7b\u5b9e\u4f8b\u3002\u5982\u679c\u4f60\u9700\u8981\u4ece\u51fd\u6570\u5bf9\u8c61\u7684\u5185\u90e8\u8bbf\u95ee\u5b83\uff0c\u90a3\u4e48\u4f60\u5fc5\u987b\u4f7f\u7528\u4e00\u4e2a\u533f\u540d\u7c7b\u3002"),(0,r.kt)("p",null,"Lambdas share with anonymous classes the property that you can\u2019t reliably serialize and deserialize them across implementations. Therefore, ",(0,r.kt)("strong",{parentName:"p"},"you should rarely, if ever, serialize a lambda")," (or an anonymous class instance). If you have a function object that you want to make serializable, such as a Comparator, use an instance of a private static nested class (Item 24)."),(0,r.kt)("p",null,"Lambda \u8868\u8fbe\u5f0f\u4e0e\u533f\u540d\u7c7b\u5171\u4eab\u65e0\u6cd5\u901a\u8fc7\u5b9e\u73b0\u53ef\u9760\u5730\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316\u5b83\u4eec\u7684\u5c5e\u6027\u3002\u56e0\u6b64\uff0c",(0,r.kt)("strong",{parentName:"p"},"\u5f88\u5c11\uff08\u5982\u679c\u6709\u7684\u8bdd\uff09\u5e8f\u5217\u5316 lambda"),"\uff08\u6216\u533f\u540d\u7c7b\u5b9e\u4f8b\uff09\u3002\u5982\u679c\u4f60\u6709\u4e00\u4e2a\u60f3\u8981\u5e8f\u5217\u5316\u7684\u51fd\u6570\u5bf9\u8c61\uff0c\u6bd4\u5982\u6bd4\u8f83\u5668\uff0c\u90a3\u4e48\u4f7f\u7528\u79c1\u6709\u9759\u6001\u5d4c\u5957\u7c7b\u7684\u5b9e\u4f8b\uff08",(0,r.kt)("a",{parentName:"p",href:"./Chapter-4-Item-24-Favor-static-member-classes-over-nonstatic"},"Item-24"),"\uff09\u3002"),(0,r.kt)("p",null,"In summary, as of Java 8, lambdas are by far the best way to represent small function objects. ",(0,r.kt)("strong",{parentName:"p"},"Don\u2019t use anonymous classes for function objects unless you have to create instances of types that aren\u2019t functional interfaces.")," Also, remember that lambdas make it so easy to represent small function objects that it opens the door to functional programming techniques that were not previously practical in Java."),(0,r.kt)("p",null,"\u603b\u4e4b\uff0c\u5728 Java 8 \u4e2d\uff0clambda \u8868\u8fbe\u5f0f\u662f\u8fc4\u4eca\u4e3a\u6b62\u8868\u793a\u5c0f\u51fd\u6570\u5bf9\u8c61\u7684\u6700\u4f73\u65b9\u5f0f\u3002",(0,r.kt)("strong",{parentName:"p"},"\u4e0d\u8981\u5bf9\u51fd\u6570\u5bf9\u8c61\u4f7f\u7528\u533f\u540d\u7c7b\uff0c\u9664\u975e\u4f60\u5fc5\u987b\u521b\u5efa\u975e\u51fd\u6570\u5f0f\u63a5\u53e3\u7c7b\u578b\u7684\u5b9e\u4f8b\u3002")," \u53e6\u5916\uff0c\u8bf7\u8bb0\u4f4f\uff0clambda \u8868\u8fbe\u5f0f\u4f7f\u8868\u793a\u5c0f\u51fd\u6570\u5bf9\u8c61\u53d8\u5f97\u975e\u5e38\u5bb9\u6613\uff0c\u4ece\u800c\u4e3a Java \u4ee5\u524d\u4e0d\u5b9e\u7528\u7684\u51fd\u6570\u5f0f\u7f16\u7a0b\u6280\u672f\u6253\u5f00\u4e86\u5927\u95e8\u3002"),(0,r.kt)("hr",null),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"./Chapter-7-Introduction"},"Back to contents of the chapter\uff08\u8fd4\u56de\u7ae0\u8282\u76ee\u5f55\uff09"))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Next Item\uff08\u4e0b\u4e00\u6761\u76ee\uff09\uff1a",(0,r.kt)("a",{parentName:"strong",href:"./Chapter-7-Item-43-Prefer-method-references-to-lambdas"},"Item 43: Prefer method references to lambdas\uff08\u65b9\u6cd5\u5f15\u7528\u4f18\u4e8e \u03bb \u8868\u8fbe\u5f0f\uff09")))))}p.isMDXComponent=!0}}]);