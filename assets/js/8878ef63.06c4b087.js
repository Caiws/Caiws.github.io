"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[3683],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=c(n),m=o,u=p["".concat(l,".").concat(m)]||p[m]||h[m]||i;return n?a.createElement(u,r(r({ref:t},d),{},{components:n})):a.createElement(u,r({ref:t},d))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,r[1]=s;for(var c=2;c<i;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},6480:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var a=n(7462),o=(n(7294),n(3905));const i={},r=void 0,s={unversionedId:"Books/EffectiveJava3/Chapter-8/Chapter-8-Item-52-Use-overloading-judiciously",id:"Books/EffectiveJava3/Chapter-8/Chapter-8-Item-52-Use-overloading-judiciously",title:"Chapter-8-Item-52-Use-overloading-judiciously",description:"Chapter 8. Methods\uff08\u65b9\u6cd5\uff09",source:"@site/docs/Books/EffectiveJava3/Chapter-8/Chapter-8-Item-52-Use-overloading-judiciously.md",sourceDirName:"Books/EffectiveJava3/Chapter-8",slug:"/Books/EffectiveJava3/Chapter-8/Chapter-8-Item-52-Use-overloading-judiciously",permalink:"/docs/Books/EffectiveJava3/Chapter-8/Chapter-8-Item-52-Use-overloading-judiciously",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Books/EffectiveJava3/Chapter-8/Chapter-8-Item-52-Use-overloading-judiciously.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Chapter-8-Item-51-Design-method-signatures-carefully",permalink:"/docs/Books/EffectiveJava3/Chapter-8/Chapter-8-Item-51-Design-method-signatures-carefully"},next:{title:"Chapter-8-Item-53-Use-varargs-judiciously",permalink:"/docs/Books/EffectiveJava3/Chapter-8/Chapter-8-Item-53-Use-varargs-judiciously"}},l={},c=[{value:"Chapter 8. Methods\uff08\u65b9\u6cd5\uff09",id:"chapter-8-methods\u65b9\u6cd5",level:2},{value:"Item 52: Use overloading judiciously\uff08\u660e\u667a\u5730\u4f7f\u7528\u91cd\u8f7d\uff09",id:"item-52-use-overloading-judiciously\u660e\u667a\u5730\u4f7f\u7528\u91cd\u8f7d",level:3}],d={toc:c};function h(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"chapter-8-methods\u65b9\u6cd5"},"Chapter 8. Methods\uff08\u65b9\u6cd5\uff09"),(0,o.kt)("h3",{id:"item-52-use-overloading-judiciously\u660e\u667a\u5730\u4f7f\u7528\u91cd\u8f7d"},"Item 52: Use overloading judiciously\uff08\u660e\u667a\u5730\u4f7f\u7528\u91cd\u8f7d\uff09"),(0,o.kt)("p",null,"The following program is a well-intentioned attempt to classify collections according to whether they are sets, lists, or some other kind of collection:"),(0,o.kt)("p",null,"\u4e0b\u9762\u7684\u7a0b\u5e8f\u662f\u4e00\u4e2a\u5584\u610f\u7684\u5c1d\u8bd5\uff0c\u6839\u636e\u4e00\u4e2a Collection \u662f Set\u3001List \u8fd8\u662f\u5176\u4ed6\u7684\u96c6\u5408\u7c7b\u578b\u6765\u8fdb\u884c\u5206\u7c7b\uff1a"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'// Broken! - What does this program print?\npublic class CollectionClassifier {\n    public static String classify(Set<?> s) {\n        return "Set";\n    }\n\n    public static String classify(List<?> lst) {\n        return "List";\n    }\n\n    public static String classify(Collection<?> c) {\n        return "Unknown Collection";\n    }\n\n    public static void main(String[] args) {\n        Collection<?>[] collections = {\n            new HashSet<String>(),new ArrayList<BigInteger>(),new HashMap<String, String>().values()\n        };\n        for (Collection<?> c : collections)\n            System.out.println(classify(c));\n    }\n}\n')),(0,o.kt)("p",null,"You might expect this program to print Set, followed by List and Unknown Collection, but it doesn\u2019t. It prints Unknown Collection three times. Why does this happen? Because the classify method is overloaded, and ",(0,o.kt)("strong",{parentName:"p"},"the choice of which overloading to invoke is made at compile time.")," For all three iterations of the loop, the compile-time type of the parameter is the same: ",(0,o.kt)("inlineCode",{parentName:"p"},"Collection<?>"),". The runtime type is different in each iteration, but this does not affect the choice of overloading. Because the compile-time type of the parameter is ",(0,o.kt)("inlineCode",{parentName:"p"},"Collection<?>"),", the only applicable overloading is the third one, ",(0,o.kt)("inlineCode",{parentName:"p"},"classify(Collection<?>)"),", and this overloading is invoked in each iteration of the loop."),(0,o.kt)("p",null,"\u4f60\u53ef\u80fd\u671f\u671b\u8fd9\u4e2a\u7a0b\u5e8f\u6253\u5370 Set\uff0c\u7136\u540e\u662f List \u548c Unknown Collection\uff0c\u4f46\u662f\u5b83\u6ca1\u6709\u8fd9\u6837\u505a\u3002\u5b83\u6253\u5370 Unknown Collection \u4e09\u6b21\u3002\u4e3a\u4ec0\u4e48\u4f1a\u8fd9\u6837\uff1f\u56e0\u4e3a classify \u65b9\u6cd5\u88ab\u91cd\u8f7d\uff0c\u5e76\u4e14 ",(0,o.kt)("strong",{parentName:"p"},"\u5728\u7f16\u8bd1\u65f6\u5c31\u51b3\u5b9a\u4e86\u8981\u8c03\u7528\u54ea\u4e2a\u91cd\u8f7d\u3002")," \u5bf9\u4e8e\u5faa\u73af\u7684\u4e09\u4e2a\u8fed\u4ee3\u8fc7\u7a0b\uff0c\u53c2\u6570\u7684\u7f16\u8bd1\u65f6\u7c7b\u578b\u662f\u76f8\u540c\u7684\uff1a",(0,o.kt)("inlineCode",{parentName:"p"},"Collection<?>"),"\u3002\u8fd0\u884c\u65f6\u7c7b\u578b\u5728\u6bcf\u4e2a\u8fed\u4ee3\u4e2d\u662f\u4e0d\u540c\u7684\uff0c\u4f46\u8fd9\u5e76\u4e0d\u5f71\u54cd\u91cd\u8f7d\u7684\u9009\u62e9\u3002\u56e0\u4e3a\u53c2\u6570\u7684\u7f16\u8bd1\u65f6\u7c7b\u578b\u662f ",(0,o.kt)("inlineCode",{parentName:"p"},"Collection<?>"),"\uff0c\u552f\u4e00\u9002\u7528\u7684\u91cd\u8f7d\u662f\u7b2c\u4e09\u4e2a\uff0c",(0,o.kt)("inlineCode",{parentName:"p"},"classify(Collection<?>)"),"\uff0c\u8fd9\u4e2a\u91cd\u8f7d\u5728\u5faa\u73af\u7684\u6bcf\u4e2a\u8fed\u4ee3\u8fc7\u7a0b\u4e2d\u90fd\u4f1a\u8c03\u7528\u3002"),(0,o.kt)("p",null,"The behavior of this program is counterintuitive because ",(0,o.kt)("strong",{parentName:"p"},"selection among overloaded methods is static, while selection among overridden methods is dynamic.")," The correct version of an overridden method is chosen at runtime, based on the runtime type of the object on which the method is invoked. As a reminder, a method is overridden when a subclass contains a method declaration with the same signature as a method declaration in an ancestor. If an instance method is overridden in a subclass and this method is invoked on an instance of the subclass, the subclass\u2019s overriding method executes, regardless of the compile-time type of the subclass instance. To make this concrete, consider the following program:"),(0,o.kt)("p",null,"\u8fd9\u4e2a\u7a0b\u5e8f\u7684\u884c\u4e3a\u8fdd\u53cd\u5e38\u89c4\uff0c\u56e0\u4e3a ",(0,o.kt)("strong",{parentName:"p"},"\u91cd\u8f7d\u65b9\u6cd5\u7684\u9009\u62e9\u662f\u9759\u6001\u7684\uff0c\u800c\u8986\u76d6\u6cd5\u7684\u9009\u62e9\u662f\u52a8\u6001\u7684\u3002")," \u5728\u8fd0\u884c\u65f6\u6839\u636e\u8c03\u7528\u65b9\u6cd5\u7684\u5bf9\u8c61\u7684\u8fd0\u884c\u65f6\u7c7b\u578b\u9009\u62e9\u8986\u76d6\u65b9\u6cd5\u7684\u6b63\u786e\u7248\u672c\u3002\u63d0\u9192\u4e00\u4e0b\uff0c\u5f53\u5b50\u7c7b\u5305\u542b\u4e0e\u7956\u5148\u4e2d\u7684\u65b9\u6cd5\u58f0\u660e\u5177\u6709\u76f8\u540c\u7b7e\u540d\u7684\u65b9\u6cd5\u58f0\u660e\u65f6\uff0c\u65b9\u6cd5\u5c06\u88ab\u8986\u76d6\u3002\u5982\u679c\u5728\u5b50\u7c7b\u4e2d\u8986\u76d6\u5b9e\u4f8b\u65b9\u6cd5\uff0c\u5e76\u4e14\u5728\u5b50\u7c7b\u7684\u5b9e\u4f8b\u4e0a\u8c03\u7528\u6b64\u65b9\u6cd5\uff0c\u5219\u6267\u884c\u5b50\u7c7b\u7684\u8986\u76d6\u65b9\u6cd5\uff0c\u800c\u4e0d\u7ba1\u5b50\u7c7b\u5b9e\u4f8b\u7684\u7f16\u8bd1\u65f6\u7c7b\u578b\u5982\u4f55\u3002\u4e3a\u4e86\u66f4\u5177\u4f53\u7684\u8bf4\u660e\uff0c\u8003\u8651\u4ee5\u4e0b\u7a0b\u5e8f:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'class Wine {\n    String name() { return "wine"; }\n}\n\nclass SparklingWine extends Wine {\n    @Override\n    String name() { return "sparkling wine"; }\n}\n\nclass Champagne extends SparklingWine {\n    @Override\n    String name() { return "champagne"; }\n}\n\npublic class Overriding {\n    public static void main(String[] args) {\n        List<Wine> wineList = List.of(new Wine(), new SparklingWine(), new Champagne());\n    for (Wine wine : wineList)\n        System.out.println(wine.name());\n    }\n}\n')),(0,o.kt)("p",null,"The name method is declared in class Wine and overridden in subclasses SparklingWine and Champagne. As you would expect, this program prints out wine, sparkling wine, and champagne, even though the compiletime type of the instance is Wine in each iteration of the loop. The compile-time type of an object has no effect on which method is executed when an overridden method is invoked; the \u201cmost specific\u201d overriding method always gets executed. Compare this to overloading, where the runtime type of an object has no effect on which overloading is executed; the selection is made at compile time, based entirely on the compile-time types of the parameters."),(0,o.kt)("p",null,"name \u65b9\u6cd5\u5728 Wine \u7c7b\u4e2d\u58f0\u660e\uff0c\u5e76\u5728 SparklingWine \u548c Champagne \u5b50\u7c7b\u4e2d\u91cd\u5199\u3002\u6b63\u5982\u4f60\u6240\u671f\u671b\u7684\uff0c\u8fd9\u4e2a\u7a0b\u5e8f\u6253\u5370\u51fa wine\u3001sparkling \u548c champagne\uff0c\u5373\u4f7f\u5b9e\u4f8b\u7684\u7f16\u8bd1\u65f6\u7c7b\u578b\u662f\u5faa\u73af\u6bcf\u6b21\u8fed\u4ee3\u4e2d\u7684 wine\u3002\u5bf9\u8c61\u7684\u7f16\u8bd1\u65f6\u7c7b\u578b\u5bf9\u8c03\u7528\u8986\u76d6\u65b9\u6cd5\u65f6\u6267\u884c\u7684\u65b9\u6cd5\u6ca1\u6709\u5f71\u54cd\uff1b\u300c\u6700\u7279\u5b9a\u7684\u300d\u8986\u76d6\u65b9\u6cd5\u603b\u662f\u88ab\u6267\u884c\u3002\u5c06\u6b64\u4e0e\u91cd\u8f7d\u8fdb\u884c\u6bd4\u8f83\uff0c\u5728\u91cd\u8f7d\u4e2d\uff0c\u5bf9\u8c61\u7684\u8fd0\u884c\u65f6\u7c7b\u578b\u5bf9\u6267\u884c\u91cd\u8f7d\u6ca1\u6709\u5f71\u54cd\uff1b\u9009\u62e9\u662f\u5728\u7f16\u8bd1\u65f6\u8fdb\u884c\u7684\uff0c\u5b8c\u5168\u57fa\u4e8e\u53c2\u6570\u7684\u7f16\u8bd1\u65f6\u7c7b\u578b\u3002"),(0,o.kt)("p",null,"In the CollectionClassifier example, the intent of the program was to discern the type of the parameter by dispatching automatically to the appropriate method overloading based on the runtime type of the parameter, just as the name method did in the Wine example. Method overloading simply does not provide this functionality. Assuming a static method is required, the best way to fix the CollectionClassifier program is to replace all three overloadings of classify with a single method that does explicit instanceof tests:"),(0,o.kt)("p",null,"\u5728 CollectionClassifier \u793a\u4f8b\u4e2d\uff0c\u7a0b\u5e8f\u7684\u76ee\u7684\u662f\u901a\u8fc7\u6839\u636e\u53c2\u6570\u7684\u8fd0\u884c\u65f6\u7c7b\u578b\u81ea\u52a8\u5206\u6d3e\u5230\u9002\u5f53\u7684\u65b9\u6cd5\u91cd\u8f7d\u6765\u8bc6\u522b\u53c2\u6570\u7684\u7c7b\u578b\uff0c\u5c31\u50cf Wine \u793a\u4f8b\u4e2d\u7684 name \u65b9\u6cd5\u6240\u505a\u7684\u90a3\u6837\u3002\u65b9\u6cd5\u91cd\u8f7d\u4e0d\u63d0\u4f9b\u6b64\u529f\u80fd\u3002\u5047\u8bbe\u9700\u8981\u4e00\u4e2a\u9759\u6001\u65b9\u6cd5\uff0c\u4fee\u590d CollectionClassifier \u7a0b\u5e8f\u7684\u6700\u4f73\u65b9\u6cd5\u662f\u7528\u4e00\u4e2a\u6267\u884c\u663e\u5f0f instanceof \u6d4b\u8bd5\u7684\u65b9\u6cd5\u66ff\u6362 classification \u7684\u6240\u6709\u4e09\u4e2a\u91cd\u8f7d\uff1a"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'public static String classify(Collection<?> c) {\n    return c instanceof Set ? "Set" :c instanceof List ? "List" : "Unknown Collection";\n}\n')),(0,o.kt)("p",null,"Because overriding is the norm and overloading is the exception, overriding sets people\u2019s expectations for the behavior of method invocation. As demonstrated by the CollectionClassifier example, overloading can easily confound these expectations. It is bad practice to write code whose behavior is likely to confuse programmers. This is especially true for APIs. If the typical user of an API does not know which of several method overloadings will get invoked for a given set of parameters, use of the API is likely to result in errors. These errors will likely manifest themselves as erratic behavior at runtime, and many programmers will have a hard time diagnosing them. Therefore you should ",(0,o.kt)("strong",{parentName:"p"},"avoid confusing uses of overloading.")),(0,o.kt)("p",null,"\u56e0\u4e3a\u8986\u76d6\u662f\u89c4\u8303\uff0c\u800c\u91cd\u8f7d\u662f\u4f8b\u5916\uff0c\u6240\u4ee5\u8986\u76d6\u6ee1\u8db3\u4e86\u4eba\u4eec\u5bf9\u65b9\u6cd5\u8c03\u7528\u884c\u4e3a\u7684\u671f\u671b\u3002\u6b63\u5982 CollectionClassifier \u793a\u4f8b\u6240\u793a\uff0c\u91cd\u8f7d\u5f88\u5bb9\u6613\u6df7\u6dc6\u8fd9\u4e9b\u671f\u671b\u3002\u7f16\u5199\u53ef\u80fd\u4f7f\u7a0b\u5e8f\u5458\u611f\u5230\u56f0\u60d1\u7684\u4ee3\u7801\u662f\u4e0d\u597d\u7684\u884c\u4e3a\u3002\u5bf9\u4e8e API \u5c24\u5176\u5982\u6b64\u3002\u5982\u679c API \u7684\u7528\u6237\u4e0d\u77e5\u9053\u4e00\u7ec4\u53c2\u6570\u5e94\u8be5\u8c03\u7528\u54ea\u4e00\u79cd\u65b9\u6cd5\u91cd\u8f7d\uff0c\u90a3\u4e48\u4f7f\u7528 API \u65f6\u5f88\u53ef\u80fd\u4f1a\u5bfc\u81f4\u9519\u8bef\u3002\u8fd9\u4e9b\u9519\u8bef\u5f88\u53ef\u80fd\u5728\u8fd0\u884c\u65f6\u8868\u73b0\u4e3a\u4e0d\u7a33\u5b9a\u7684\u884c\u4e3a\uff0c\u8bb8\u591a\u7a0b\u5e8f\u5458\u5c06\u5f88\u96be\u8bca\u65ad\u5b83\u4eec\u3002\u56e0\u6b64\uff0c",(0,o.kt)("strong",{parentName:"p"},"\u5e94\u8be5\u907f\u514d\u6df7\u6dc6\u91cd\u8f7d\u7684\u7528\u6cd5\u3002")),(0,o.kt)("p",null,"Exactly what constitutes a confusing use of overloading is open to some debate. ",(0,o.kt)("strong",{parentName:"p"},"A safe, conservative policy is never to export two overloadings with the same number of parameters.")," If a method uses varargs, a conservative policy is not to overload it at all, except as described in Item 53. If you adhere to these restrictions, programmers will never be in doubt as to which overloading applies to any set of actual parameters. These restrictions are not terribly onerous because ",(0,o.kt)("strong",{parentName:"p"},"you can always give methods different names instead of overloading them.")),(0,o.kt)("p",null,"\u7a76\u7adf\u662f\u4ec0\u4e48\u6784\u6210\u4e86\u6df7\u6dc6\u91cd\u8f7d\u7684\u7528\u6cd5\u8fd8\u6709\u5f85\u5546\u69b7\u3002",(0,o.kt)("strong",{parentName:"p"},"\u5b89\u5168\u3001\u4fdd\u5b88\u7684\u7b56\u7565\u662f\u6c38\u8fdc\u4e0d\u5bfc\u51fa\u5177\u6709\u76f8\u540c\u6570\u91cf\u53c2\u6570\u7684\u4e24\u4e2a\u91cd\u8f7d\u3002")," \u5982\u679c\u4e00\u4e2a\u65b9\u6cd5\u4f7f\u7528\u4e86\u53ef\u53d8\u53c2\u6570\uff0c\u4fdd\u5b88\u7b56\u7565\u662f\u6839\u672c\u4e0d\u91cd\u8f7d\u5b83\uff0c\u9664\u975e\u5982 ",(0,o.kt)("a",{parentName:"p",href:"./Chapter-8-Item-53-Use-varargs-judiciously"},"Item-53")," \u6240\u8ff0\u3002\u5982\u679c\u9075\u5b88\u8fd9\u4e9b\u9650\u5236\uff0c\u7a0b\u5e8f\u5458\u5c31\u4e0d\u4f1a\u6000\u7591\u4e00\u7ec4\u53c2\u6570\u5e94\u8be5\u8c03\u7528\u54ea\u4e00\u79cd\u65b9\u6cd5\u91cd\u8f7d\u3002\u8fd9\u4e9b\u9650\u5236\u5e76\u4e0d\u5341\u5206\u7e41\u7410\uff0c\u56e0\u4e3a ",(0,o.kt)("strong",{parentName:"p"},"\u4f60\u603b\u662f\u53ef\u4ee5\u4e3a\u65b9\u6cd5\u63d0\u4f9b\u4e0d\u540c\u7684\u540d\u79f0\uff0c\u800c\u4e0d\u662f\u91cd\u8f7d\u5b83\u4eec\u3002")),(0,o.kt)("p",null,"For example, consider the ObjectOutputStream class. It has a variant of its write method for every primitive type and for several reference types. Rather than overloading the write method, these variants all have different names, such as writeBoolean(boolean), writeInt(int), and writeLong(long). An added benefit of this naming pattern, when compared to overloading, is that it is possible to provide read methods with corresponding names, for example, readBoolean(), readInt(), and readLong(). The ObjectInputStream class does, in fact, provide such read methods."),(0,o.kt)("p",null,"\u4f8b\u5982\uff0c\u8003\u8651 ObjectOutputStream \u7c7b\u3002\u5bf9\u4e8e\u6bcf\u4e2a\u57fa\u672c\u7c7b\u578b\u548c\u51e0\u79cd\u5f15\u7528\u7c7b\u578b\uff0c\u5176 write \u65b9\u6cd5\u90fd\u6709\u53d8\u4f53\u3002\u8fd9\u4e9b\u53d8\u4f53\u90fd\u6709\u4e0d\u540c\u7684\u540d\u79f0\uff0c\u800c\u4e0d\u662f\u91cd\u8f7d write \u65b9\u6cd5\uff0c\u4f8b\u5982 ",(0,o.kt)("inlineCode",{parentName:"p"},"writeBoolean(boolean)"),"\u3001",(0,o.kt)("inlineCode",{parentName:"p"},"writeInt(int)")," \u548c ",(0,o.kt)("inlineCode",{parentName:"p"},"writeLong(long)"),"\u3002\u4e0e\u91cd\u8f7d\u76f8\u6bd4\uff0c\u8fd9\u79cd\u547d\u540d\u6a21\u5f0f\u7684\u53e6\u4e00\u4e2a\u597d\u5904\u662f\uff0c\u53ef\u4ee5\u4e3a read \u65b9\u6cd5\u63d0\u4f9b\u76f8\u5e94\u7684\u540d\u79f0\uff0c\u4f8b\u5982 ",(0,o.kt)("inlineCode",{parentName:"p"},"readBoolean()"),"\u3001",(0,o.kt)("inlineCode",{parentName:"p"},"readInt()")," \u548c ",(0,o.kt)("inlineCode",{parentName:"p"},"readLong()"),"\u3002ObjectInputStream \u7c7b\u5b9e\u9645\u4e0a\u4e5f\u63d0\u4f9b\u4e86\u8fd9\u6837\u7684\u8bfb\u65b9\u6cd5\u3002"),(0,o.kt)("p",null,"For constructors, you don\u2019t have the option of using different names: multiple constructors for a class are always overloaded. You do, in many cases, have the option of exporting static factories instead of constructors (Item 1). Also, with constructors you don\u2019t have to worry about interactions between overloading and overriding, because constructors can\u2019t be overridden. You will probably have occasion to export multiple constructors with the same number of parameters, so it pays to know how to do it safely."),(0,o.kt)("p",null,"\u5bf9\u4e8e\u6784\u9020\u51fd\u6570\uff0c\u4f60\u6ca1\u6709\u4f7f\u7528\u4e0d\u540c\u540d\u79f0\u7684\u673a\u4f1a\uff1a\u4e00\u4e2a\u7c7b\u7684\u591a\u4e2a\u6784\u9020\u51fd\u6570\u53ea\u80fd\u91cd\u8f7d\u3002\u5728\u5f88\u591a\u60c5\u51b5\u4e0b\uff0c\u4f60\u53ef\u4ee5\u9009\u62e9\u5bfc\u51fa\u9759\u6001\u5de5\u5382\u800c\u4e0d\u662f\u6784\u9020\u51fd\u6570\uff08",(0,o.kt)("a",{parentName:"p",href:"./Chapter-2-Item-1-Consider-static-factory-methods-instead-of-constructors"},"Item-1"),"\uff09\u3002\u4f60\u53ef\u80fd\u4f1a\u6709\u673a\u4f1a\u5bfc\u51fa\u5177\u6709\u76f8\u540c\u6570\u91cf\u53c2\u6570\u7684\u591a\u4e2a\u6784\u9020\u51fd\u6570\uff0c\u56e0\u6b64\u77e5\u9053\u5982\u4f55\u5b89\u5168\u5730\u6267\u884c\u662f\u6709\u5fc5\u8981\u7684\u3002"),(0,o.kt)("p",null,"Exporting multiple overloadings with the same number of parameters is unlikely to confuse programmers if it is always clear which overloading will apply to any given set of actual parameters. This is the case when at least one corresponding formal parameter in each pair of overloadings has a \u201cradically different\u201d type in the two overloadings. Two types are radically different if it is clearly impossible to cast any non-null expression to both types. Under these circumstances, which overloading applies to a given set of actual parameters is fully determined by the runtime types of the parameters and cannot be affected by their compile-time types, so a major source of confusion goes away. For example, ArrayList has one constructor that takes an int and a second constructor that takes a Collection. It is hard to imagine any confusion over which of these two constructors will be invoked under any circumstances."),(0,o.kt)("p",null,"\u5982\u679c\u603b\u662f\u6e05\u695a\u4e00\u7ec4\u53c2\u6570\u5e94\u8be5\u8c03\u7528\u54ea\u4e00\u79cd\u65b9\u6cd5\u91cd\u8f7d\uff0c\u90a3\u4e48\u7528\u76f8\u540c\u6570\u91cf\u7684\u53c2\u6570\u5bfc\u51fa\u591a\u4e2a\u91cd\u8f7d\u4e0d\u592a\u53ef\u80fd\u8ba9\u7a0b\u5e8f\u5458\u611f\u5230\u56f0\u60d1\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u6bcf\u5bf9\u91cd\u8f7d\u4e2d\u81f3\u5c11\u6709\u4e00\u4e2a\u5bf9\u5e94\u7684\u5f62\u5f0f\u53c2\u6570\u5728\u8fd9\u4e24\u4e2a\u91cd\u8f7d\u4e2d\u5177\u6709\u300c\u5b8c\u5168\u4e0d\u540c\u7684\u300d\u7c7b\u578b\u3002\u5982\u679c\u4e0d\u53ef\u80fd\u5c06\u4efb\u4f55\u975e\u7a7a\u8868\u8fbe\u5f0f\u5f3a\u5236\u8f6c\u6362\u4e3a\u8fd9\u4e24\u79cd\u7c7b\u578b\uff0c\u90a3\u4e48\u8fd9\u4e24\u79cd\u7c7b\u578b\u662f\u5b8c\u5168\u4e0d\u540c\u7684\u3002\u5728\u8fd9\u4e9b\u60c5\u51b5\u4e0b\uff0c\u5e94\u7528\u4e8e\u7ed9\u5b9a\u5b9e\u9645\u53c2\u6570\u96c6\u7684\u91cd\u8f7d\u5b8c\u5168\u7531\u53c2\u6570\u7684\u8fd0\u884c\u65f6\u7c7b\u578b\u51b3\u5b9a\uff0c\u4e14\u4e0d\u53d7\u5176\u7f16\u8bd1\u65f6\u7c7b\u578b\u7684\u5f71\u54cd\uff0c\u56e0\u6b64\u6d88\u9664\u4e86\u4e00\u4e2a\u4e3b\u8981\u7684\u6df7\u6dc6\u6e90\u3002\u4f8b\u5982\uff0cArrayList \u6709\u4e00\u4e2a\u63a5\u53d7 int \u7684\u6784\u9020\u51fd\u6570\u548c\u7b2c\u4e8c\u4e2a\u63a5\u53d7 Collection \u7684\u6784\u9020\u51fd\u6570\u3002\u5f88\u96be\u60f3\u8c61\u5728\u4ec0\u4e48\u60c5\u51b5\u4e0b\u4f1a\u4e0d\u77e5\u9053\u8fd9\u4e24\u4e2a\u6784\u9020\u51fd\u6570\u4e2d\u54ea\u4e2a\u4f1a\u88ab\u8c03\u7528\u3002"),(0,o.kt)("p",null,"Prior to Java 5, all primitive types were radically different from all reference types, but this is not true in the presence of autoboxing, and it has caused real trouble. Consider the following program:"),(0,o.kt)("p",null,"\u5728 Java 5 \u4e4b\u524d\uff0c\u6240\u6709\u539f\u59cb\u7c7b\u578b\u90fd\u4e0e\u6240\u6709\u5f15\u7528\u7c7b\u578b\u5b8c\u5168\u4e0d\u540c\uff0c\u4f46\u5728\u81ea\u52a8\u88c5\u7bb1\u65f6\u5e76\u975e\u5982\u6b64\uff0c\u8fd9\u9020\u6210\u4e86\u771f\u6b63\u7684\u9ebb\u70e6\u3002\u8003\u8651\u4ee5\u4e0b\u65b9\u6848\uff1a"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'public class SetList {\npublic static void main(String[] args) {\n    Set<Integer> set = new TreeSet<>();\n    List<Integer> list = new ArrayList<>();\n    for (int i = -3; i < 3; i++) {\n        set.add(i);\n        list.add(i);\n    }\n    for (int i = 0; i < 3; i++) {\n        set.remove(i);\n        list.remove(i);\n    }\n    System.out.println(set +""+list);\n    }\n}\n')),(0,o.kt)("p",null,"First, the program adds the integers from \u22123 to 2, inclusive, to a sorted set and a list. Then, it makes three identical calls to remove on the set and the list. If you\u2019re like most people, you\u2019d expect the program to remove the non-negative values (0, 1, and 2) from the set and the list and to print ","[-3, -2, -1][-3, -2, -1]",". In fact, the program removes the non-negative values from the set and the odd values from the list and prints ","[-3, -2, -1][-2, 0, 2]",". It is an understatement to call this behavior confusing."),(0,o.kt)("p",null,"\u9996\u5148\uff0c\u7a0b\u5e8f\u5c06\u4ece -3 \u5230 2 \u7684\u6574\u6570\uff08\u5305\u62ec\uff09\u6dfb\u52a0\u5230\u5df2\u6392\u5e8f\u7684 Set \u548c List \u4e2d\u3002\u7136\u540e\uff0c\u5b83\u6267\u884c\u4e09\u4e2a\u76f8\u540c\u7684\u8c03\u7528\u6765\u5220\u9664\u96c6\u5408\u548c\u5217\u8868\u3002\u5982\u679c\u4f60\u548c\u5927\u591a\u6570\u4eba\u4e00\u6837\uff0c\u4f60\u5e0c\u671b\u7a0b\u5e8f\u4ece\u96c6\u5408\u548c\u5217\u8868\u4e2d\u5220\u9664\u975e\u8d1f\u503c\uff080\u30011 \u548c 2\uff09\uff0c\u5e76\u6253\u5370 ",(0,o.kt)("inlineCode",{parentName:"p"},"[-3,2,1][-3,2,1]"),"\u3002\u5b9e\u9645\u4e0a\uff0c\u7a0b\u5e8f\u4ece Set \u4e2d\u5220\u9664\u975e\u8d1f\u503c\uff0c\u4ece List \u4e2d\u5220\u9664\u5947\u6570\u503c\uff0c\u5e76\u8f93\u51fa ",(0,o.kt)("inlineCode",{parentName:"p"},"[-3,2,1][-2,0,2]"),"\u3002\u628a\u8fd9\u79cd\u884c\u4e3a\u79f0\u4e3a\u6df7\u4e71\uff0c\u53ea\u662f\u4e00\u79cd\u4fdd\u5b88\u7684\u8bf4\u6cd5\u3002"),(0,o.kt)("p",null,"Here\u2019s what\u2019s happening: The call to set.remove(i) selects the overloading remove(E), where E is the element type of the set (Integer), and autoboxes i from int to Integer. This is the behavior you\u2019d expect, so the program ends up removing the positive values from the set. The call to list.remove(i), on the other hand, selects the overloading remove(int i), which removes the element at the specified position in the list. If you start with the list ","[-3, -2, -1, 0, 1, 2]"," and remove the zeroth element, then the first, and then the second, you\u2019re left with ","[-2, 0, 2]",", and the mystery is solved. To fix the problem, cast list.remove\u2019s argument to Integer, forcing the correct overloading to be selected. Alternatively, you could invoke Integer.valueOf on i and pass the result to list.remove. Either way, the program prints ","[-3, -2, -1][-3, -2, -1]",", as expected:"),(0,o.kt)("p",null,"\u5b9e\u9645\u60c5\u51b5\u5982\u4e0b\uff1a\u8c03\u7528 ",(0,o.kt)("inlineCode",{parentName:"p"},"set.remove(i)")," \u9009\u62e9\u91cd\u8f7d ",(0,o.kt)("inlineCode",{parentName:"p"},"remove(E)"),"\uff0c\u5176\u4e2d E \u662f set \uff08Integer\uff09\u7684\u5143\u7d20\u7c7b\u578b\uff0c\u800c\u5c06\u4ece int \u81ea\u52a8\u88c5\u7bb1\u5230 Integer \u4e2d\u3002\u8fd9\u662f\u4f60\u671f\u671b\u7684\u884c\u4e3a\uff0c\u56e0\u6b64\u7a0b\u5e8f\u6700\u7ec8\u4f1a\u4ece Set \u4e2d\u5220\u9664\u6b63\u503c\u3002\u53e6\u4e00\u65b9\u9762\uff0c\u5bf9 ",(0,o.kt)("inlineCode",{parentName:"p"},"list.remove(i)")," \u7684\u8c03\u7528\u9009\u62e9\u91cd\u8f7d ",(0,o.kt)("inlineCode",{parentName:"p"},"remove(int i)"),"\uff0c\u5b83\u5c06\u5220\u9664 List \u4e2d\u6307\u5b9a\u4f4d\u7f6e\u7684\u5143\u7d20\u3002\u5982\u679c\u4ece List ",(0,o.kt)("inlineCode",{parentName:"p"},"[-3\uff0c-2\uff0c-1,0,1,2]")," \u5f00\u59cb\uff0c\u79fb\u9664\u7b2c 0 \u4e2a\u5143\u7d20\uff0c\u7136\u540e\u662f\u7b2c 1 \u4e2a\uff0c\u7136\u540e\u662f\u7b2c 2 \u4e2a\uff0c\u5c31\u53ea\u5269\u4e0b ",(0,o.kt)("inlineCode",{parentName:"p"},"[-2,0,2]"),"\uff0c\u8c1c\u5e95\u5c31\u89e3\u5f00\u4e86\u3002\u82e5\u8981\u4fee\u590d\u6b64\u95ee\u9898\uff0c\u8981\u5c06 ",(0,o.kt)("inlineCode",{parentName:"p"},"list.remove")," \u7684\u53c2\u6570\u8f6c\u6362\u6210 Integer\uff0c\u5f3a\u5236\u9009\u62e9\u6b63\u786e\u7684\u91cd\u8f7d\u3002\u6216\u8005\uff0c\u4f60\u53ef\u4ee5\u8c03\u7528 ",(0,o.kt)("inlineCode",{parentName:"p"},"Integer.valuef()"),"\uff0c\u7136\u540e\u5c06\u7ed3\u679c\u4f20\u9012\u7ed9 ",(0,o.kt)("inlineCode",{parentName:"p"},"list.remove"),"\u3002\u65e0\u8bba\u54ea\u79cd\u65b9\u5f0f\uff0c\u7a0b\u5e8f\u90fd\u4f1a\u6309\u9884\u671f\u6253\u5370 ",(0,o.kt)("inlineCode",{parentName:"p"},"[-3, -2, -1] [-3, -2, -1]"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"for (int i = 0; i < 3; i++) {\n    set.remove(i);\n    list.remove((Integer) i); // or remove(Integer.valueOf(i))\n}\n")),(0,o.kt)("p",null,"The confusing behavior demonstrated by the previous example came about because the ",(0,o.kt)("inlineCode",{parentName:"p"},"List<E>")," interface has two overloadings of the remove method: remove(E) and remove(int). Prior to Java 5 when the List interface was \u201cgenerified,\u201d it had a remove(Object) method in place of remove(E), and the corresponding parameter types, Object and int, were radically different. But in the presence of generics and autoboxing, the two parameter types are no longer radically different. In other words, adding generics and autoboxing to the language damaged the List interface. Luckily, few if any other APIs in the Java libraries were similarly damaged, but this tale makes it clear that autoboxing and generics increased the importance of caution when overloading. The addition of lambdas and method references in Java 8 further increased the potential for confusion in overloading. For example, consider these two snippets:"),(0,o.kt)("p",null,"\u524d\u4e00\u4e2a\u793a\u4f8b\u6240\u6f14\u793a\u7684\u4ee4\u4eba\u56f0\u60d1\u7684\u884c\u4e3a\u662f\u7531\u4e8e ",(0,o.kt)("inlineCode",{parentName:"p"},"List<E>")," \u63a5\u53e3\u5bf9 remove \u65b9\u6cd5\u6709\u4e24\u4e2a\u91cd\u8f7d\uff1a",(0,o.kt)("inlineCode",{parentName:"p"},"remove(E)")," \u548c ",(0,o.kt)("inlineCode",{parentName:"p"},"remove(int)"),"\u3002\u5728 Java 5 \u4e4b\u524d\uff0c\u5f53 List \u63a5\u53e3\u88ab\u300c\u6cdb\u5316\u300d\u65f6\uff0c\u5b83\u6709\u4e00\u4e2a ",(0,o.kt)("inlineCode",{parentName:"p"},"remove(Object)")," \u65b9\u6cd5\u4ee3\u66ff ",(0,o.kt)("inlineCode",{parentName:"p"},"remove(E)"),"\uff0c\u800c\u76f8\u5e94\u7684\u53c2\u6570\u7c7b\u578b Object \u548c int \u5219\u5b8c\u5168\u4e0d\u540c\u3002\u4f46\u662f\uff0c\u5728\u6cdb\u578b\u548c\u81ea\u52a8\u88c5\u7bb1\u7684\u5b58\u5728\u4e0b\uff0c\u8fd9\u4e24\u79cd\u53c2\u6570\u7c7b\u578b\u4e0d\u518d\u5b8c\u5168\u4e0d\u540c\u3002\u6362\u53e5\u8bdd\u8bf4\uff0c\u5728\u8bed\u8a00\u4e2d\u6dfb\u52a0\u6cdb\u578b\u548c\u81ea\u52a8\u88c5\u7bb1\u7834\u574f\u4e86 List \u63a5\u53e3\u3002\u5e78\u8fd0\u7684\u662f\uff0cJava \u5e93\u4e2d\u7684\u5176\u4ed6 API \u51e0\u4e4e\u6ca1\u6709\u53d7\u5230\u7c7b\u4f3c\u7684\u7834\u574f\uff0c\u4f46\u662f\u8fd9\u4e2a\u6545\u4e8b\u6e05\u695a\u5730\u8868\u660e\uff0c\u81ea\u52a8\u88c5\u7bb1\u548c\u6cdb\u578b\u51fa\u73b0\u540e\uff0c\u5728\u91cd\u8f7d\u65f6\u5c31\u5e94\u66f4\u52a0\u8c28\u614e\u3002Java 8 \u4e2d\u6dfb\u52a0\u7684 lambda \u8868\u8fbe\u5f0f\u548c\u65b9\u6cd5\u5f15\u7528\u8fdb\u4e00\u6b65\u589e\u52a0\u4e86\u91cd\u8f7d\u4e2d\u6df7\u6dc6\u7684\u53ef\u80fd\u6027\u3002\u4f8b\u5982\uff0c\u8003\u8651\u4ee5\u4e0b\u4e24\u4e2a\u7247\u6bb5\uff1a"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"new Thread(System.out::println).start();\nExecutorService exec = Executors.newCachedThreadPool();\nexec.submit(System.out::println);\n")),(0,o.kt)("p",null,"While the Thread constructor invocation and the submit method invocation look similar, the former compiles while the latter does not. The arguments are identical (System.out::println), and both the constructor and the method have an overloading that takes a Runnable. What\u2019s going on here? The surprising answer is that the submit method has an overloading that takes a ",(0,o.kt)("inlineCode",{parentName:"p"},"Callable<T>"),", while the Thread constructor does not. You might think that this shouldn\u2019t make any difference because all overloadings of println return void, so the method reference couldn\u2019t possibly be a Callable. This makes perfect sense, but it\u2019s not the way the overload resolution algorithm works. Perhaps equally surprising is that the submit method invocation would be legal if the println method weren\u2019t also overloaded. It is the combination of the overloading of the referenced method (println) and the invoked method (submit) that prevents the overload resolution algorithm from behaving as you\u2019d expect."),(0,o.kt)("p",null,"\u867d\u7136 Thread \u6784\u9020\u51fd\u6570\u8c03\u7528\u548c submit \u65b9\u6cd5\u8c03\u7528\u770b\u8d77\u6765\u5f88\u76f8\u4f3c\uff0c\u4f46\u662f\u524d\u8005\u7f16\u8bd1\u800c\u540e\u8005\u4e0d\u7f16\u8bd1\u3002\u53c2\u6570\u662f\u76f8\u540c\u7684 ",(0,o.kt)("inlineCode",{parentName:"p"},"System.out::println"),"\uff0c\u6784\u9020\u51fd\u6570\u548c\u65b9\u6cd5\u90fd\u6709\u4e00\u4e2a\u91cd\u8f7d\uff0c\u8be5\u91cd\u8f7d\u63a5\u53d7 Runnable\u3002\u8fd9\u662f\u600e\u4e48\u56de\u4e8b\uff1f\u4ee4\u4eba\u60ca\u8bb6\u7684\u7b54\u6848\u662f\uff0csubmit \u65b9\u6cd5\u6709\u4e00\u4e2a\u91cd\u8f7d\uff0c\u5b83\u63a5\u53d7\u4e00\u4e2a ",(0,o.kt)("inlineCode",{parentName:"p"},"Callable<T>"),"\uff0c\u800c\u7ebf\u7a0b\u6784\u9020\u51fd\u6570\u6ca1\u6709\u3002\u4f60\u53ef\u80fd\u8ba4\u4e3a\u8fd9\u4e0d\u4f1a\u6709\u4ec0\u4e48\u533a\u522b\uff0c\u56e0\u4e3a println \u7684\u6240\u6709\u91cd\u8f7d\u90fd\u4f1a\u8fd4\u56de void\uff0c\u6240\u4ee5\u65b9\u6cd5\u5f15\u7528\u4e0d\u53ef\u80fd\u662f Callable\u3002\u8fd9\u5f88\u6709\u9053\u7406\uff0c\u4f46\u91cd\u8f7d\u89e3\u6790\u7b97\u6cd5\u4e0d\u662f\u8fd9\u6837\u5de5\u4f5c\u7684\u3002\u4e5f\u8bb8\u540c\u6837\u4ee4\u4eba\u60ca\u8bb6\u7684\u662f\uff0c\u5982\u679c println \u65b9\u6cd5\u6ca1\u6709\u88ab\u91cd\u8f7d\uff0c\u90a3\u4e48 submit \u65b9\u6cd5\u8c03\u7528\u5c06\u662f\u5408\u6cd5\u7684\u3002\u6b63\u662f\u88ab\u5f15\u7528\u7684\u65b9\u6cd5 println \u548c\u88ab\u8c03\u7528\u7684\u65b9\u6cd5 submit \u7684\u91cd\u8f7d\u76f8\u7ed3\u5408\uff0c\u963b\u6b62\u4e86\u91cd\u8f7d\u89e3\u6790\u7b97\u6cd5\u6309\u7167\u4f60\u6240\u671f\u671b\u7684\u90a3\u6837\u8fd0\u884c\u3002"),(0,o.kt)("p",null,"Technically speaking, the problem is that System.out::println is an inexact method reference ","[JLS, 15.13.1]"," and that \u201ccertain argument expressions that contain implicitly typed lambda expressions or inexact method references are ignored by the applicability tests, because their meaning cannot be determined until a target type is selected ","[JLS, 15.12.2]",".\u201d Don\u2019t worry if you don\u2019t understand this passage; it is aimed at compiler writers. The key point is that overloading methods or constructors with different functional interfaces in the same argument position causes confusion. Therefore, ",(0,o.kt)("strong",{parentName:"p"},"do not overload methods to take different functional interfaces in the same argument position.")," In the parlance of this item, different functional interfaces are not radically different. The Java compiler will warn you about this sort of problematic overload if you pass the command line switch - Xlint:overloads."),(0,o.kt)("p",null,"\u4ece\u6280\u672f\u4e0a\u8bb2\uff0c\u95ee\u9898\u51fa\u5728 System.out::println \u4e0a\uff0c\u5b83\u662f\u4e00\u4e2a\u4e0d\u51c6\u786e\u7684\u65b9\u6cd5\u5f15\u7528 ","[JLS, 15.13.1]","\uff0c\u5e76\u4e14\u300c\u67d0\u4e9b\u5305\u542b\u9690\u5f0f\u7c7b\u578b\u5316 lambda \u8868\u8fbe\u5f0f\u6216\u4e0d\u51c6\u786e\u7684\u65b9\u6cd5\u5f15\u7528\u7684\u53c2\u6570\u8868\u8fbe\u5f0f\u4f1a\u88ab\u9002\u7528\u6027\u6d4b\u8bd5\u5ffd\u7565\uff0c\u56e0\u4e3a\u5b83\u4eec\u7684\u542b\u4e49\u5728\u9009\u62e9\u76ee\u6807\u7c7b\u578b\u4e4b\u524d\u65e0\u6cd5\u786e\u5b9a ","[JLS, 15.12.2]","\u3002\u300d\u5982\u679c\u4f60\u4e0d\u660e\u767d\u8fd9\u6bb5\u8bdd\uff0c\u4e0d\u8981\u62c5\u5fc3\uff1b\u5b83\u7684\u76ee\u6807\u662f\u7f16\u8bd1\u5668\u7f16\u5199\u5668\u3002\u5173\u952e\u662f\u5728\u76f8\u540c\u7684\u53c2\u6570\u4f4d\u7f6e\u4e0a\u91cd\u8f7d\u5177\u6709\u4e0d\u540c\u529f\u80fd\u63a5\u53e3\u7684\u65b9\u6cd5\u6216\u6784\u9020\u51fd\u6570\u4f1a\u5bfc\u81f4\u6df7\u6dc6\u3002\u56e0\u6b64\uff0c",(0,o.kt)("strong",{parentName:"p"},"\u4e0d\u8981\u91cd\u8f7d\u65b9\u6cd5\u6765\u5728\u76f8\u540c\u7684\u53c2\u6570\u4f4d\u7f6e\u4e0a\u4f7f\u7528\u4e0d\u540c\u7684\u51fd\u6570\u5f0f\u63a5\u53e3\u3002")," \u7528\u672c\u9879\u76ee\u7684\u8bdd\u8bf4\uff0c\u4e0d\u540c\u7684\u51fd\u6570\u5f0f\u63a5\u53e3\u5e76\u6ca1\u6709\u6839\u672c\u7684\u4e0d\u540c\u3002\u5982\u679c\u4f60\u901a\u8fc7\u547d\u4ee4\u884c\u5f00\u5173 ",(0,o.kt)("inlineCode",{parentName:"p"},"Xlint:overloads"),", Java \u7f16\u8bd1\u5668\u5c06\u5bf9\u8fd9\u79cd\u6709\u95ee\u9898\u7684\u91cd\u8f7d\u53d1\u51fa\u8b66\u544a\u3002"),(0,o.kt)("p",null,"Array types and class types other than Object are radically different. Also, array types and interface types other than Serializable and Cloneable are radically different. Two distinct classes are said to be unrelated if neither class is a descendant of the other ","[JLS, 5.5]",". For example, String and Throwable are unrelated. It is impossible for any object to be an instance of two unrelated classes, so unrelated classes are radically different, too."),(0,o.kt)("p",null,"\u6570\u7ec4\u7c7b\u578b\u548c Object \u4ee5\u5916\u7684\u7c7b\u7c7b\u578b\u662f\u5b8c\u5168\u4e0d\u540c\u7684\u3002\u6b64\u5916\uff0c\u6570\u7ec4\u7c7b\u578b\u548c Serializable \u548c Cloneable \u4e4b\u5916\u7684\u63a5\u53e3\u7c7b\u578b\u4e5f\u5b8c\u5168\u4e0d\u540c\u3002\u5982\u679c\u4e24\u4e2a\u4e0d\u540c\u7684\u7c7b\u90fd\u4e0d\u662f\u53e6\u4e00\u4e2a\u7c7b\u7684\u540e\u4ee3 ","[JLS, 5.5]","\uff0c\u5219\u79f0\u5b83\u4eec\u662f\u4e0d\u76f8\u5173\u7684\u3002\u4f8b\u5982\uff0cString \u548c Throwable \u662f\u4e0d\u76f8\u5173\u7684\u3002\u4efb\u4f55\u5bf9\u8c61\u90fd\u4e0d\u53ef\u80fd\u662f\u4e24\u4e2a\u4e0d\u76f8\u5173\u7c7b\u7684\u5b9e\u4f8b\uff0c\u6240\u4ee5\u4e0d\u76f8\u5173\u7684\u7c7b\u4e5f\u662f\u5b8c\u5168\u4e0d\u540c\u7684\u3002"),(0,o.kt)("p",null,"There are other pairs of types that can\u2019t be converted in either direction ","[JLS, 5.1.12]",", but once you go beyond the simple cases described above, it becomes very difficult for most programmers to discern which, if any, overloading applies to a set of actual parameters. The rules that determine which overloading is selected are extremely complex and grow more complex with every release. Few programmers understand all of their subtleties."),(0,o.kt)("p",null,"\u8fd8\u6709\u5176\u4ed6\u6210\u5bf9\u7684\u7c7b\u4e0d\u80fd\u5728\u4efb\u4f55\u65b9\u5411\u76f8\u4e92\u8f6c\u6362 ","[JLS, 5.1.12]","\uff0c\u4f46\u662f\u4e00\u65e6\u8d85\u51fa\u4e0a\u9762\u63cf\u8ff0\u7684\u7b80\u5355\u60c5\u51b5\uff0c\u5927\u591a\u6570\u7a0b\u5e8f\u5458\u5c31\u5f88\u96be\u8fa8\u522b\u4e00\u7ec4\u53c2\u6570\u5e94\u8be5\u8c03\u7528\u54ea\u4e00\u79cd\u65b9\u6cd5\u91cd\u8f7d\u3002\u51b3\u5b9a\u9009\u62e9\u54ea\u4e2a\u91cd\u8f7d\u7684\u89c4\u5219\u975e\u5e38\u590d\u6742\uff0c\u5e76\u4e14\u968f\u7740\u6bcf\u4e2a\u7248\u672c\u7684\u53d1\u5e03\u800c\u53d8\u5f97\u8d8a\u6765\u8d8a\u590d\u6742\u3002\u5f88\u5c11\u6709\u7a0b\u5e8f\u5458\u80fd\u7406\u89e3\u5b83\u4eec\u6240\u6709\u7684\u5fae\u5999\u4e4b\u5904\u3002"),(0,o.kt)("p",null,"There may be times when you feel the need to violate the guidelines in this item, especially when evolving existing classes. For example, consider String, which has had a contentEquals(StringBuffer) method since Java 4. In Java 5, CharSequence was added to provide a common interface for StringBuffer, StringBuilder, String, CharBuffer, and other similar types. At the same time that CharSequence was added, String was outfitted with an overloading of the contentEquals method that takes a CharSequence."),(0,o.kt)("p",null,"\u6709\u65f6\u5019\uff0c\u4f60\u53ef\u80fd\u89c9\u5f97\u4f1a\u88ab\u8feb\u8fdd\u53cd\u672c\u6761\u76ee\u4e2d\u7684\u6307\u5bfc\u539f\u5219\uff0c\u7279\u522b\u662f\u5728\u66f4\u65b0\u73b0\u6709\u7c7b\u65f6\u3002\u4f8b\u5982\uff0c\u8003\u8651 String\uff0c\u5b83\u4ece Java 4 \u5f00\u59cb\u5c31\u6709\u4e00\u4e2a ",(0,o.kt)("inlineCode",{parentName:"p"},"contentEquals(StringBuffer)")," \u65b9\u6cd5\u3002\u5728 Java 5 \u4e2d\uff0c\u6dfb\u52a0\u4e86 CharSequence \u6765\u4e3a StringBuffer\u3001StringBuilder\u3001String\u3001CharBuffer \u548c\u5176\u4ed6\u7c7b\u4f3c\u7c7b\u578b\u63d0\u4f9b\u516c\u5171\u63a5\u53e3\u3002\u5728\u6dfb\u52a0 CharSequence \u7684\u540c\u65f6\uff0cString \u8fd8\u914d\u5907\u4e86\u4e00\u4e2a\u91cd\u8f7d\u7684 contentEquals \u65b9\u6cd5\uff0c\u8be5\u65b9\u6cd5\u63a5\u53d7 CharSequence\u3002"),(0,o.kt)("p",null,"While the resulting overloading clearly violates the guidelines in this item, it causes no harm because both overloaded methods do exactly the same thing when they are invoked on the same object reference. The programmer may not know which overloading will be invoked, but it is of no consequence so long as they behave identically. The standard way to ensure this behavior is to have the more specific overloading forward to the more general:"),(0,o.kt)("p",null,"\u867d\u7136\u8fd9\u6837\u7684\u91cd\u8f7d\u660e\u663e\u8fdd\u53cd\u4e86\u6b64\u9879\u4e2d\u7684\u6307\u5bfc\u539f\u5219\uff0c\u4f46\u5b83\u4e0d\u4f1a\u9020\u6210\u4efb\u4f55\u5371\u5bb3\uff0c\u56e0\u4e3a\u5f53\u5728\u540c\u4e00\u4e2a\u5bf9\u8c61\u5f15\u7528\u4e0a\u8c03\u7528\u8fd9\u4e24\u4e2a\u91cd\u8f7d\u65b9\u6cd5\u65f6\uff0c\u5b83\u4eec\u505a\u7684\u662f\u5b8c\u5168\u76f8\u540c\u7684\u4e8b\u60c5\u3002\u7a0b\u5e8f\u5458\u53ef\u80fd\u4e0d\u77e5\u9053\u5c06\u8c03\u7528\u54ea\u4e2a\u91cd\u8f7d\uff0c\u4f46\u53ea\u8981\u5b83\u4eec\u7684\u884c\u4e3a\u76f8\u540c\uff0c\u5c31\u6ca1\u6709\u4ec0\u4e48\u4e0d\u826f\u540e\u679c\u3002\u786e\u4fdd\u8fd9\u79cd\u884c\u4e3a\u7684\u6807\u51c6\u65b9\u6cd5\u662f\u5c06\u66f4\u5177\u4f53\u7684\u91cd\u8f7d\u8f6c\u53d1\u7ed9\u66f4\u4e00\u822c\u7684\u91cd\u8f7d\uff1a"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"// Ensuring that 2 methods have identical behavior by forwarding\npublic boolean contentEquals(StringBuffer sb) {\n    return contentEquals((CharSequence) sb);\n}\n")),(0,o.kt)("p",null,"While the Java libraries largely adhere to the spirit of the advice in this item, there are a number of classes that violate it. For example, String exports two overloaded static factory methods, valueOf(char[]) and valueOf(Object), that do completely different things when passed the same object reference. There is no real justification for this, and it should be regarded as an anomaly with the potential for real confusion."),(0,o.kt)("p",null,"\u867d\u7136 Java \u5e93\u5728\u5f88\u5927\u7a0b\u5ea6\u4e0a\u9075\u5faa\u4e86\u672c\u6761\u76ee\u4e2d\u7684\u4e3b\u65e8\u7cbe\u795e\uff0c\u4f46\u662f\u6709\u4e00\u4e9b\u7c7b\u8fdd\u53cd\u4e86\u5b83\u3002\u4f8b\u5982\uff0cString \u5bfc\u51fa\u4e24\u4e2a\u91cd\u8f7d\u7684\u9759\u6001\u5de5\u5382\u65b9\u6cd5 ",(0,o.kt)("inlineCode",{parentName:"p"},"valueOf(char[])")," \u548c ",(0,o.kt)("inlineCode",{parentName:"p"},"valueOf(Object)"),"\uff0c\u5b83\u4eec\u5728\u4f20\u9012\u76f8\u540c\u7684\u5bf9\u8c61\u5f15\u7528\u65f6\u6267\u884c\u5b8c\u5168\u4e0d\u540c\u7684\u64cd\u4f5c\u3002\u8fd9\u6837\u505a\u6ca1\u6709\u771f\u6b63\u7684\u7406\u7531\uff0c\u5b83\u5e94\u8be5\u88ab\u89c6\u4e3a\u4e00\u79cd\u5f02\u5e38\u884c\u4e3a\uff0c\u6709\u53ef\u80fd\u9020\u6210\u771f\u6b63\u7684\u6df7\u4e71\u3002"),(0,o.kt)("p",null,"To summarize, just because you can overload methods doesn\u2019t mean you should. It is generally best to refrain from overloading methods with multiple signatures that have the same number of parameters. In some cases, especially where constructors are involved, it may be impossible to follow this advice. In these cases, you should at least avoid situations where the same set of parameters can be passed to different overloadings by the addition of casts. If this cannot be avoided, for example, because you are retrofitting an existing class to implement a new interface, you should ensure that all overloadings behave identically when passed the same parameters. If you fail to do this, programmers will be hard pressed to make effective use of the overloaded method or constructor, and they won\u2019t understand why it doesn\u2019t work."),(0,o.kt)("p",null,"\u603b\u800c\u8a00\u4e4b\uff0c\u65b9\u6cd5\u53ef\u4ee5\u91cd\u8f7d\uff0c\u4f46\u5e76\u4e0d\u610f\u5473\u7740\u5c31\u5e94\u8be5\u8fd9\u6837\u505a\u3002\u901a\u5e38\uff0c\u6700\u597d\u907f\u514d\u91cd\u8f7d\u5177\u6709\u76f8\u540c\u6570\u91cf\u53c2\u6570\u7684\u591a\u4e2a\u7b7e\u540d\u7684\u65b9\u6cd5\u3002\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u7279\u522b\u662f\u6d89\u53ca\u6784\u9020\u51fd\u6570\u7684\u60c5\u51b5\u4e0b\uff0c\u53ef\u80fd\u96be\u4ee5\u9075\u5faa\u8fd9\u4e2a\u5efa\u8bae\u3002\u5728\u8fd9\u4e9b\u60c5\u51b5\u4e0b\uff0c\u4f60\u81f3\u5c11\u5e94\u8be5\u907f\u514d\u540c\u4e00\u7ec4\u53c2\u6570\u53ea\u9700\u7ecf\u8fc7\u7c7b\u578b\u8f6c\u6362\u5c31\u53ef\u4ee5\u88ab\u4f20\u9012\u7ed9\u4e0d\u540c\u7684\u91cd\u8f7d\u65b9\u6cd5\u3002\u5982\u679c\u8fd9\u662f\u65e0\u6cd5\u907f\u514d\u7684\uff0c\u4f8b\u5982\uff0c\u56e0\u4e3a\u8981\u5bf9\u73b0\u6709\u7c7b\u8fdb\u884c\u6539\u9020\u4ee5\u5b9e\u73b0\u65b0\u63a5\u53e3\uff0c\u90a3\u4e48\u5e94\u8be5\u786e\u4fdd\u5728\u4f20\u9012\u76f8\u540c\u7684\u53c2\u6570\u65f6\uff0c\u6240\u6709\u91cd\u8f7d\u7684\u884c\u4e3a\u90fd\u662f\u76f8\u540c\u7684\u3002\u5982\u679c\u4f60\u505a\u4e0d\u5230\u8fd9\u4e00\u70b9\uff0c\u7a0b\u5e8f\u5458\u5c06\u5f88\u96be\u6709\u6548\u5730\u4f7f\u7528\u91cd\u8f7d\u65b9\u6cd5\u6216\u6784\u9020\u51fd\u6570\uff0c\u4ed6\u4eec\u5c06\u65e0\u6cd5\u7406\u89e3\u4e3a\u4ec0\u4e48\u5b83\u4e0d\u80fd\u5de5\u4f5c\u3002"),(0,o.kt)("hr",null),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("a",{parentName:"strong",href:"./Chapter-8-Introduction"},"Back to contents of the chapter\uff08\u8fd4\u56de\u7ae0\u8282\u76ee\u5f55\uff09"))),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Previous Item\uff08\u4e0a\u4e00\u6761\u76ee\uff09\uff1a",(0,o.kt)("a",{parentName:"strong",href:"./Chapter-8-Item-51-Design-method-signatures-carefully"},"Item 51: Design method signatures carefully\uff08\u4ed4\u7ec6\u8bbe\u8ba1\u65b9\u6cd5\u7b7e\u540d\uff09"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Next Item\uff08\u4e0b\u4e00\u6761\u76ee\uff09\uff1a",(0,o.kt)("a",{parentName:"strong",href:"./Chapter-8-Item-53-Use-varargs-judiciously"},"Item 53: Use varargs judiciously\uff08\u660e\u667a\u5730\u4f7f\u7528\u53ef\u53d8\u53c2\u6570\uff09")))))}h.isMDXComponent=!0}}]);