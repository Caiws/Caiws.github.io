"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[8201],{3905:(e,i,t)=>{t.d(i,{Zo:()=>d,kt:()=>p});var a=t(7294);function n(e,i,t){return i in e?Object.defineProperty(e,i,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[i]=t,e}function l(e,i){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);i&&(a=a.filter((function(i){return Object.getOwnPropertyDescriptor(e,i).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var i=1;i<arguments.length;i++){var t=null!=arguments[i]?arguments[i]:{};i%2?l(Object(t),!0).forEach((function(i){n(e,i,t[i])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(i){Object.defineProperty(e,i,Object.getOwnPropertyDescriptor(t,i))}))}return e}function r(e,i){if(null==e)return{};var t,a,n=function(e,i){if(null==e)return{};var t,a,n={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],i.indexOf(t)>=0||(n[t]=e[t]);return n}(e,i);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],i.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(n[t]=e[t])}return n}var s=a.createContext({}),c=function(e){var i=a.useContext(s),t=i;return e&&(t="function"==typeof e?e(i):o(o({},i),e)),t},d=function(e){var i=c(e.components);return a.createElement(s.Provider,{value:i},e.children)},h={inlineCode:"code",wrapper:function(e){var i=e.children;return a.createElement(a.Fragment,{},i)}},u=a.forwardRef((function(e,i){var t=e.components,n=e.mdxType,l=e.originalType,s=e.parentName,d=r(e,["components","mdxType","originalType","parentName"]),u=c(t),p=n,f=u["".concat(s,".").concat(p)]||u[p]||h[p]||l;return t?a.createElement(f,o(o({ref:i},d),{},{components:t})):a.createElement(f,o({ref:i},d))}));function p(e,i){var t=arguments,n=i&&i.mdxType;if("string"==typeof e||n){var l=t.length,o=new Array(l);o[0]=u;var r={};for(var s in i)hasOwnProperty.call(i,s)&&(r[s]=i[s]);r.originalType=e,r.mdxType="string"==typeof e?e:n,o[1]=r;for(var c=2;c<l;c++)o[c]=t[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},8820:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>s,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>c});var a=t(7462),n=(t(7294),t(3905));const l={},o=void 0,r={unversionedId:"Books/EffectiveJava3/Chapter-11/Chapter-11-Item-83-Use-lazy-initialization-judiciously",id:"Books/EffectiveJava3/Chapter-11/Chapter-11-Item-83-Use-lazy-initialization-judiciously",title:"Chapter-11-Item-83-Use-lazy-initialization-judiciously",description:"Chapter 11. Concurrency\uff08\u5e76\u53d1\uff09",source:"@site/docs/Books/EffectiveJava3/Chapter-11/Chapter-11-Item-83-Use-lazy-initialization-judiciously.md",sourceDirName:"Books/EffectiveJava3/Chapter-11",slug:"/Books/EffectiveJava3/Chapter-11/Chapter-11-Item-83-Use-lazy-initialization-judiciously",permalink:"/docs/Books/EffectiveJava3/Chapter-11/Chapter-11-Item-83-Use-lazy-initialization-judiciously",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Books/EffectiveJava3/Chapter-11/Chapter-11-Item-83-Use-lazy-initialization-judiciously.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Chapter-11-Item-82-Document-thread-safety",permalink:"/docs/Books/EffectiveJava3/Chapter-11/Chapter-11-Item-82-Document-thread-safety"},next:{title:"Chapter-11-Item-84-Don\u2019t-depend-on-the-thread-scheduler",permalink:"/docs/Books/EffectiveJava3/Chapter-11/Chapter-11-Item-84-Don\u2019t-depend-on-the-thread-scheduler"}},s={},c=[{value:"Chapter 11. Concurrency\uff08\u5e76\u53d1\uff09",id:"chapter-11-concurrency\u5e76\u53d1",level:2},{value:"Item 83: Use lazy initialization judiciously\uff08\u660e\u667a\u5730\u4f7f\u7528\u5ef6\u8fdf\u521d\u59cb\u5316\uff09",id:"item-83-use-lazy-initialization-judiciously\u660e\u667a\u5730\u4f7f\u7528\u5ef6\u8fdf\u521d\u59cb\u5316",level:3}],d={toc:c};function h(e){let{components:i,...t}=e;return(0,n.kt)("wrapper",(0,a.Z)({},d,t,{components:i,mdxType:"MDXLayout"}),(0,n.kt)("h2",{id:"chapter-11-concurrency\u5e76\u53d1"},"Chapter 11. Concurrency\uff08\u5e76\u53d1\uff09"),(0,n.kt)("h3",{id:"item-83-use-lazy-initialization-judiciously\u660e\u667a\u5730\u4f7f\u7528\u5ef6\u8fdf\u521d\u59cb\u5316"},"Item 83: Use lazy initialization judiciously\uff08\u660e\u667a\u5730\u4f7f\u7528\u5ef6\u8fdf\u521d\u59cb\u5316\uff09"),(0,n.kt)("p",null,"Lazy initialization is the act of delaying the initialization of a field until its value is needed. If the value is never needed, the field is never initialized. This technique is applicable to both static and instance fields. While lazy initialization is primarily an optimization, it can also be used to break harmful circularities in class and instance initialization ","[Bloch05, Puzzle 51]","."),(0,n.kt)("p",null,"\u5ef6\u8fdf\u521d\u59cb\u5316\u662f\u5ef6\u8fdf\u5b57\u6bb5\u7684\u521d\u59cb\u5316\uff0c\u76f4\u5230\u9700\u8981\u5b83\u7684\u503c\u3002\u5982\u679c\u4e0d\u9700\u8981\u8be5\u503c\uff0c\u5219\u4e0d\u4f1a\u521d\u59cb\u5316\u5b57\u6bb5\u3002\u8fd9\u79cd\u6280\u672f\u65e2\u9002\u7528\u4e8e\u9759\u6001\u5b57\u6bb5\uff0c\u4e5f\u9002\u7528\u4e8e\u5b9e\u4f8b\u5b57\u6bb5\u3002\u867d\u7136\u5ef6\u8fdf\u521d\u59cb\u5316\u4e3b\u8981\u4f5c\u4e3a\u4e00\u79cd\u4f18\u5316\u624b\u6bb5\uff0c\u5b83\u8fd8\u53ef\u7528\u4e8e\u907f\u514d\u7c7b\u4e0e\u5b9e\u4f8b\u521d\u59cb\u5316\u4e2d\u5faa\u73af\u4f9d\u8d56\u7684\u95ee\u9898 ","[Bloch05, Puzzle 51]","\u3002"),(0,n.kt)("p",null,"As is the case for most optimizations, the best advice for lazy initialization is \u201cdon\u2019t do it unless you need to\u201d (Item 67). Lazy initialization is a double-edged sword. It decreases the cost of initializing a class or creating an instance, at the expense of increasing the cost of accessing the lazily initialized field. Depending on what fraction of these fields eventually require initialization, how expensive it is to initialize them, and how often each one is accessed once initialized, lazy initialization can (like many \u201coptimizations\u201d) actually harm performance."),(0,n.kt)("p",null,"\u4e0e\u5927\u591a\u6570\u4f18\u5316\u4e00\u6837\uff0c\u5ef6\u8fdf\u521d\u59cb\u5316\u7684\u6700\u4f73\u5efa\u8bae\u662f\u300c\u9664\u975e\u9700\u8981\uff0c\u5426\u5219\u4e0d\u8981\u8fd9\u6837\u505a\u300d(\u7b2c67\u9879)\u3002\u5ef6\u8fdf\u521d\u59cb\u5316\u662f\u4e00\u628a\u53cc\u5203\u5251\u3002\u5b83\u964d\u4f4e\u4e86\u521d\u59cb\u5316\u7c7b\u6216\u521b\u5efa\u5b9e\u4f8b\u7684\u6210\u672c\uff0c\u4ee3\u4ef7\u662f\u589e\u52a0\u4e86\u8bbf\u95ee\u5ef6\u8fdf\u521d\u59cb\u5316\u5b57\u6bb5\u7684\u6210\u672c\u3002\u6839\u636e\u8fd9\u4e9b\u5b57\u6bb5\u4e2d\u6700\u7ec8\u9700\u8981\u521d\u59cb\u5316\u7684\u90e8\u5206\u3001\u521d\u59cb\u5316\u5b83\u4eec\u7684\u5f00\u9500\u4ee5\u53ca\u521d\u59cb\u5316\u540e\u8bbf\u95ee\u6bcf\u4e2a\u5b57\u6bb5\u7684\u9891\u7387\uff0c\u5ef6\u8fdf\u521d\u59cb\u5316\u5b9e\u9645\u4e0a\u4f1a\u635f\u5bb3\u6027\u80fd\uff08\u5c31\u50cf\u8bb8\u591a\u300c\u4f18\u5316\u300d\u4e00\u6837\uff09\u3002"),(0,n.kt)("p",null,"That said, lazy initialization has its uses. If a field is accessed only on a fraction of the instances of a class and it is costly to initialize the field, then lazy initialization may be worthwhile. The only way to know for sure is to measure the performance of the class with and without lazy initialization."),(0,n.kt)("p",null,"\u5ef6\u8fdf\u521d\u59cb\u5316\u4e5f\u6709\u5b83\u7684\u7528\u9014\u3002\u5982\u679c\u4e00\u4e2a\u5b57\u6bb5\u53ea\u5728\u7c7b\u7684\u4e00\u5c0f\u90e8\u5206\u5b9e\u4f8b\u4e0a\u8bbf\u95ee\uff0c\u5e76\u4e14\u521d\u59cb\u5316\u8be5\u5b57\u6bb5\u7684\u4ee3\u4ef7\u5f88\u9ad8\uff0c\u90a3\u4e48\u5ef6\u8fdf\u521d\u59cb\u5316\u53ef\u80fd\u662f\u503c\u5f97\u7684\u3002\u552f\u4e00\u786e\u5b9a\u7684\u65b9\u6cd5\u662f\u4ee5\u4f7f\u7528\u548c\u4e0d\u4f7f\u7528\u5ef6\u8fdf\u521d\u59cb\u5316\u7684\u6548\u679c\u5bf9\u6bd4\u6765\u5ea6\u91cf\u7c7b\u7684\u6027\u80fd\u3002"),(0,n.kt)("p",null,"In the presence of multiple threads, lazy initialization is tricky. If two or more threads share a lazily initialized field, it is critical that some form of synchronization be employed, or severe bugs can result (Item 78). All of the initialization techniques discussed in this item are thread-safe."),(0,n.kt)("p",null,"\u5728\u5b58\u5728\u591a\u4e2a\u7ebf\u7a0b\u7684\u60c5\u51b5\u4e0b\uff0c\u4f7f\u7528\u5ef6\u8fdf\u521d\u59cb\u5316\u5f88\u68d8\u624b\u3002\u5982\u679c\u4e24\u4e2a\u6216\u591a\u4e2a\u7ebf\u7a0b\u5171\u4eab\u4e00\u4e2a\u5ef6\u8fdf\u521d\u59cb\u5316\u7684\u5b57\u6bb5\uff0c\u90a3\u4e48\u5fc5\u987b\u4f7f\u7528\u67d0\u79cd\u5f62\u5f0f\u7684\u540c\u6b65\uff0c\u5426\u5219\u4f1a\u5bfc\u81f4\u4e25\u91cd\u7684\u9519\u8bef\uff08",(0,n.kt)("a",{parentName:"p",href:"./Chapter-11/Chapter-11-Item-78-Synchronize-access-to-shared-mutable-data"},"Item-78"),"\uff09\u3002\u672c\u6761\u76ee\u8ba8\u8bba\u7684\u6240\u6709\u521d\u59cb\u5316\u6280\u672f\u90fd\u662f\u7ebf\u7a0b\u5b89\u5168\u7684\u3002"),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Under most circumstances, normal initialization is preferable to lazy initialization.")," Here is a typical declaration for a normally initialized instance field. Note the use of the final modifier (Item 17):"),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"\u5728\u5927\u591a\u6570\u60c5\u51b5\u4e0b\uff0c\u5e38\u89c4\u521d\u59cb\u5316\u4f18\u4e8e\u5ef6\u8fdf\u521d\u59cb\u5316\u3002")," \u4e0b\u9762\u662f\u4e00\u4e2a\u4f7f\u7528\u5e38\u89c4\u521d\u59cb\u5316\u7684\u5b9e\u4f8b\u5b57\u6bb5\u7684\u5178\u578b\u58f0\u660e\u3002\u6ce8\u610f final \u4fee\u9970\u7b26\u7684\u4f7f\u7528\uff08",(0,n.kt)("a",{parentName:"p",href:"./Chapter-4-Item-17-Minimize-mutability"},"Item-17"),"\uff09\uff1a"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"// Normal initialization of an instance field\nprivate final FieldType field = computeFieldValue();\n")),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"If you use lazy initialization to break an initialization circularity, use a synchronized accessor")," because it is the simplest, clearest alternative:"),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"\u5982\u679c\u60a8\u4f7f\u7528\u5ef6\u8fdf\u521d\u59cb\u5316\u6765\u53d6\u4ee3\u521d\u59cb\u5316 circularity\uff0c\u8bf7\u4f7f\u7528\u540c\u6b65\u8bbf\u95ee\u5668"),"\uff0c\u56e0\u4e3a\u5b83\u662f\u6700\u7b80\u5355\u3001\u6700\u6e05\u6670\u7684\u66ff\u4ee3\u65b9\u6cd5\uff1a"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"// Lazy initialization of instance field - synchronized accessor\nprivate FieldType field;\nprivate synchronized FieldType getField() {\n    if (field == null)\n        field = computeFieldValue();\n    return field;\n}\n")),(0,n.kt)("p",null,"Both of these idioms (normal initialization and lazy initialization with a synchronized accessor) are unchanged when applied to static fields, except that you add the static modifier to the field and accessor declarations."),(0,n.kt)("p",null,"\u8fd9\u4e24\u79cd\u4e60\u60ef\u7528\u6cd5\uff08\u4f7f\u7528\u540c\u6b65\u8bbf\u95ee\u5668\u8fdb\u884c\u5e38\u89c4\u521d\u59cb\u5316\u548c\u5ef6\u8fdf\u521d\u59cb\u5316\uff09\u5728\u5e94\u7528\u4e8e\u9759\u6001\u5b57\u6bb5\u65f6\u90fd\u6ca1\u6709\u6539\u53d8\uff0c\u53ea\u662f\u5728\u5b57\u6bb5\u548c\u8bbf\u95ee\u5668\u58f0\u660e\u4e2d\u6dfb\u52a0\u4e86 static \u4fee\u9970\u7b26\u3002"),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"If you need to use lazy initialization for performance on a static field, use the lazy initialization holder class idiom.")," This idiom exploits the guarantee that a class will not be initialized until it is used ","[JLS, 12.4.1]",". Here\u2019s how it looks:"),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"\u5982\u679c\u9700\u8981\u5728\u9759\u6001\u5b57\u6bb5\u4e0a\u4f7f\u7528\u5ef6\u8fdf\u521d\u59cb\u5316\u6765\u63d0\u9ad8\u6027\u80fd\uff0cuse the lazy initialization holder class idiom.")," \u8fd9\u4e2a\u7528\u6cd5\u53ef\u4fdd\u8bc1\u4e00\u4e2a\u7c7b\u5728\u4f7f\u7528\u4e4b\u524d\u4e0d\u4f1a\u88ab\u521d\u59cb\u5316 ","[JLS, 12.4.1]","\u3002\u5b83\u662f\u8fd9\u6837\u7684\uff1a"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"// Lazy initialization holder class idiom for static fields\nprivate static class FieldHolder {\n    static final FieldType field = computeFieldValue();\n}\nprivate static FieldType getField() { return FieldHolder.field; }\n")),(0,n.kt)("p",null,"When getField is invoked for the first time, it reads FieldHolder.field for the first time, causing the initialization of the FieldHolder class. The beauty of this idiom is that the getField method is not synchronized and performs only a field access, so lazy initialization adds practically nothing to the cost of access. A typical VM will synchronize field access only to initialize the class. Once the class is initialized, the VM patches the code so that subsequent access to the field does not involve any testing or synchronization."),(0,n.kt)("p",null,"\u7b2c\u4e00\u6b21\u8c03\u7528 getField \u65f6\uff0c\u5b83\u6267\u884c FieldHolder.field\uff0c\u5bfc\u81f4\u521d\u59cb\u5316 FieldHolder \u7c7b\u3002\u8fd9\u4e2a\u4e60\u60ef\u7528\u6cd5\u7684\u4f18\u70b9\u662f getField \u65b9\u6cd5\u4e0d\u662f\u540c\u6b65\u7684\uff0c\u53ea\u6267\u884c\u5b57\u6bb5\u8bbf\u95ee\uff0c\u6240\u4ee5\u5ef6\u8fdf\u521d\u59cb\u5316\u5b9e\u9645\u4e0a\u4e0d\u4f1a\u589e\u52a0\u8bbf\u95ee\u6210\u672c\u3002\u5178\u578b\u7684 VM \u53ea\u4f1a\u540c\u6b65\u5b57\u6bb5\u8bbf\u95ee\u6765\u521d\u59cb\u5316\u7c7b\u3002\u521d\u59cb\u5316\u7c7b\u4e4b\u540e\uff0cVM \u4f1a\u5bf9\u4ee3\u7801\u8fdb\u884c\u4fee\u8865\uff0c\u8fd9\u6837\u5bf9\u5b57\u6bb5\u7684\u540e\u7eed\u8bbf\u95ee\u5c31\u4e0d\u4f1a\u6d89\u53ca\u4efb\u4f55\u6d4b\u8bd5\u6216\u540c\u6b65\u3002"),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"If you need to use lazy initialization for performance on an instance field, use the double-check idiom.")," This idiom avoids the cost of locking when accessing the field after initialization (Item 79). The idea behind the idiom is to check the value of the field twice (hence the name double-check): once without locking and then, if the field appears to be uninitialized, a second time with locking. Only if the second check indicates that the field is uninitialized does the call initialize the field. Because there is no locking once the field is initialized, it is critical that the field be declared volatile (Item 78). Here is the idiom:"),(0,n.kt)("p",null,"\u5982\u679c\u9700\u8981\u4f7f\u7528\u5ef6\u8fdf\u521d\u59cb\u5316\u6765\u63d0\u9ad8\u5b9e\u4f8b\u5b57\u6bb5\u7684\u6027\u80fd\uff0c\u8bf7\u4f7f\u7528\u53cc\u91cd\u68c0\u67e5\u6a21\u5f0f\u3002\u8fd9\u4e2a\u6a21\u5f0f\u907f\u514d\u4e86\u521d\u59cb\u5316\u540e\u8bbf\u95ee\u5b57\u6bb5\u65f6\u7684\u9501\u5b9a\u6210\u672c\uff08",(0,n.kt)("a",{parentName:"p",href:"./Chapter-11/Chapter-11-Item-79-Avoid-excessive-synchronization"},"Item-79"),"\uff09\u3002\u8fd9\u4e2a\u6a21\u5f0f\u80cc\u540e\u7684\u601d\u60f3\u662f\u4e24\u6b21\u68c0\u67e5\u5b57\u6bb5\u7684\u503c\uff08\u56e0\u6b64\u5f97\u540d double check\uff09\uff1a\u4e00\u6b21\u6ca1\u6709\u9501\u5b9a\uff0c\u7136\u540e\uff0c\u5982\u679c\u5b57\u6bb5\u6ca1\u6709\u521d\u59cb\u5316\uff0c\u7b2c\u4e8c\u6b21\u4f7f\u7528\u9501\u5b9a\u3002\u53ea\u6709\u5f53\u7b2c\u4e8c\u6b21\u68c0\u67e5\u6307\u793a\u5b57\u6bb5\u672a\u521d\u59cb\u5316\u65f6\uff0c\u8c03\u7528\u624d\u521d\u59cb\u5316\u5b57\u6bb5\u3002\u7531\u4e8e\u521d\u59cb\u5316\u5b57\u6bb5\u540e\u6ca1\u6709\u9501\u5b9a\uff0c\u56e0\u6b64\u5c06\u5b57\u6bb5\u58f0\u660e\u4e3a volatile \u975e\u5e38\u91cd\u8981\uff08",(0,n.kt)("a",{parentName:"p",href:"./Chapter-11/Chapter-11-Item-78-Synchronize-access-to-shared-mutable-data"},"Item-78"),"\uff09\u3002\u4e0b\u9762\u662f\u8fd9\u4e2a\u6a21\u5f0f\u7684\u793a\u4f8b\uff1a"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"// Double-check idiom for lazy initialization of instance fields\nprivate volatile FieldType field;\nprivate FieldType getField() {\n    FieldType result = field;\n    if (result == null) { // First check (no locking)\n        synchronized(this) {\n            if (field == null) // Second check (with locking)\n                field = result = computeFieldValue();\n        }\n    }\n    return result;\n}\n")),(0,n.kt)("p",null,"This code may appear a bit convoluted. In particular, the need for the local variable (result) may be unclear. What this variable does is to ensure that field is read only once in the common case where it\u2019s already initialized."),(0,n.kt)("p",null,"\u8fd9\u6bb5\u4ee3\u7801\u53ef\u80fd\u770b\u8d77\u6765\u6709\u70b9\u590d\u6742\u3002\u7279\u522b\u662f\u4e0d\u6e05\u695a\u662f\u5426\u9700\u8981\u5c40\u90e8\u53d8\u91cf\uff08result\uff09\u3002\u8be5\u53d8\u91cf\u7684\u4f5c\u7528\u662f\u786e\u4fdd field \u5728\u5df2\u7ecf\u521d\u59cb\u5316\u7684\u60c5\u51b5\u4e0b\u53ea\u8bfb\u53d6\u4e00\u6b21\u3002"),(0,n.kt)("p",null,"While not strictly necessary, this may improve performance and is more elegant by the standards applied to low-level concurrent programming. On my machine, the method above is about 1.4 times as fast as the obvious version without a local variable. While you can apply the double-check idiom to static fields as well, there is no reason to do so: the lazy initialization holder class idiom is a better choice."),(0,n.kt)("p",null,"\u867d\u7136\u4e0d\u662f\u4e25\u683c\u5fc5\u9700\u7684\uff0c\u4f46\u8fd9\u53ef\u80fd\u4f1a\u63d0\u9ad8\u6027\u80fd\uff0c\u800c\u4e14\u4e0e\u4f4e\u7ea7\u5e76\u53d1\u7f16\u7a0b\u76f8\u6bd4\uff0c\u8fd9\u66f4\u4f18\u96c5\u3002\u5728\u6211\u7684\u673a\u5668\u4e0a\uff0c\u4e0a\u8ff0\u65b9\u6cd5\u7684\u901f\u5ea6\u5927\u7ea6\u662f\u6ca1\u6709\u5c40\u90e8\u53d8\u91cf\u7248\u672c\u7684 1.4 \u500d\u3002\u867d\u7136\u60a8\u4e5f\u53ef\u4ee5\u5c06\u53cc\u91cd\u68c0\u67e5\u6a21\u5f0f\u5e94\u7528\u4e8e\u9759\u6001\u5b57\u6bb5\uff0c\u4f46\u662f\u6ca1\u6709\u7406\u7531\u8fd9\u6837\u505a\uff1athe lazy initialization holder class idiom is a better choice."),(0,n.kt)("p",null,"Two variants of the double-check idiom bear noting. Occasionally, you may need to lazily initialize an instance field that can tolerate repeated initialization. If you find yourself in this situation, you can use a variant of the double-check idiom that dispenses with the second check. It is, not surprisingly, known as the single-check idiom. Here is how it looks. Note that field is still declared volatile:"),(0,n.kt)("p",null,"\u53cc\u91cd\u68c0\u67e5\u6a21\u5f0f\u7684\u4e24\u4e2a\u53d8\u4f53\u503c\u5f97\u6ce8\u610f\u3002\u6709\u65f6\u5019\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u5ef6\u8fdf\u521d\u59cb\u5316\u4e00\u4e2a\u5b9e\u4f8b\u5b57\u6bb5\uff0c\u8be5\u5b57\u6bb5\u53ef\u4ee5\u5bb9\u5fcd\u91cd\u590d\u521d\u59cb\u5316\u3002\u5982\u679c\u60a8\u53d1\u73b0\u81ea\u5df1\u5904\u4e8e\u8fd9\u79cd\u60c5\u51b5\uff0c\u60a8\u53ef\u4ee5\u4f7f\u7528\u53cc\u91cd\u68c0\u67e5\u6a21\u5f0f\u7684\u53d8\u4f53\u6765\u907f\u514d\u7b2c\u4e8c\u4e2a\u68c0\u67e5\u3002\u6beb\u65e0\u7591\u95ee\uff0c\u8fd9\u5c31\u662f\u6240\u8c13\u7684\u300c\u5355\u68c0\u67e5\u300d\u6a21\u5f0f\u3002\u5b83\u662f\u8fd9\u6837\u7684\u3002\u6ce8\u610f\uff0cfield \u4ecd\u7136\u58f0\u660e\u4e3a volatile\uff1a"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"// Single-check idiom - can cause repeated initialization!\nprivate volatile FieldType field;\nprivate FieldType getField() {\n    FieldType result = field;\n    if (result == null)\n        field = result = computeFieldValue();\n    return result;\n}\n")),(0,n.kt)("p",null,"All of the initialization techniques discussed in this item apply to primitive fields as well as object reference fields. When the double-check or single-check idiom is applied to a numerical primitive field, the field\u2019s value is checked against 0 (the default value for numerical primitive variables) rather than null."),(0,n.kt)("p",null,"\u672c\u6761\u76ee\u4e2d\u8ba8\u8bba\u7684\u6240\u6709\u521d\u59cb\u5316\u6280\u672f\u90fd\u9002\u7528\u4e8e\u57fa\u672c\u5b57\u6bb5\u548c\u5bf9\u8c61\u5f15\u7528\u5b57\u6bb5\u3002\u5f53\u53cc\u68c0\u67e5\u6216\u5355\u68c0\u67e5\u6a21\u5f0f\u5e94\u7528\u4e8e\u6570\u503c\u57fa\u672c\u7c7b\u578b\u5b57\u6bb5\u65f6\uff0c\u5c06\u6839\u636e 0\uff08\u6570\u503c\u57fa\u672c\u7c7b\u578b\u53d8\u91cf\u7684\u9ed8\u8ba4\u503c\uff09\u800c\u4e0d\u662f null \u68c0\u67e5\u5b57\u6bb5\u7684\u503c\u3002"),(0,n.kt)("p",null,"If you don\u2019t care whether every thread recalculates the value of a field, and the type of the field is a primitive other than long or double, then you may choose to remove the volatile modifier from the field declaration in the single-check idiom. This variant is known as the racy single-check idiom. It speeds up field access on some architectures, at the expense of additional initializations (up to one per thread that accesses the field). This is definitely an exotic technique, not for everyday use."),(0,n.kt)("p",null,"\u5982\u679c\u60a8\u4e0d\u5173\u5fc3\u6bcf\u4e2a\u7ebf\u7a0b\u662f\u5426\u90fd\u4f1a\u91cd\u65b0\u8ba1\u7b97\u5b57\u6bb5\u7684\u503c\uff0c\u5e76\u4e14\u5b57\u6bb5\u7684\u7c7b\u578b\u662f long \u6216 double \u4e4b\u5916\u7684\u57fa\u672c\u7c7b\u578b\uff0c\u90a3\u4e48\u60a8\u53ef\u4ee5\u9009\u62e9\u5728\u5355\u68c0\u67e5\u6a21\u5f0f\u4e2d\u4ece\u5b57\u6bb5\u58f0\u660e\u4e2d\u5220\u9664 volatile \u4fee\u9970\u7b26\u3002\u8fd9\u79cd\u53d8\u4f53\u79f0\u4e3a\u539f\u751f\u5355\u68c0\u67e5\u6a21\u5f0f\u3002\u5b83\u52a0\u5feb\u4e86\u67d0\u4e9b\u67b6\u6784\u4e0a\u7684\u5b57\u6bb5\u8bbf\u95ee\u901f\u5ea6\uff0c\u4ee3\u4ef7\u662f\u9700\u8981\u989d\u5916\u7684\u521d\u59cb\u5316\uff08\u6bcf\u4e2a\u8bbf\u95ee\u8be5\u5b57\u6bb5\u7684\u7ebf\u7a0b\u6700\u591a\u9700\u8981\u4e00\u4e2a\u521d\u59cb\u5316\uff09\u3002\u8fd9\u7edd\u5bf9\u662f\u4e00\u79cd\u5947\u7279\u7684\u6280\u672f\uff0c\u4e0d\u662f\u65e5\u5e38\u4f7f\u7528\u7684\u3002"),(0,n.kt)("p",null,"In summary, you should initialize most fields normally, not lazily. If you must initialize a field lazily in order to achieve your performance goals or to break a harmful initialization circularity, then use the appropriate lazy initialization technique. For instance fields, it is the double-check idiom; for static fields, the lazy initialization holder class idiom. For instance fields that can tolerate repeated initialization, you may also consider the single-check idiom."),(0,n.kt)("p",null,"\u603b\u4e4b\uff0c\u60a8\u5e94\u8be5\u6b63\u5e38\u521d\u59cb\u5316\u5927\u591a\u6570\u5b57\u6bb5\uff0c\u800c\u4e0d\u662f\u5ef6\u8fdf\u521d\u59cb\u5316\u3002\u5982\u679c\u5fc5\u987b\u5ef6\u8fdf\u521d\u59cb\u5316\u5b57\u6bb5\u4ee5\u5b9e\u73b0\u6027\u80fd\u76ee\u6807\u6216 break a harmful initialization circularity\uff0c\u5219\u4f7f\u7528\u9002\u5f53\u7684\u5ef6\u8fdf\u521d\u59cb\u5316\u6280\u672f\u3002\u5bf9\u4e8e\u5b57\u6bb5\uff0c\u4f7f\u7528\u53cc\u91cd\u68c0\u67e5\u6a21\u5f0f\uff1b\u5bf9\u4e8e\u9759\u6001\u5b57\u6bb5\uff0cthe lazy initialization holder class idiom. \u4f8b\u5982\uff0c\u53ef\u4ee5\u5bb9\u5fcd\u91cd\u590d\u521d\u59cb\u5316\u7684\u5b9e\u4f8b\u5b57\u6bb5\uff0c\u60a8\u8fd8\u53ef\u4ee5\u8003\u8651\u5355\u68c0\u67e5\u6a21\u5f0f\u3002"),(0,n.kt)("hr",null),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},(0,n.kt)("a",{parentName:"strong",href:"./Chapter-11/Chapter-11-Introduction"},"Back to contents of the chapter\uff08\u8fd4\u56de\u7ae0\u8282\u76ee\u5f55\uff09"))),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Previous Item\uff08\u4e0a\u4e00\u6761\u76ee\uff09\uff1a",(0,n.kt)("a",{parentName:"strong",href:"./Chapter-11/Chapter-11-Item-82-Document-thread-safety"},"Item 82: Document thread safety\uff08\u6587\u6863\u5e94\u5305\u542b\u7ebf\u7a0b\u5b89\u5168\u5c5e\u6027\uff09"))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Next Item\uff08\u4e0b\u4e00\u6761\u76ee\uff09\uff1a",(0,n.kt)("a",{parentName:"strong",href:"./Chapter-11/Chapter-11-Item-84-Don%E2%80%99t-depend-on-the-thread-scheduler"},"Item 84: Don\u2019t depend on the thread scheduler\uff08\u4e0d\u8981\u4f9d\u8d56\u7ebf\u7a0b\u8c03\u5ea6\u5668\uff09")))))}h.isMDXComponent=!0}}]);