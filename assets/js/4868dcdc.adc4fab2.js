"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[334],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>p});var a=n(7294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,s=function(e,t){if(null==e)return{};var n,a,s={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var l=a.createContext({}),d=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=d(e.components);return a.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,s=e.mdxType,o=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),u=d(n),p=s,m=u["".concat(l,".").concat(p)]||u[p]||h[p]||o;return n?a.createElement(m,r(r({ref:t},c),{},{components:n})):a.createElement(m,r({ref:t},c))}));function p(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var o=n.length,r=new Array(o);r[0]=u;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:s,r[1]=i;for(var d=2;d<o;d++)r[d]=n[d];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},7484:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>d});var a=n(7462),s=(n(7294),n(3905));const o={},r=void 0,i={unversionedId:"Books/EffectiveJava3/Chapter-4/Chapter-4-Item-18-Favor-composition-over-inheritance",id:"Books/EffectiveJava3/Chapter-4/Chapter-4-Item-18-Favor-composition-over-inheritance",title:"Chapter-4-Item-18-Favor-composition-over-inheritance",description:"Chapter 4. Classes and Interfaces\uff08\u7c7b\u548c\u63a5\u53e3\uff09",source:"@site/docs/Books/EffectiveJava3/Chapter-4/Chapter-4-Item-18-Favor-composition-over-inheritance.md",sourceDirName:"Books/EffectiveJava3/Chapter-4",slug:"/Books/EffectiveJava3/Chapter-4/Chapter-4-Item-18-Favor-composition-over-inheritance",permalink:"/docs/Books/EffectiveJava3/Chapter-4/Chapter-4-Item-18-Favor-composition-over-inheritance",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Books/EffectiveJava3/Chapter-4/Chapter-4-Item-18-Favor-composition-over-inheritance.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Chapter-4-Item-17-Minimize-mutability",permalink:"/docs/Books/EffectiveJava3/Chapter-4/Chapter-4-Item-17-Minimize-mutability"},next:{title:"Chapter-4-Item-19-Design-and-document-for-inheritance-or-else-prohibit-it",permalink:"/docs/Books/EffectiveJava3/Chapter-4/Chapter-4-Item-19-Design-and-document-for-inheritance-or-else-prohibit-it"}},l={},d=[{value:"Chapter 4. Classes and Interfaces\uff08\u7c7b\u548c\u63a5\u53e3\uff09",id:"chapter-4-classes-and-interfaces\u7c7b\u548c\u63a5\u53e3",level:2},{value:"Item 18: Favor composition over inheritance\uff08\u4f18\u5148\u9009\u62e9\u590d\u5408\u800c\u4e0d\u662f\u7ee7\u627f\uff09",id:"item-18-favor-composition-over-inheritance\u4f18\u5148\u9009\u62e9\u590d\u5408\u800c\u4e0d\u662f\u7ee7\u627f",level:3}],c={toc:d};function h(e){let{components:t,...n}=e;return(0,s.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h2",{id:"chapter-4-classes-and-interfaces\u7c7b\u548c\u63a5\u53e3"},"Chapter 4. Classes and Interfaces\uff08\u7c7b\u548c\u63a5\u53e3\uff09"),(0,s.kt)("h3",{id:"item-18-favor-composition-over-inheritance\u4f18\u5148\u9009\u62e9\u590d\u5408\u800c\u4e0d\u662f\u7ee7\u627f"},"Item 18: Favor composition over inheritance\uff08\u4f18\u5148\u9009\u62e9\u590d\u5408\u800c\u4e0d\u662f\u7ee7\u627f\uff09"),(0,s.kt)("p",null,"Inheritance is a powerful way to achieve code reuse, but it is not always the best tool for the job. Used inappropriately, it leads to fragile software. It is safe to use inheritance within a package, where the subclass and the superclass implementations are under the control of the same programmers. It is also safe to use inheritance when extending classes specifically designed and documented for extension (Item 19). Inheriting from ordinary concrete classes across package boundaries, however, is dangerous. As a reminder, this book uses the word \u201cinheritance\u201d to mean implementation inheritance (when one class extends another). The problems discussed in this item do not apply to interface inheritance (when a class implements an interface or when one interface extends another)."),(0,s.kt)("p",null,"\u7ee7\u627f\u662f\u5b9e\u73b0\u4ee3\u7801\u590d\u7528\u7684\u4e00\u79cd\u5f3a\u5927\u65b9\u6cd5\uff0c\u4f46\u5b83\u5e76\u4e0d\u603b\u662f\u6700\u4f73\u7684\u5de5\u5177\u3002\u4f7f\u7528\u4e0d\u5f53\u4f1a\u5bfc\u81f4\u8f6f\u4ef6\u53d8\u5f97\u8106\u5f31\u3002\u5728\u540c\u4e00\u4e2a\u5305\u4e2d\u4f7f\u7528\u7ee7\u627f\u662f\u5b89\u5168\u7684\uff0c\u5176\u4e2d\u5b50\u7c7b\u548c\u8d85\u7c7b\u5b9e\u73b0\u7531\u76f8\u540c\u7684\u7a0b\u5e8f\u5458\u63a7\u5236\u3002\u5728\u5bf9\u4e13\u4e3a\u6269\u5c55\u800c\u8bbe\u8ba1\u548c\u6587\u6863\u5316\u7684\u7c7b\u65f6\u4f7f\u7528\u7ee7\u627f\u4e5f\u662f\u5b89\u5168\u7684\uff08",(0,s.kt)("a",{parentName:"p",href:"./Chapter-4-Item-19-Design-and-document-for-inheritance-or-else-prohibit-it"},"Item-19"),"\uff09\u3002\u7136\u800c\uff0c\u5bf9\u666e\u901a\u7684\u5177\u4f53\u7c7b\u8fdb\u884c\u8de8\u8d8a\u5305\u8fb9\u754c\u7684\u7ee7\u627f\u662f\u5371\u9669\u7684\u3002\u4f5c\u4e3a\u63d0\u9192\uff0c\u672c\u4e66\u4f7f\u7528\u300c\u7ee7\u627f\u300d\u4e00\u8bcd\u6765\u8868\u793a\u5b9e\u73b0\u7ee7\u627f\uff08\u5f53\u4e00\u4e2a\u7c7b\u6269\u5c55\u53e6\u4e00\u4e2a\u7c7b\u65f6\uff09\u3002\u672c\u6761\u76ee\u4e2d\u8ba8\u8bba\u7684\u95ee\u9898\u4e0d\u9002\u7528\u4e8e\u63a5\u53e3\u7ee7\u627f\uff08\u5f53\u7c7b\u5b9e\u73b0\u63a5\u53e3\u6216\u4e00\u4e2a\u63a5\u53e3\u6269\u5c55\u53e6\u4e00\u4e2a\u63a5\u53e3\u65f6\uff09\u3002"),(0,s.kt)("p",null,"Unlike method invocation, inheritance violates encapsulation ","[Snyder86]",". In other words, a subclass depends on the implementation details of its superclass for its proper function. The superclass\u2019s implementation may change from release to release, and if it does, the subclass may break, even though its code has not been touched. As a consequence, a subclass must evolve in tandem with its superclass, unless the superclass\u2019s authors have designed and documented it specifically for the purpose of being extended."),(0,s.kt)("p",null,"\u4e0e\u65b9\u6cd5\u8c03\u7528\u4e0d\u540c\uff0c\u7ee7\u627f\u7834\u574f\u4e86\u5c01\u88c5 ","[Snyder86]","\u3002\u6362\u53e5\u8bdd\u8bf4\uff0c\u5b50\u7c7b\u7684\u529f\u80fd\u6b63\u786e\u4e0e\u5426\u4f9d\u8d56\u4e8e\u5b83\u7684\u8d85\u7c7b\u7684\u5b9e\u73b0\u7ec6\u8282\u3002\u8d85\u7c7b\u7684\u5b9e\u73b0\u53ef\u80fd\u5728\u7248\u672c\u4e4b\u95f4\u53d1\u751f\u53d8\u5316\uff0c\u5982\u679c\u53d1\u751f\u4e86\u53d8\u5316\uff0c\u5b50\u7c7b\u53ef\u80fd\u4f1a\u5d29\u6e83\uff0c\u5373\u4f7f\u5b50\u7c7b\u7684\u4ee3\u7801\u6ca1\u6709\u88ab\u4fee\u6539\u8fc7\u3002\u56e0\u6b64\uff0c\u5b50\u7c7b\u5fc5\u987b\u4e0e\u5176\u8d85\u7c7b\u540c\u6b65\u53d1\u5c55\uff0c\u9664\u975e\u8d85\u7c7b\u662f\u4e13\u95e8\u4e3a\u6269\u5c55\u7684\u76ee\u7684\u800c\u8bbe\u8ba1\u7684\uff0c\u5e76\u5177\u6709\u5f88\u660e\u786e\u7684\u6587\u6863\u8bf4\u660e\u3002"),(0,s.kt)("p",null,"To make this concrete, let\u2019s suppose we have a program that uses a HashSet. To tune the performance of our program, we need to query the HashSet as to how many elements have been added since it was created (not to be confused with its current size, which goes down when an element is removed). To provide this functionality, we write a HashSet variant that keeps count of the number of attempted element insertions and exports an accessor for this count. The HashSet class contains two methods capable of adding elements, add and addAll, so we override both of these methods:"),(0,s.kt)("p",null,"\u4e3a\u4e86\u4f7f\u95ee\u9898\u66f4\u5177\u4f53\u4e00\u4e9b\uff0c\u8ba9\u6211\u4eec\u5047\u8bbe\u6709\u4e00\u4e2a\u4f7f\u7528 HashSet \u7684\u7a0b\u5e8f\u3002\u4e3a\u4e86\u4f18\u5316\u7a0b\u5e8f\u7684\u6027\u80fd\uff0c\u6211\u4eec\u9700\u8981\u67e5\u8be2 HashSet\uff0c\u4ee5\u786e\u5b9a\u81ea\u521b\u5efa\u4ee5\u6765\u6dfb\u52a0\u4e86\u591a\u5c11\u5143\u7d20\uff08\u4e0d\u8981\u4e0e\u5f53\u524d\u7684\u5927\u5c0f\u6df7\u6dc6\uff0c\u5f53\u5143\u7d20\u88ab\u5220\u9664\u65f6\uff0c\u5f53\u524d\u7684\u5927\u5c0f\u4f1a\u9012\u51cf\uff09\u3002\u4e3a\u4e86\u63d0\u4f9b\u8fd9\u4e2a\u529f\u80fd\uff0c\u6211\u4eec\u7f16\u5199\u4e86\u4e00\u4e2a\u53d8\u91cf\uff0c\u5b83\u8bb0\u5f55\u8bd5\u56fe\u63d2\u5165 HashSet \u7684\u5143\u7d20\u6570\u91cf\uff0c\u5e76\u4e3a\u8fd9\u4e2a\u8ba1\u6570\u53d8\u91cf\u5bfc\u51fa\u4e00\u4e2a\u8bbf\u95ee\u5668\u3002HashSet \u7c7b\u5305\u542b\u4e24\u4e2a\u80fd\u591f\u6dfb\u52a0\u5143\u7d20\u7684\u65b9\u6cd5\uff0cadd \u548c addAll\uff0c\u56e0\u6b64\u6211\u4eec\u8986\u76d6\u8fd9\u4e24\u4e2a\u65b9\u6cd5\uff1a"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"// Broken - Inappropriate use of inheritance!\npublic class InstrumentedHashSet<E> extends HashSet<E> {\n\n    // The number of attempted element insertions\n    private int addCount = 0;\n\n    public InstrumentedHashSet() {\n    }\n\n    public InstrumentedHashSet(int initCap, float loadFactor) {\n        super(initCap, loadFactor);\n    }\n\n    @Override\n    public boolean add(E e) {\n        addCount++;\n        return super.add(e);\n    }\n\n    @Override\n    public boolean addAll(Collection<? extends E> c) {\n        addCount += c.size();\n        return super.addAll(c);\n    }\n\n    public int getAddCount() {\n        return addCount;\n    }\n}\n")),(0,s.kt)("p",null,"This class looks reasonable, but it doesn\u2019t work. Suppose we create an instance and add three elements using the addAll method. Incidentally, note that we create a list using the static factory method List.of, which was added in Java 9; if you\u2019re using an earlier release, use Arrays.asList instead:"),(0,s.kt)("p",null,"\u8fd9\u4e2a\u7c7b\u770b\u8d77\u6765\u662f\u5408\u7406\u7684\uff0c\u4f46\u662f\u5b83\u4e0d\u8d77\u4f5c\u7528\u3002\u5047\u8bbe\u6211\u4eec\u521b\u5efa\u4e86\u4e00\u4e2a\u5b9e\u4f8b\uff0c\u5e76\u4f7f\u7528 addAll \u65b9\u6cd5\u6dfb\u52a0\u4e86\u4e09\u4e2a\u5143\u7d20\u3002\u987a\u4fbf\u8bf4\u4e00\u4e0b\uff0c\u6211\u4eec\u4f7f\u7528 Java 9 \u4e2d\u6dfb\u52a0\u7684\u9759\u6001\u5de5\u5382\u65b9\u6cd5 ",(0,s.kt)("inlineCode",{parentName:"p"},"List.of")," \u521b\u5efa\u4e86\u4e00\u4e2a\u5217\u8868\uff1b\u5982\u679c\u4f60\u4f7f\u7528\u7684\u662f\u65e9\u671f\u7248\u672c\uff0c\u90a3\u4e48\u4f7f\u7528 ",(0,s.kt)("inlineCode",{parentName:"p"},"Arrays.asList"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},'InstrumentedHashSet<String> s = new InstrumentedHashSet<>();\ns.addAll(List.of("Snap", "Crackle", "Pop"));\n')),(0,s.kt)("p",null,"We would expect the getAddCount method to return three at this point, but it returns six. What went wrong? Internally, HashSet\u2019s addAll method is implemented on top of its add method, although HashSet, quite reasonably, does not document this implementation detail. The addAll method in Instrumented-HashSet added three to addCount and then invoked HashSet\u2019s addAll implementation using super.addAll. This in turn invoked the add method, as overridden in InstrumentedHashSet, once for each element. Each of these three invocations added one more to addCount, for a total increase of six: each element added with the addAll method is double-counted."),(0,s.kt)("p",null,"\u6211\u4eec\u5e0c\u671b getAddCount \u65b9\u6cd5\u6b64\u65f6\u8fd4\u56de 3\uff0c\u4f46\u5b83\u8fd4\u56de 6\u3002\u5230\u5e95\u662f\u54ea\u91cc\u51fa\u4e86\u9519\uff1f\u5728 HashSet \u5185\u90e8\uff0caddAll \u65b9\u6cd5\u662f\u57fa\u4e8e add \u65b9\u6cd5\u5b9e\u73b0\u7684\uff0c\u5c3d\u7ba1 HashSet \u7406\u6240\u5f53\u7136\u7684\u6ca1\u6709\u8bb0\u5f55\u8fd9\u4e2a\u5b9e\u73b0\u7ec6\u8282\u3002InstrumentedHashSet \u4e2d\u7684 addAll \u65b9\u6cd5\u4f7f addCount \u53d8\u91cf\u589e\u52a0\u4e86 3\uff0c\u7136\u540e\u901a\u8fc7 ",(0,s.kt)("inlineCode",{parentName:"p"},"super.addAll")," \u8c03\u7528 HashSet \u7684 addAll \u5b9e\u73b0\u3002\u8fd9\u76f8\u5f53\u4e8e\u53cd\u8fc7\u6765\u8c03\u7528\u5728 InstrumentedHashSet \u4e2d\u88ab\u8986\u76d6\u7684 add \u65b9\u6cd5\uff0c\u6bcf\u4e2a\u5143\u7d20\u4e00\u6b21\u3002\u8fd9\u4e09\u4e2a\u8c03\u7528\u4e2d\u7684\u6bcf\u4e00\u4e2a\u90fd\u4f7f addCount \u53d8\u91cf\u589e\u52a0\u4e86 1\uff0c\u603b\u5171\u589e\u52a0\u4e86 6\uff0c\u5373\u4f7f\u7528 addAll \u65b9\u6cd5\u6dfb\u52a0\u7684\u6bcf\u4e2a\u5143\u7d20\u90fd\u88ab\u91cd\u590d\u8ba1\u6570\u3002"),(0,s.kt)("p",null,"We could \u201cfix\u201d the subclass by eliminating its override of the addAll method. While the resulting class would work, it would depend for its proper function on the fact that HashSet\u2019s addAll method is implemented on top of its add method. This \u201cself-use\u201d is an implementation detail, not guaranteed to hold in all implementations of the Java platform and subject to change from release to release. Therefore, the resulting InstrumentedHashSet class would be fragile."),(0,s.kt)("p",null,"\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u79fb\u9664\u5b50\u7c7b\u8986\u76d6\u7684 addAll \u65b9\u6cd5\u6765\u300c\u4fee\u590d\u300d\u3002\u867d\u7136\u751f\u6210\u7684\u7c7b\u53ef\u4ee5\u5de5\u4f5c\uff0c\u4f46\u5b83\u7684\u6b63\u786e\u529f\u80fd\u53d6\u51b3\u4e8e HashSet \u7684 addAll \u65b9\u6cd5\u662f\u57fa\u4e8e add \u65b9\u6cd5\u5b9e\u73b0\u7684\u4e8b\u5b9e\u3002\u8fd9\u79cd\u300c\u81ea\u7528\u300d\u662f\u5b9e\u73b0\u7ec6\u8282\uff0c\u4e0d\u80fd\u4fdd\u8bc1\u5728 Java \u5e73\u53f0\u7684\u6240\u6709\u5b9e\u73b0\u4e2d\u90fd\u4fdd\u7559\uff0c\u5e76\u4e14\u5728\u4e0d\u540c\u7684\u7248\u672c\u4e2d\u53ef\u80fd\u4f1a\u6709\u53d8\u5316\u3002\u56e0\u6b64\uff0c\u751f\u6210\u7684 InstrumentedHashSet \u7c7b\u662f\u8106\u5f31\u7684\u3002"),(0,s.kt)("p",null,"It would be slightly better to override the addAll method to iterate over the specified collection, calling the add method once for each element. This would guarantee the correct result whether or not HashSet\u2019s addAll method were implemented atop its add method because HashSet\u2019s addAll implementation would no longer be invoked. This technique, however, does not solve all our problems. It amounts to reimplementing superclass methods that may or may not result in self-use, which is difficult, time-consuming, errorprone,and may reduce performance. Additionally, it isn\u2019t always possible because some methods cannot be implemented without access to private fields inaccessible to the subclass."),(0,s.kt)("p",null,"\u5982\u679c\u901a\u8fc7\u8986\u76d6 addAll \u65b9\u6cd5\u6765\u904d\u5386\u6307\u5b9a\u7684\u96c6\u5408\uff0c\u5bf9\u6bcf\u4e2a\u5143\u7d20\u8c03\u7528\u4e00\u6b21 add \u65b9\u6cd5\u4f1a\u7a0d\u597d\u4e00\u4e9b\u3002\u65e0\u8bba HashSet \u7684 addAll \u65b9\u6cd5\u662f\u5426\u57fa\u4e8e add \u65b9\u6cd5\u5b9e\u73b0\u90fd\u80fd\u4fdd\u8bc1\u5f97\u5230\u6b63\u786e\u7ed3\u679c\uff0c\u56e0\u4e3a HashSet \u7684 addAll \u5b9e\u73b0\u5c06\u4e0d\u518d\u88ab\u8c03\u7528\u3002\u7136\u800c\uff0c\u8fd9\u79cd\u6280\u672f\u5e76\u4e0d\u80fd\u89e3\u51b3\u6211\u4eec\u6240\u6709\u7684\u95ee\u9898\u3002\u5b83\u76f8\u5f53\u4e8e\u91cd\u65b0\u5b9e\u73b0\u8d85\u7c7b\u65b9\u6cd5\uff0c\u8fd9\u53ef\u80fd\u4f1a\u5bfc\u81f4\u300c\u81ea\u7528\u300d\uff0c\u4e5f\u53ef\u80fd\u4e0d\u4f1a\uff0c\u8fd9\u662f\u56f0\u96be\u7684\u3001\u8017\u65f6\u7684\u3001\u5bb9\u6613\u51fa\u9519\u7684\uff0c\u5e76\u4e14\u53ef\u80fd\u4f1a\u964d\u4f4e\u6027\u80fd\u3002\u6b64\u5916\uff0c\u8fd9\u5e76\u4e0d\u603b\u662f\u53ef\u884c\u7684\uff0c\u5982\u679c\u5b50\u7c7b\u65e0\u6cd5\u8bbf\u95ee\u67d0\u4e9b\u79c1\u6709\u5b57\u6bb5\uff0c\u8fd9\u4e9b\u65b9\u6cd5\u5c31\u65e0\u6cd5\u5b9e\u73b0\u3002"),(0,s.kt)("p",null,"A related cause of fragility in subclasses is that their superclass can acquire new methods in subsequent releases. Suppose a program depends for its security on the fact that all elements inserted into some collection satisfy some predicate.This can be guaranteed by subclassing the collection and overriding each method capable of adding an element to ensure that the predicate is satisfied before adding the element. This works fine until a new method capable of inserting an element is added to the superclass in a subsequent release. Once this happens, it becomes possible to add an \u201cillegal\u201d element merely by invoking the new method, which is not overridden in the subclass. This is not a purely theoretical problem. Several security holes of this nature had to be fixed when Hashtable and Vector were retrofitted to participate in the Collections Framework."),(0,s.kt)("p",null,"\u5b50\u7c7b\u8106\u5f31\u7684\u4e00\u4e2a\u539f\u56e0\u662f\u4ed6\u4eec\u7684\u8d85\u7c7b\u53ef\u4ee5\u5728\u540e\u7eed\u7248\u672c\u4e2d\u83b7\u5f97\u65b0\u7684\u65b9\u6cd5\u3002\u5047\u8bbe\u4e00\u4e2a\u7a0b\u5e8f\u7684\u5b89\u5168\u6027\u53d6\u51b3\u4e8e\u63d2\u5165\u5230\u67d0\u4e2a\u96c6\u5408\u4e2d\u7684\u6240\u6709\u5143\u7d20\u6ee1\u8db3\u67d0\u4e2a\u65ad\u8a00\u3002\u8fd9\u53ef\u4ee5\u901a\u8fc7\u5b50\u7c7b\u5316\u96c6\u5408\u548c\u8986\u76d6\u6bcf\u4e2a\u80fd\u591f\u6dfb\u52a0\u5143\u7d20\u7684\u65b9\u6cd5\u6765\u786e\u4fdd\u5728\u6dfb\u52a0\u5143\u7d20\u4e4b\u524d\u6ee1\u8db3\u65ad\u8a00\u3002\u8fd9\u53ef\u4ee5\u5f88\u597d\u5730\u5de5\u4f5c\uff0c\u76f4\u5230\u5728\u540e\u7eed\u7248\u672c\u4e2d\u5411\u8d85\u7c7b\u4e2d\u6dfb\u52a0\u80fd\u591f\u63d2\u5165\u5143\u7d20\u7684\u65b0\u65b9\u6cd5\u3002\u4e00\u65e6\u53d1\u751f\u8fd9\u79cd\u60c5\u51b5\uff0c\u53ea\u9700\u8c03\u7528\u65b0\u65b9\u6cd5\u5c31\u53ef\u4ee5\u6dfb\u52a0\u300c\u975e\u6cd5\u300d\u5143\u7d20\uff0c\u800c\u65b0\u65b9\u6cd5\u5728\u5b50\u7c7b\u4e2d\u4e0d\u4f1a\u88ab\u8986\u76d6\u3002\u8fd9\u4e0d\u662f\u4e00\u4e2a\u7eaf\u7cb9\u7684\u7406\u8bba\u95ee\u9898\u3002\u5f53 Hashtable \u548c Vector \u88ab\u91cd\u65b0\u6539\u88c5\u4ee5\u52a0\u5165 Collections \u6846\u67b6\u65f6\uff0c\u5fc5\u987b\u4fee\u590d\u51e0\u4e2a\u8fd9\u79cd\u6027\u8d28\u7684\u5b89\u5168\u6f0f\u6d1e\u3002"),(0,s.kt)("p",null,"Both of these problems stem from overriding methods. You might think that it is safe to extend a class if you merely add new methods and refrain from overriding existing methods. While this sort of extension is much safer, it is not without risk. If the superclass acquires a new method in a subsequent release and you have the bad luck to have given the subclass a method with the same signature and a different return type, your subclass will no longer compile ","[JLS, 8.4.8.3]",". If you\u2019ve given the subclass a method with the same signature and return type as the new superclass method, then you\u2019re now overriding it, so you\u2019re subject to the problems described earlier. Furthermore, it is doubtful that your method will fulfill the contract of the new superclass method, because that contract had not yet been written when you wrote the subclass method."),(0,s.kt)("p",null,"\u8fd9\u4e24\u4e2a\u95ee\u9898\u90fd\u6e90\u4e8e\u8986\u76d6\u65b9\u6cd5\u3002\u4f60\u53ef\u80fd\u8ba4\u4e3a\uff0c\u5982\u679c\u53ea\u6dfb\u52a0\u65b0\u65b9\u6cd5\uff0c\u5e76\u4e14\u4e0d\u8986\u76d6\u73b0\u6709\u65b9\u6cd5\uff0c\u90a3\u4e48\u6269\u5c55\u7c7b\u662f\u5b89\u5168\u7684\u3002\u867d\u7136\u8fd9\u79cd\u6269\u5c55\u4f1a\u66f4\u5b89\u5168\uff0c\u4f46\u4e5f\u4e0d\u662f\u6ca1\u6709\u98ce\u9669\u3002\u5982\u679c\u8d85\u7c7b\u5728\u968f\u540e\u7684\u7248\u672c\u4e2d\u83b7\u5f97\u4e86\u4e00\u4e2a\u65b0\u65b9\u6cd5\uff0c\u800c\u5b50\u7c7b\u5177\u6709\u4e00\u4e2a\u76f8\u540c\u7b7e\u540d\u548c\u4e0d\u540c\u8fd4\u56de\u7c7b\u578b\u7684\u65b9\u6cd5\uff0c\u90a3\u4e48\u4f60\u7684\u5b50\u7c7b\u5c06\u4e0d\u80fd\u7f16\u8bd1 ","[JLS, 8.4.8.3]","\u3002\u5982\u679c\u7ed9\u5b50\u7c7b\u4e00\u4e2a\u65b9\u6cd5\uff0c\u8be5\u65b9\u6cd5\u5177\u6709\u4e0e\u65b0\u8d85\u7c7b\u65b9\u6cd5\u76f8\u540c\u7684\u7b7e\u540d\u548c\u8fd4\u56de\u7c7b\u578b\uff0c\u90a3\u4e48\u73b0\u5728\u8981\u8986\u76d6\u5b83\uff0c\u56e0\u6b64\u4f60\u8981\u9762\u5bf9\u524d\u9762\u63cf\u8ff0\u7684\u95ee\u9898\u3002\u6b64\u5916\uff0c\u4f60\u7684\u65b9\u6cd5\u662f\u5426\u80fd\u591f\u5b8c\u6210\u65b0\u7684\u8d85\u7c7b\u65b9\u6cd5\u7684\u7ea6\u5b9a\u662f\u503c\u5f97\u6000\u7591\u7684\uff0c\u56e0\u4e3a\u5728\u4f60\u7f16\u5199\u5b50\u7c7b\u65b9\u6cd5\u65f6\uff0c\u8be5\u7ea6\u5b9a\u8fd8\u6ca1\u6709\u88ab\u5199\u5165\u3002"),(0,s.kt)("p",null,"Luckily, there is a way to avoid all of the problems described above. Instead of extending an existing class, give your new class a private field that references an instance of the existing class. This design is called composition because the existing class becomes a component of the new one. Each instance method in the new class invokes the corresponding method on the contained instance of the existing class and returns the results. This is known as forwarding, and the methods in the new class are known as forwarding methods. The resulting class will be rock solid, with no dependencies on the implementation details of the existing class. Even adding new methods to the existing class will have no impact on the new class. To make this concrete, here\u2019s a replacement for InstrumentedHashSet that uses the composition-and-forwarding approach. Note that the implementation is broken into two pieces, the class itself and a reusable forwarding class, which contains all of the forwarding methods and nothing else:"),(0,s.kt)("p",null,"\u5e78\u8fd0\u7684\u662f\uff0c\u6709\u4e00\u79cd\u65b9\u6cd5\u53ef\u4ee5\u907f\u514d\u4e0a\u8ff0\u6240\u6709\u95ee\u9898\u3002\u4e0e\u5176\u6269\u5c55\u73b0\u6709\u7c7b\uff0c\u4e0d\u5982\u4e3a\u65b0\u7c7b\u63d0\u4f9b\u4e00\u4e2a\u5f15\u7528\u73b0\u6709\u7c7b\u5b9e\u4f8b\u7684\u79c1\u6709\u5b57\u6bb5\u3002\u8fd9\u79cd\u8bbe\u8ba1\u79f0\u4e3a\u590d\u5408\uff0c\u56e0\u4e3a\u73b0\u6709\u7684\u7c7b\u662f\u65b0\u7c7b\u7684\u4e00\u4e2a\u7ec4\u4ef6\u3002\u65b0\u7c7b\u4e2d\u7684\u6bcf\u4e2a\u5b9e\u4f8b\u65b9\u6cd5\u8c03\u7528\u73b0\u6709\u7c7b\u5b9e\u4f8b\u7684\u5bf9\u5e94\u65b9\u6cd5\uff0c\u5e76\u8fd4\u56de\u7ed3\u679c\u3002\u8fd9\u79f0\u4e3a\u8f6c\u53d1\uff0c\u65b0\u7c7b\u4e2d\u7684\u65b9\u6cd5\u79f0\u4e3a\u8f6c\u53d1\u65b9\u6cd5\u3002\u751f\u6210\u7684\u7c7b\u5c06\u975e\u5e38\u575a\u56fa\uff0c\u4e0d\u4f9d\u8d56\u4e8e\u73b0\u6709\u7c7b\u7684\u5b9e\u73b0\u7ec6\u8282\u3002\u5373\u4f7f\u5411\u73b0\u6709\u7c7b\u6dfb\u52a0\u65b0\u65b9\u6cd5\uff0c\u4e5f\u4e0d\u4f1a\u5bf9\u65b0\u7c7b\u4ea7\u751f\u5f71\u54cd\u3002\u4e3a\u4e86\u8bf4\u660e\u95ee\u9898\uff0c\u8fd9\u91cc\u6709\u4e00\u4e2a\u4f7f\u7528\u590d\u5408\u548c\u8f6c\u53d1\u65b9\u6cd5\u7684\u6848\u4f8b\uff0c\u7528\u4ee5\u66ff\u4ee3 InstrumentedHashSet\u3002\u6ce8\u610f\uff0c\u5b9e\u73b0\u88ab\u5206\u6210\u4e24\u90e8\u5206\uff0c\u7c7b\u672c\u8eab\u548c\u4e00\u4e2a\u53ef\u590d\u7528\u7684\u8f6c\u53d1\u7c7b\uff0c\u5176\u4e2d\u5305\u542b\u6240\u6709\u7684\u8f6c\u53d1\u65b9\u6cd5\uff0c\u6ca1\u6709\u5176\u4ed6\u5185\u5bb9\uff1a"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"// Wrapper class - uses composition in place of inheritance\npublic class InstrumentedSet<E> extends ForwardingSet<E> {\n\n    private int addCount = 0;\n\n    public InstrumentedSet(Set<E> s) {\n        super(s);\n    }\n\n    @Override\n    public boolean add(E e) {\n        addCount++;\n        return super.add(e);\n    }\n\n    @Override\n    public boolean addAll(Collection<? extends E> c) {\n        addCount += c.size();\n        return super.addAll(c);\n    }\n\n    public int getAddCount() {\n        return addCount;\n    }\n}\n\n// Reusable forwarding class\npublic class ForwardingSet<E> implements Set<E> {\n    private final Set<E> s;\n    public ForwardingSet(Set<E> s) { this.s = s; }\n    public void clear() { s.clear(); }\n    public boolean contains(Object o) { return s.contains(o); }\n    public boolean isEmpty() { return s.isEmpty(); }\n    public int size() { return s.size(); }\n    public Iterator<E> iterator() { return s.iterator(); }\n    public boolean add(E e) { return s.add(e); }\n    public boolean remove(Object o) { return s.remove(o); }\n    public boolean containsAll(Collection<?> c)\n    { return s.containsAll(c); }\n    public boolean addAll(Collection<? extends E> c)\n    { return s.addAll(c); }\n    public boolean removeAll(Collection<?> c)\n    { return s.removeAll(c); }\n    public boolean retainAll(Collection<?> c)\n    { return s.retainAll(c); }\n    public Object[] toArray() { return s.toArray(); }\n    public <T> T[] toArray(T[] a) { return s.toArray(a); }\n\n    @Override\n    public boolean equals(Object o){ return s.equals(o); }\n\n    @Override\n    public int hashCode() { return s.hashCode(); }\n\n    @Override\n    public String toString() { return s.toString(); }\n}\n")),(0,s.kt)("p",null,"The design of the InstrumentedSet class is enabled by the existence of the Set interface, which captures the functionality of the HashSet class. Besides being robust, this design is extremely flexible. The InstrumentedSet class implements the Set interface and has a single constructor whose argument is also of type Set. In essence, the class transforms one Set into another, adding the instrumentation functionality. Unlike the inheritance-based approach, which works only for a single concrete class and requires a separate constructor for each supported constructor in the superclass, the wrapper class can be used to instrument any Set implementation and will work in conjunction with any preexisting constructor:"),(0,s.kt)("p",null,"InstrumentedSet \u7c7b\u7684\u8bbe\u8ba1\u662f\u901a\u8fc7 Set \u63a5\u53e3\u6765\u5b9e\u73b0\u7684\uff0c\u8fd9\u4e2a\u63a5\u53e3\u53ef\u4ee5\u6355\u83b7 HashSet \u7c7b\u7684\u529f\u80fd\u3002\u9664\u4e86\u5065\u58ee\u5916\uff0c\u8fd9\u4e2a\u8bbe\u8ba1\u975e\u5e38\u7075\u6d3b\u3002InstrumentedSet \u7c7b\u5b9e\u73b0\u4e86 Set \u63a5\u53e3\uff0c\u5e76\u4e14\u6709\u4e00\u4e2a\u53c2\u6570\u4e5f\u662f Set \u7c7b\u578b\u7684\u6784\u9020\u51fd\u6570\u3002\u5b9e\u9645\u4e0a\uff0c\u8be5\u7c7b\u5177\u6709\u300c\u63d2\u88c5\u300d\u529f\u80fd\uff0c\u53ef\u95f4\u63a5\u5c06\u4e00\u79cd Set \u7684\u8f6c\u5316\u4e3a\u53e6\u4e00\u79cd Set\u3002\u57fa\u4e8e\u7ee7\u627f\u7684\u65b9\u6cd5\u53ea\u9002\u7528\u4e8e\u5355\u4e2a\u5177\u4f53\u7c7b\uff0c\u5e76\u4e14\u9700\u8981\u4e3a\u8d85\u7c7b\u4e2d\u6bcf\u4e2a\u53d7\u652f\u6301\u7684\u6784\u9020\u51fd\u6570\u63d0\u4f9b\u5355\u72ec\u7684\u6784\u9020\u51fd\u6570\uff0c\u4e0e\u6b64\u4e0d\u540c\u7684\u662f\uff0c\u5305\u88c5\u5668\u7c7b\u53ef\u7528\u4e8e\u63d2\u88c5\u4efb\u4f55 Set \u5b9e\u73b0\uff0c\u5e76\u5c06\u4e0e\u4efb\u4f55\u73b0\u6709\u6784\u9020\u51fd\u6570\u4e00\u8d77\u5de5\u4f5c\uff1a"),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"\u8bd1\u6ce8\uff1ainstrumentation \u8bd1\u4e3a\u300c\u63d2\u88c5\u300d\uff0c\u7c7b\u6bd4\u786c\u76d8\uff08Set\uff09\u63d2\u88c5\u5230\u4e3b\u677f\uff08ForwardingSet\uff09\uff0c\u65e0\u8bba\u786c\u76d8\u5982\u4f55\u66f4\u65b0\u6362\u4ee3\uff0c\u4f46\u662f\u7528\u4e8e\u5b58\u50a8\u7684\u529f\u80fd\u4e0d\u4f1a\u53d8\u3002\u5916\u8bbe\uff08\u5ba2\u6237\u7aef\uff09\u901a\u8fc7\u4e3b\u677f\u7684 USB2.0 \u53e3\uff08InstrumentedSet2.0\uff09\u6216 USB3.0 \u53e3\uff08InstrumentedSet3.0\uff09\uff0c\u4e0e\u786c\u76d8\u4ea4\u4e92\uff0c\u4f7f\u7528\u5176\u5b58\u50a8\u529f\u80fd\u3002")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"Set<Instant> times = new InstrumentedSet<>(new TreeSet<>(cmp));\nSet<E> s = new InstrumentedSet<>(new HashSet<>(INIT_CAPACITY));\n")),(0,s.kt)("p",null,"The InstrumentedSet class can even be used to temporarily instrument a set instance that has already been used without instrumentation:"),(0,s.kt)("p",null,"InstrumentedSet \u7c7b\u751a\u81f3\u8fd8\u53ef\u4ee5\u7528\u6765\u4e34\u65f6\u914d\u7f6e\u4e00\u4e2a\u6ca1\u6709\u300c\u63d2\u88c5\u300d\u529f\u80fd\u7684 Set \u5b9e\u4f8b\uff1a"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"static void walk(Set<Dog> dogs) {\nInstrumentedSet<Dog> iDogs = new InstrumentedSet<>(dogs);\n... // Within this method use iDogs instead of dogs\n}\n")),(0,s.kt)("p",null,"The InstrumentedSet class is known as a wrapper class because each InstrumentedSet instance contains (\u201cwraps\u201d) another Set instance. This is also known as the Decorator pattern ","[Gamma95]"," because the InstrumentedSet class \u201cdecorates\u201d a set by adding instrumentation. Sometimes the combination of composition and forwarding is loosely referred to as delegation. Technically it\u2019s not delegation unless the wrapper object passes itself to the wrapped object ","[Lieberman86; Gamma95]","."),(0,s.kt)("p",null,"InstrumentedSet \u7c7b\u88ab\u79f0\u4e3a\u5305\u88c5\u5668\u7c7b\uff0c\u56e0\u4e3a\u6bcf\u4e2a InstrumentedSet \u5b9e\u4f8b\u90fd\u5305\u542b\uff08\u300c\u5305\u88c5\u300d\uff09\u4e86\u53e6\u4e00\u4e2a Set \u5b9e\u4f8b\u3002\u8fd9\u4e5f\u79f0\u4e3a\u88c5\u9970\u8005\u6a21\u5f0f ","[Gamma95]","\uff0c\u56e0\u4e3a InstrumentedSet \u7c7b\u901a\u8fc7\u6dfb\u52a0\u300c\u63d2\u88c5\u300d\u6765\u300c\u88c5\u9970\u300d\u4e00\u4e2a\u96c6\u5408\u3002\u6709\u65f6\u590d\u5408\u548c\u8f6c\u53d1\u7684\u7ec4\u5408\u88ab\u4e0d\u5f53\u5730\u79f0\u4e3a\u59d4\u6258\u3002\u4e25\u683c\u6765\u8bf4\uff0c\u9664\u975e\u5305\u88c5\u5668\u5bf9\u8c61\u5c06\u81ea\u8eab\u4f20\u9012\u7ed9\u5305\u88c5\u5bf9\u8c61\uff0c\u5426\u5219\u5b83\u4e0d\u662f\u59d4\u6258 ","[Lieberman86; Gamma95]","\u3002"),(0,s.kt)("p",null,"The disadvantages of wrapper classes are few. One caveat is that wrapper classes are not suited for use in callback frameworks, wherein objects pass selfreferences to other objects for subsequent invocations (\u201ccallbacks\u201d). Because a wrapped object doesn\u2019t know of its wrapper, it passes a reference to itself (this) and callbacks elude the wrapper. This is known as the SELF problem ","[Lieberman86]",". Some people worry about the performance impact of forwarding method invocations or the memory footprint impact of wrapper objects. Neither turn out to have much impact in practice. It\u2019s tedious to write forwarding methods, but you have to write the reusable forwarding class for each interface only once, and forwarding classes may be provided for you. For example, Guava provides forwarding classes for all of the collection interfaces ","[Guava]","."),(0,s.kt)("p",null,"\u5305\u88c5\u5668\u7c7b\u7684\u7f3a\u70b9\u5f88\u5c11\u3002\u4e00\u4e2a\u9700\u8981\u6ce8\u610f\u7684\u70b9\u662f\uff1a\u5305\u88c5\u5668\u7c7b\u4e0d\u9002\u5408\u5728\u56de\u8c03\u6846\u67b6\u4e2d\u4f7f\u7528\uff0c\u5728\u56de\u8c03\u6846\u67b6\u4e2d\uff0c\u5bf9\u8c61\u4e3a\u540e\u7eed\u8c03\u7528(\u300c\u56de\u8c03\u300d)\u5c06\u81ea\u5b9a\u4e49\u4f20\u9012\u7ed9\u5176\u4ed6\u5bf9\u8c61\u3002\u56e0\u4e3a\u5305\u88c5\u5bf9\u8c61\u4e0d\u77e5\u9053\u5b83\u5bf9\u5e94\u7684\u5305\u88c5\u5668\uff0c\u6240\u4ee5\u5b83\u4f20\u9012\u4e00\u4e2a\u5bf9\u5b83\u81ea\u5df1\u7684\u5f15\u7528\uff08this\uff09\uff0c\u56de\u8c03\u907f\u5f00\u5305\u88c5\u5668\u3002\u8fd9\u5c31\u662f\u6240\u8c13\u7684\u300c\u81ea\u7528\u300d\u95ee\u9898\u3002\u6709\u4e9b\u4eba\u62c5\u5fc3\u8f6c\u53d1\u65b9\u6cd5\u8c03\u7528\u7684\u6027\u80fd\u5f71\u54cd\u6216\u5305\u88c5\u5668\u5bf9\u8c61\u7684\u5185\u5b58\u5360\u7528\u5f71\u54cd\u3002\u8fd9\u4e24\u79cd\u65b9\u6cd5\u5728\u5b9e\u8df5\u4e2d\u90fd\u6ca1\u6709\u591a\u5927\u5f71\u54cd\u3002\u7f16\u5199\u8f6c\u53d1\u65b9\u6cd5\u5f88\u9ebb\u70e6\uff0c\u4f46\u662f\u4f60\u5fc5\u987b\u53ea\u4e3a\u6bcf\u4e2a\u63a5\u53e3\u7f16\u5199\u4e00\u6b21\u53ef\u590d\u7528\u7684\u8f6c\u53d1\u7c7b\uff0c\u800c\u4e14\u53ef\u80fd\u4f1a\u4e3a\u4f60\u63d0\u4f9b\u8f6c\u53d1\u7c7b\u3002\u4f8b\u5982\uff0cGuava \u4e3a\u6240\u6709\u7684\u96c6\u5408\u63a5\u53e3\u63d0\u4f9b\u4e86\u8f6c\u53d1\u7c7b ","[Guava]","\u3002"),(0,s.kt)("p",null,"Inheritance is appropriate only in circumstances where the subclass really is a subtype of the superclass. In other words, a class B should extend a class A only if an \u201cis-a\u201d relationship exists between the two classes. If you are tempted to have a class B extend a class A, ask yourself the question: Is every B really an A? If you cannot truthfully answer yes to this question, B should not extend A. If the answer is no, it is often the case that B should contain a private instance of A and expose a different API: A is not an essential part of B, merely a detail of its implementation."),(0,s.kt)("p",null,"\u53ea\u6709\u5b50\u7c7b\u786e\u5b9e\u662f\u8d85\u7c7b\u7684\u5b50\u7c7b\u578b\u7684\u60c5\u51b5\u4e0b\uff0c\u7ee7\u627f\u624d\u5408\u9002\u3002\u6362\u53e5\u8bdd\u8bf4\uff0c\u4e24\u4e2a\u7c7b A\u3001B \u4e4b\u95f4\u53ea\u6709 B \u6ee1\u8db3\u300cis-a\u300d\u5173\u7cfb\u65f6\u624d\u5e94\u8be5\u6269\u5c55 A\u3002\u5982\u679c\u4f60\u60f3\u8ba9 B \u6269\u5c55 A\uff0c\u90a3\u5c31\u95ee\u95ee\u81ea\u5df1\uff1a\u6bcf\u4e2a B \u90fd\u662f A \u5417\uff1f\u5982\u679c\u4e0d\u80fd\u5bf9\u8fd9\u4e2a\u95ee\u9898\u7ed9\u51fa\u80af\u5b9a\u56de\u7b54\uff0cB \u4e0d\u5e94\u8be5\u6269\u5c55 A\uff1b\u5982\u679c\u7b54\u6848\u662f\u5426\u5b9a\u7684\uff0c\u901a\u5e38\u60c5\u51b5\u4e0b\uff0cB \u5e94\u8be5\u5305\u542b A \u7684\u79c1\u6709\u5b9e\u4f8b\u5e76\u66b4\u9732\u4e0d\u540c\u7684 API\uff1aA \u4e0d\u662f B \u7684\u57fa\u672c\u7ec4\u6210\u90e8\u5206\uff0c\u800c\u4ec5\u4ec5\u662f\u5176\u5b9e\u73b0\u7684\u4e00\u4e2a\u7ec6\u8282\u3002"),(0,s.kt)("p",null,"There are a number of obvious violations of this principle in the Java platform libraries. For example, a stack is not a vector, so Stack should not extend Vector. Similarly, a property list is not a hash table, so Properties should not extend Hashtable. In both cases, composition would have been preferable."),(0,s.kt)("p",null,"\u5728 Java \u5e93\u4e2d\u6709\u8bb8\u591a\u660e\u663e\u8fdd\u53cd\u8fd9\u4e00\u539f\u5219\u7684\u5730\u65b9\u3002\u4f8b\u5982\uff0cstack \u4e0d\u662f vector\uff0c\u56e0\u6b64 Stack \u4e0d\u5e94\u8be5\u7ee7\u627f Vector\u3002\u7c7b\u4f3c\u5730\uff0cproperty \u5217\u8868\u4e0d\u662f hash \u8868\uff0c\u56e0\u6b64 Properties \u4e0d\u5e94\u8be5\u7ee7\u627f Hashtable\u3002\u5728\u8fd9\u4e24\u79cd\u60c5\u51b5\u4e0b\uff0c\u590d\u5408\u90fd\u662f\u53ef\u53d6\u7684\u3002"),(0,s.kt)("p",null,"If you use inheritance where composition is appropriate, you needlessly expose implementation details. The resulting API ties you to the original implementation, forever limiting the performance of your class. More seriously,by exposing the internals you let clients access them directly. At the very least, it can lead to confusing semantics. For example, if p refers to a Properties instance, then p.getProperty(key) may yield different results from p.get(key): the former method takes defaults into account, while the latter method, which is inherited from Hashtable, does not. Most seriously, the client may be able to corrupt invariants of the subclass by modifying the superclass directly. In the case of Properties, the designers intended that only strings be allowed as keys and values, but direct access to the underlying Hashtable allows this invariant to be violated. Once violated, it is no longer possible to use other parts of the Properties API (load and store). By the time this problem was discovered, it was too late to correct it because clients depended on the use of non-string keys and values."),(0,s.kt)("p",null,"\u5982\u679c\u5728\u590d\u5408\u9002\u7528\u7684\u5730\u65b9\u4f7f\u7528\u4e86\u7ee7\u627f\uff0c\u5c31\u4f1a\u4e0d\u5fc5\u8981\u5730\u66b4\u9732\u5b9e\u73b0\u7ec6\u8282\u3002\u751f\u6210\u7684 API \u5c06\u4f60\u4e0e\u539f\u59cb\u5b9e\u73b0\u7ed1\u5b9a\u5728\u4e00\u8d77\uff0c\u6c38\u8fdc\u9650\u5236\u4e86\u7c7b\u7684\u6027\u80fd\u3002\u66f4\u4e25\u91cd\u7684\u662f\uff0c\u901a\u8fc7\u66b4\u9732\u5185\u90e8\u7ec4\u4ef6\uff0c\u4f60\u53ef\u4ee5\u8ba9\u5ba2\u6237\u7aef\u76f4\u63a5\u8bbf\u95ee\u5b83\u4eec\u3002\u81f3\u5c11\uff0c\u5b83\u4f1a\u5bfc\u81f4\u8bed\u4e49\u6df7\u4e71\u3002\u4f8b\u5982\uff0c\u5982\u679c p \u5f15\u7528\u4e86\u4e00\u4e2a Properties \u7c7b\u7684\u5b9e\u4f8b\uff0c\u90a3\u4e48 ",(0,s.kt)("inlineCode",{parentName:"p"},"p.getProperty(key)")," \u53ef\u80fd\u4f1a\u4ea7\u751f\u4e0e ",(0,s.kt)("inlineCode",{parentName:"p"},"p.get(key)")," \u4e0d\u540c\u7684\u7ed3\u679c\uff1a\u524d\u8005\u8003\u8651\u4e86\u9ed8\u8ba4\u503c\uff0c\u800c\u540e\u8005\uff08\u4ece Hashtable \u7ee7\u627f\u800c\u6765\uff09\u5219\u4e0d\u4f1a\u3002\u6700\u4e25\u91cd\u7684\u662f\uff0c\u5ba2\u6237\u7aef\u53ef\u4ee5\u901a\u8fc7\u76f4\u63a5\u4fee\u6539\u8d85\u7c7b\u6765\u7834\u574f\u5b50\u7c7b\u7684\u4e0d\u53d8\u91cf\u3002\u5bf9\u4e8e Properties \u7c7b\uff0c\u8bbe\u8ba1\u8005\u5e0c\u671b\u53ea\u5141\u8bb8\u5b57\u7b26\u4e32\u4f5c\u4e3a\u952e\u548c\u503c\uff0c\u4f46\u662f\u76f4\u63a5\u8bbf\u95ee\u5e95\u5c42 Hashtable \u5141\u8bb8\u8fdd\u53cd\u8fd9\u4e2a\u4e0d\u53d8\u6027\u3002\u4e00\u65e6\u8fdd\u53cd\uff0c\u5c31\u4e0d\u518d\u53ef\u80fd\u4f7f\u7528 Properties API \u7684\u5176\u4ed6\u90e8\u5206\uff08\u52a0\u8f7d\u548c\u5b58\u50a8\uff09\u3002\u5f53\u53d1\u73b0\u8fd9\u4e2a\u95ee\u9898\u65f6\uff0c\u5df2\u7ecf\u6765\u4e0d\u53ca\u7ea0\u6b63\u4e86\uff0c\u56e0\u4e3a\u5ba2\u6237\u7aef\u4f9d\u8d56\u4e8e\u975e\u5b57\u7b26\u4e32\u952e\u548c\u503c\u7684\u4f7f\u7528\u3002"),(0,s.kt)("p",null,"There is one last set of questions you should ask yourself before deciding to use inheritance in place of composition. Does the class that you contemplate extending have any flaws in its API? If so, are you comfortable propagating those flaws into your class\u2019s API? Inheritance propagates any flaws in the superclass\u2019s API, while composition lets you design a new API that hides these flaws."),(0,s.kt)("p",null,"\u5728\u51b3\u5b9a\u4f7f\u7528\u7ee7\u627f\u800c\u4e0d\u662f\u590d\u5408\u4e4b\u524d\uff0c\u4f60\u5e94\u8be5\u95ee\u81ea\u5df1\u6700\u540e\u4e00\u7ec4\u95ee\u9898\u3002\u4f60\u6253\u7b97\u6269\u5c55\u7684\u7c7b\u5728\u5176 API \u4e2d\u6709\u4efb\u4f55\u7f3a\u9677\u5417\uff1f\u5982\u679c\u662f\u8fd9\u6837\uff0c\u4f60\u662f\u5426\u613f\u610f\u5c06\u8fd9\u4e9b\u7f3a\u9677\u4f20\u64ad\u5230\u7c7b\u7684 API \u4e2d\uff1f\u7ee7\u627f\u4f20\u64ad\u8d85\u7c7b API \u4e2d\u7684\u4efb\u4f55\u7f3a\u9677\uff0c\u800c\u590d\u5408\u5141\u8bb8\u4f60\u8bbe\u8ba1\u4e00\u4e2a\u65b0\u7684 API \u6765\u9690\u85cf\u8fd9\u4e9b\u7f3a\u9677\u3002"),(0,s.kt)("p",null,"To summarize, inheritance is powerful, but it is problematic because it violates encapsulation. It is appropriate only when a genuine subtype relationship exists between the subclass and the superclass. Even then, inheritance may lead to fragility if the subclass is in a different package from the superclass and the superclass is not designed for inheritance. To avoid this fragility, use composition and forwarding instead of inheritance, especially if an appropriate interface to implement a wrapper class exists. Not only are wrapper classes more robust than subclasses, they are also more powerful."),(0,s.kt)("p",null,"\u603b\u800c\u8a00\u4e4b\uff0c\u7ee7\u627f\u662f\u5f3a\u5927\u7684\uff0c\u4f46\u662f\u5b83\u662f\u6709\u95ee\u9898\u7684\uff0c\u56e0\u4e3a\u5b83\u6253\u7834\u4e86\u5c01\u88c5\u3002\u53ea\u6709\u5f53\u5b50\u7c7b\u548c\u8d85\u7c7b\u4e4b\u95f4\u5b58\u5728\u771f\u6b63\u7684\u5b50\u7c7b\u578b\u5173\u7cfb\u65f6\u624d\u5408\u9002\u3002\u5373\u4f7f\u8fd9\u6837\uff0c\u5982\u679c\u5b50\u7c7b\u4e0e\u8d85\u7c7b\u5728\u4e0d\u540c\u7684\u5305\u4e2d\uff0c\u5e76\u4e14\u8d85\u7c7b\u4e0d\u662f\u4e3a\u7ee7\u627f\u800c\u8bbe\u8ba1\u7684\uff0c\u7ee7\u627f\u4e5f\u53ef\u80fd\u5bfc\u81f4\u7a0b\u5e8f\u8106\u5f31\u3002\u4e3a\u4e86\u907f\u514d\u8fd9\u79cd\u7f3a\u9677\uff0c\u5e94\u4f7f\u7528\u590d\u5408\u548c\u8f6c\u53d1\uff0c\u7279\u522b\u662f\u5b58\u5728\u9002\u5f53\u63a5\u53e3\u80fd\u5b9e\u73b0\u5305\u88c5\u5668\u7c7b\u65f6\u66f4\u5e94\u5982\u6b64\u3002\u5305\u88c5\u7c7b\u4e0d\u4ec5\u6bd4\u5b50\u7c7b\u66f4\u5065\u58ee\uff0c\u800c\u4e14\u529f\u80fd\u66f4\u5f3a\u5927\u3002"),(0,s.kt)("hr",null),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},(0,s.kt)("a",{parentName:"strong",href:"./Chapter-4-Introduction"},"Back to contents of the chapter\uff08\u8fd4\u56de\u7ae0\u8282\u76ee\u5f55\uff09"))),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Previous Item\uff08\u4e0a\u4e00\u6761\u76ee\uff09\uff1a",(0,s.kt)("a",{parentName:"strong",href:"./Chapter-4-Item-17-Minimize-mutability"},"Item 17: Minimize mutability\uff08\u51cf\u5c11\u53ef\u53d8\u6027\uff09"))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Next Item\uff08\u4e0b\u4e00\u6761\u76ee\uff09\uff1a",(0,s.kt)("a",{parentName:"strong",href:"./Chapter-4-Item-19-Design-and-document-for-inheritance-or-else-prohibit-it"},"Item 19: Design and document for inheritance or else prohibit it\uff08\u7ee7\u627f\u8981\u8bbe\u8ba1\u826f\u597d\u5e76\u4e14\u5177\u6709\u6587\u6863\uff0c\u5426\u5219\u7981\u6b62\u4f7f\u7528\uff09")))))}h.isMDXComponent=!0}}]);