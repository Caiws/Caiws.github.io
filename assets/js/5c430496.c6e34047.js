"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1722],{3905:(e,t,n)=>{n.d(t,{Zo:()=>l,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=a.createContext({}),c=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},l=function(e){var t=c(e.components);return a.createElement(p.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,p=e.parentName,l=o(e,["components","mdxType","originalType","parentName"]),h=c(n),m=r,y=h["".concat(p,".").concat(m)]||h[m]||u[m]||i;return n?a.createElement(y,s(s({ref:t},l),{},{components:n})):a.createElement(y,s({ref:t},l))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,s=new Array(i);s[0]=h;var o={};for(var p in t)hasOwnProperty.call(t,p)&&(o[p]=t[p]);o.originalType=e,o.mdxType="string"==typeof e?e:r,s[1]=o;for(var c=2;c<i;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},1060:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>s,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var a=n(7462),r=(n(7294),n(3905));const i={},s=void 0,o={unversionedId:"Books/EffectiveJava3/Chapter-5/Chapter-5-Item-29-Favor-generic-types",id:"Books/EffectiveJava3/Chapter-5/Chapter-5-Item-29-Favor-generic-types",title:"Chapter-5-Item-29-Favor-generic-types",description:"Chapter 5. Generics\uff08\u6cdb\u578b\uff09",source:"@site/docs/Books/EffectiveJava3/Chapter-5/Chapter-5-Item-29-Favor-generic-types.md",sourceDirName:"Books/EffectiveJava3/Chapter-5",slug:"/Books/EffectiveJava3/Chapter-5/Chapter-5-Item-29-Favor-generic-types",permalink:"/docs/Books/EffectiveJava3/Chapter-5/Chapter-5-Item-29-Favor-generic-types",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Books/EffectiveJava3/Chapter-5/Chapter-5-Item-29-Favor-generic-types.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Chapter-5-Item-28-Prefer-lists-to-arrays",permalink:"/docs/Books/EffectiveJava3/Chapter-5/Chapter-5-Item-28-Prefer-lists-to-arrays"},next:{title:"Chapter-5-Item-30-Favor-generic-methods",permalink:"/docs/Books/EffectiveJava3/Chapter-5/Chapter-5-Item-30-Favor-generic-methods"}},p={},c=[{value:"Chapter 5. Generics\uff08\u6cdb\u578b\uff09",id:"chapter-5-generics\u6cdb\u578b",level:2},{value:"Item 29: Favor generic types\uff08\u4f18\u5148\u4f7f\u7528\u6cdb\u578b\uff09",id:"item-29-favor-generic-types\u4f18\u5148\u4f7f\u7528\u6cdb\u578b",level:3}],l={toc:c};function u(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"chapter-5-generics\u6cdb\u578b"},"Chapter 5. Generics\uff08\u6cdb\u578b\uff09"),(0,r.kt)("h3",{id:"item-29-favor-generic-types\u4f18\u5148\u4f7f\u7528\u6cdb\u578b"},"Item 29: Favor generic types\uff08\u4f18\u5148\u4f7f\u7528\u6cdb\u578b\uff09"),(0,r.kt)("p",null,"It is generally not too difficult to parameterize your declarations and make use of the generic types and methods provided by the JDK. Writing your own generic types is a bit more difficult, but it\u2019s worth the effort to learn how."),(0,r.kt)("p",null,"\u901a\u5e38\uff0c\u5bf9\u58f0\u660e\u8fdb\u884c\u53c2\u6570\u5316\u5e76\u4f7f\u7528 JDK \u63d0\u4f9b\u7684\u6cdb\u578b\u548c\u65b9\u6cd5\u5e76\u4e0d\u592a\u96be\u3002\u7f16\u5199\u81ea\u5df1\u7684\u6cdb\u578b\u6709\u70b9\u56f0\u96be\uff0c\u4f46\u662f\u503c\u5f97\u52aa\u529b\u5b66\u4e60\u3002"),(0,r.kt)("p",null,"Consider the simple (toy) stack implementation from Item 7:"),(0,r.kt)("p",null,"\u8003\u8651 ",(0,r.kt)("a",{parentName:"p",href:"./Chapter-2-Item-7-Eliminate-obsolete-object-references"},"Item-7")," \u4e2d\u7b80\u5355\u7684\u5806\u6808\u5b9e\u73b0\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"// Object-based collection - a prime candidate for generics\npublic class Stack {\n    private Object[] elements;\n    private int size = 0;\n    private static final int DEFAULT_INITIAL_CAPACITY = 16;\n\n    public Stack() {\n        elements = new Object[DEFAULT_INITIAL_CAPACITY];\n    }\n\n    public void push(Object e) {\n        ensureCapacity();\n        elements[size++] = e;\n    }\n\n    public Object pop() {\n        if (size == 0)\n            throw new EmptyStackException();\n        Object result = elements[--size];\n        elements[size] = null; // Eliminate obsolete reference\n        return result;\n    }\n\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    private void ensureCapacity() {\n        if (elements.length == size)\n            elements = Arrays.copyOf(elements, 2 * size + 1);\n    }\n}\n")),(0,r.kt)("p",null,"This class should have been parameterized to begin with, but since it wasn\u2019t, we can generify it after the fact. In other words, we can parameterize it without harming clients of the original non-parameterized version. As it stands, the client has to cast objects that are popped off the stack, and those casts might fail at runtime. The first step in generifying a class is to add one or more type parameters to its declaration. In this case there is one type parameter, representing the element type of the stack, and the conventional name for this type parameter is E (Item 68)."),(0,r.kt)("p",null,"\u8fd9\u4e2a\u7c7b\u4e00\u5f00\u59cb\u5c31\u5e94\u8be5\u662f\u53c2\u6570\u5316\u7684\uff0c\u4f46\u662f\u56e0\u4e3a\u5b83\u4e0d\u662f\u53c2\u6570\u5316\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u5728\u4e8b\u540e\u5bf9\u5b83\u8fdb\u884c\u6cdb\u5316\u3002\u6362\u53e5\u8bdd\u8bf4\uff0c\u6211\u4eec\u53ef\u4ee5\u5bf9\u5b83\u8fdb\u884c\u53c2\u6570\u5316\uff0c\u800c\u4e0d\u4f1a\u635f\u5bb3\u539f\u59cb\u975e\u53c2\u6570\u5316\u7248\u672c\u7684\u5ba2\u6237\u7aef\u3002\u6309\u7167\u76ee\u524d\u7684\u60c5\u51b5\uff0c\u5ba2\u6237\u7aef\u5fc5\u987b\u8f6c\u6362\u4ece\u5806\u6808\u4e2d\u5f39\u51fa\u7684\u5bf9\u8c61\uff0c\u800c\u8fd9\u4e9b\u8f6c\u6362\u53ef\u80fd\u5728\u8fd0\u884c\u65f6\u5931\u8d25\u3002\u751f\u6210\u7c7b\u7684\u7b2c\u4e00\u6b65\u662f\u5411\u5176\u58f0\u660e\u4e2d\u6dfb\u52a0\u4e00\u4e2a\u6216\u591a\u4e2a\u7c7b\u578b\u53c2\u6570\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u6709\u4e00\u4e2a\u7c7b\u578b\u53c2\u6570\uff0c\u8868\u793a\u5806\u6808\u7684\u5143\u7d20\u7c7b\u578b\uff0c\u8fd9\u4e2a\u7c7b\u578b\u53c2\u6570\u7684\u5e38\u89c4\u540d\u79f0\u662f E\uff08",(0,r.kt)("a",{parentName:"p",href:"./Chapter-9-Item-68-Adhere-to-generally-accepted-naming-conventions"},"Item-68"),"\uff09\u3002"),(0,r.kt)("p",null,"The next step is to replace all the uses of the type Object with the appropriate type parameter and then try to compile the resulting program:"),(0,r.kt)("p",null,"\u4e0b\u4e00\u6b65\u662f\u7528\u9002\u5f53\u7684\u7c7b\u578b\u53c2\u6570\u66ff\u6362\u6240\u6709\u7684 Object \u7c7b\u578b\uff0c\u7136\u540e\u5c1d\u8bd5\u7f16\u8bd1\u4fee\u6539\u540e\u7684\u7a0b\u5e8f\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"// Initial attempt to generify Stack - won't compile!\npublic class Stack<E> {\n    private E[] elements;\n    private int size = 0;\n    private static final int DEFAULT_INITIAL_CAPACITY = 16;\n\n    public Stack() {\n        elements = new E[DEFAULT_INITIAL_CAPACITY];\n    }\n\n    public void push(E e) {\n        ensureCapacity();\n        elements[size++] = e;\n    }\n\n    public E pop() {\n        if (size == 0)\n            throw new EmptyStackException();\n        E result = elements[--size];\n        elements[size] = null; // Eliminate obsolete reference\n        return result;\n    } ... // no changes in isEmpty or ensureCapacity\n}\n")),(0,r.kt)("p",null,"You\u2019ll generally get at least one error or warning, and this class is no exception. Luckily, this class generates only one error:"),(0,r.kt)("p",null,"\u901a\u5e38\u81f3\u5c11\u4f1a\u5f97\u5230\u4e00\u4e2a\u9519\u8bef\u6216\u8b66\u544a\uff0c\u8fd9\u4e2a\u7c7b\u4e5f\u4e0d\u4f8b\u5916\u3002\u5e78\u8fd0\u7684\u662f\uff0c\u8fd9\u4e2a\u7c7b\u53ea\u751f\u6210\u4e00\u4e2a\u9519\u8bef\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Stack.java:8: generic array creation\nelements = new E[DEFAULT_INITIAL_CAPACITY];\n^\n")),(0,r.kt)("p",null,"As explained in Item 28, you can\u2019t create an array of a non-reifiable type, such as E. This problem arises every time you write a generic type that is backed by an array. There are two reasonable ways to solve it. The first solution directly circumvents the prohibition on generic array creation: create an array of Object and cast it to the generic array type. Now in place of an error, the compiler will emit a warning. This usage is legal, but it\u2019s not (in general) typesafe:"),(0,r.kt)("p",null,"\u6b63\u5982 ",(0,r.kt)("a",{parentName:"p",href:"./Chapter-5-Item-28-Prefer-lists-to-arrays"},"Item-28")," \u4e2d\u6240\u89e3\u91ca\u7684\uff0c\u4f60\u4e0d\u80fd\u521b\u5efa\u975e\u5177\u4f53\u5316\u7c7b\u578b\u7684\u6570\u7ec4\uff0c\u4f8b\u5982 E\u3002\u6bcf\u5f53\u4f60\u7f16\u5199\u7531\u6570\u7ec4\u652f\u6301\u7684\u6cdb\u578b\u65f6\uff0c\u5c31\u4f1a\u51fa\u73b0\u8fd9\u4e2a\u95ee\u9898\u3002\u6709\u4e24\u79cd\u5408\u7406\u7684\u65b9\u6cd5\u6765\u89e3\u51b3\u5b83\u3002\u7b2c\u4e00\u4e2a\u89e3\u51b3\u65b9\u6848\u76f4\u63a5\u7ed5\u8fc7\u4e86\u521b\u5efa\u6cdb\u578b\u6570\u7ec4\u7684\u7981\u4ee4\uff1a\u521b\u5efa\u5bf9\u8c61\u6570\u7ec4\u5e76\u5c06\u5176\u5f3a\u5236\u8f6c\u6362\u4e3a\u6cdb\u578b\u6570\u7ec4\u7c7b\u578b\u3002\u73b0\u5728\uff0c\u7f16\u8bd1\u5668\u5c06\u53d1\u51fa\u4e00\u4e2a\u8b66\u544a\u6765\u4ee3\u66ff\u9519\u8bef\u3002\u8fd9\u79cd\u7528\u6cd5\u662f\u5408\u6cd5\u7684\uff0c\u4f46\uff08\u4e00\u822c\u800c\u8a00\uff09\u5b83\u4e0d\u662f\u7c7b\u578b\u5b89\u5168\u7684\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Stack.java:8: warning: [unchecked] unchecked cast\nfound: Object[], required: E[]\nelements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY];\n^\n")),(0,r.kt)("p",null,"The compiler may not be able to prove that your program is typesafe, but you can. You must convince yourself that the unchecked cast will not compromise the type safety of the program. The array in question (elements) is stored in a private field and never returned to the client or passed to any other method. The only elements stored in the array are those passed to the push method, which are of type E, so the unchecked cast can do no harm."),(0,r.kt)("p",null,"\u7f16\u8bd1\u5668\u53ef\u80fd\u65e0\u6cd5\u8bc1\u660e\u4f60\u7684\u7a0b\u5e8f\u662f\u7c7b\u578b\u5b89\u5168\u7684\uff0c\u4f46\u4f60\u53ef\u4ee5\u3002\u4f60\u5fc5\u987b\u8bf4\u670d\u81ea\u5df1\uff0cunchecked \u7684\u8f6c\u6362\u4e0d\u4f1a\u635f\u5bb3\u7a0b\u5e8f\u7684\u7c7b\u578b\u5b89\u5168\u6027\u3002\u6240\u6d89\u53ca\u7684\u6570\u7ec4\uff08\u5143\u7d20\uff09\u5b58\u50a8\u5728\u79c1\u6709\u5b57\u6bb5\u4e2d\uff0c\u4ece\u672a\u8fd4\u56de\u7ed9\u5ba2\u6237\u7aef\u6216\u4f20\u9012\u7ed9\u4efb\u4f55\u5176\u4ed6\u65b9\u6cd5\u3002\u6570\u7ec4\u4e2d\u5b58\u50a8\u7684\u60df\u4e00\u5143\u7d20\u662f\u4f20\u9012\u7ed9 push \u65b9\u6cd5\u7684\u5143\u7d20\uff0c\u5b83\u4eec\u5c5e\u4e8e E \u7c7b\u578b\uff0c\u56e0\u6b64 unchecked \u7684\u8f6c\u6362\u4e0d\u4f1a\u9020\u6210\u4efb\u4f55\u635f\u5bb3\u3002"),(0,r.kt)("p",null,"Once you\u2019ve proved that an unchecked cast is safe, suppress the warning in as narrow a scope as possible (Item 27). In this case, the constructor contains only the unchecked array creation, so it\u2019s appropriate to suppress the warning in the entire constructor. With the addition of an annotation to do this, Stack compiles cleanly, and you can use it without explicit casts or fear of a ClassCastException:"),(0,r.kt)("p",null,"\u4e00\u65e6\u4f60\u8bc1\u660e\u4e86 unchecked \u7684\u8f6c\u6362\u662f\u5b89\u5168\u7684\uff0c\u5c31\u5c06\u8b66\u544a\u9650\u5236\u5728\u5c3d\u53ef\u80fd\u5c0f\u7684\u8303\u56f4\u5185\uff08",(0,r.kt)("a",{parentName:"p",href:"./Chapter-5-Item-27-Eliminate-unchecked-warnings"},"Item-27"),"\uff09\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u6784\u9020\u51fd\u6570\u53ea\u5305\u542b unchecked \u7684\u6570\u7ec4\u521b\u5efa\uff0c\u56e0\u6b64\u5728\u6574\u4e2a\u6784\u9020\u51fd\u6570\u4e2d\u53d6\u6d88\u8b66\u544a\u662f\u5408\u9002\u7684\u3002\u901a\u8fc7\u6dfb\u52a0\u6ce8\u89e3\u6765\u5b9e\u73b0\u8fd9\u4e00\u70b9\uff0cStack \u53ef\u4ee5\u5e72\u51c0\u5730\u7f16\u8bd1\uff0c\u800c\u4e14\u4f60\u53ef\u4ee5\u4f7f\u7528\u5b83\u800c\u65e0\u9700\u663e\u5f0f\u5f3a\u5236\u8f6c\u6362\u6216\u62c5\u5fc3 ClassCastException\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'// The elements array will contain only E instances from push(E).\n// This is sufficient to ensure type safety, but the runtime\n// type of the array won\'t be E[]; it will always be Object[]!\n@SuppressWarnings("unchecked")\npublic Stack() {\n    elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY];\n}\n')),(0,r.kt)("p",null,"The second way to eliminate the generic array creation error in Stack is to change the type of the field elements from E[] to Object[]. If you do this, you\u2019ll get a different error:"),(0,r.kt)("p",null,"\u6d88\u9664 Stack \u4e2d\u6cdb\u578b\u6570\u7ec4\u521b\u5efa\u9519\u8bef\u7684\u7b2c\u4e8c\u79cd\u65b9\u6cd5\u662f\u5c06\u5b57\u6bb5\u5143\u7d20\u7684\u7c7b\u578b\u4ece E[] \u66f4\u6539\u4e3a Object[]\u3002\u5982\u679c\u4f60\u8fd9\u6837\u505a\uff0c\u4f60\u4f1a\u5f97\u5230\u4e00\u4e2a\u4e0d\u540c\u7684\u9519\u8bef\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Stack.java:19: incompatible types\nfound: Object, required: E\nE result = elements[--size];\n^\n")),(0,r.kt)("p",null,"You can change this error into a warning by casting the element retrieved from the array to E, but you will get a warning:"),(0,r.kt)("p",null,"\u901a\u8fc7\u5c06\u4ece\u6570\u7ec4\u4e2d\u68c0\u7d22\u5230\u7684\u5143\u7d20\u8f6c\u6362\u4e3a E\uff0c\u53ef\u4ee5\u5c06\u6b64\u9519\u8bef\u8f6c\u6362\u4e3a\u8b66\u544a\uff0c\u4f46\u4f60\u5c06\u5f97\u5230\u8b66\u544a\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Stack.java:19: warning: [unchecked] unchecked cast\nfound: Object, required: E\nE result = (E) elements[--size];\n^\n")),(0,r.kt)("p",null,"Because E is a non-reifiable type, there\u2019s no way the compiler can check the cast at runtime. Again, you can easily prove to yourself that the unchecked cast is safe, so it\u2019s appropriate to suppress the warning. In line with the advice of Item 27, we suppress the warning only on the assignment that contains the unchecked cast, not on the entire pop method:"),(0,r.kt)("p",null,"\u56e0\u4e3a E \u662f\u4e0d\u53ef\u5177\u4f53\u5316\u7684\u7c7b\u578b\uff0c\u7f16\u8bd1\u5668\u65e0\u6cd5\u5728\u8fd0\u884c\u65f6\u68c0\u67e5\u5f3a\u5236\u8f6c\u6362\u3002\u540c\u6837\uff0c\u4f60\u53ef\u4ee5\u5f88\u5bb9\u6613\u5730\u5411\u81ea\u5df1\u8bc1\u660e unchecked \u7684\u5f3a\u5236\u8f6c\u6362\u662f\u5b89\u5168\u7684\uff0c\u56e0\u6b64\u53ef\u4ee5\u9002\u5f53\u5730\u6291\u5236\u8b66\u544a\u3002\u6839\u636e ",(0,r.kt)("a",{parentName:"p",href:"./Chapter-5-Item-27-Eliminate-unchecked-warnings"},"Item-27")," \u7684\u5efa\u8bae\uff0c\u6211\u4eec\u4ec5\u5bf9\u5305\u542b unchecked \u5f3a\u5236\u8f6c\u6362\u7684\u8d4b\u503c\u7981\u7528\u8b66\u544a\uff0c\u800c\u4e0d\u662f\u5bf9\u6574\u4e2a pop \u65b9\u6cd5\u7981\u7528\u8b66\u544a\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'// Appropriate suppression of unchecked warning\npublic E pop() {\n    if (size == 0)\n        throw new EmptyStackException();\n    // push requires elements to be of type E, so cast is correct\n    @SuppressWarnings("unchecked")\n    E result =(E) elements[--size];\n    elements[size] = null; // Eliminate obsolete reference\n    return result;\n}\n')),(0,r.kt)("p",null,"Both techniques for eliminating the generic array creation have their adherents. The first is more readable: the array is declared to be of type E[], clearly indicating that it contains only E instances. It is also more concise: in a typical generic class, you read from the array at many points in the code; the first technique requires only a single cast (where the array is created), while the second requires a separate cast each time an array element is read. Thus, the first technique is preferable and more commonly used in practice. It does, however, cause heap pollution (Item 32): the runtime type of the array does not match its compile-time type (unless E happens to be Object). This makes some programmers sufficiently queasy that they opt for the second technique, though the heap pollution is harmless in this situation."),(0,r.kt)("p",null,"\u6d88\u9664\u6cdb\u578b\u6570\u7ec4\u521b\u5efa\u7684\u4e24\u79cd\u6280\u672f\u90fd\u6709\u5176\u8ffd\u968f\u8005\u3002\u7b2c\u4e00\u4e2a\u66f4\u5bb9\u6613\u8bfb\uff1a\u6570\u7ec4\u58f0\u660e\u4e3a E[] \u7c7b\u578b\uff0c\u8fd9\u6e05\u695a\u5730\u8868\u660e\u5b83\u53ea\u5305\u542b E \u7684\u5b9e\u4f8b\u3002\u5b83\u4e5f\u66f4\u7b80\u6d01\uff1a\u5728\u4e00\u4e2a\u5178\u578b\u7684\u6cdb\u578b\u7c7b\u4e2d\uff0c\u4ece\u6570\u7ec4\u4e2d\u8bfb\u53d6\u4ee3\u7801\u4e2d\u7684\u8bb8\u591a\u70b9\uff1b\u7b2c\u4e00\u79cd\u6280\u672f\u53ea\u9700\u8981\u4e00\u6b21\u8f6c\u6362\uff08\u5728\u521b\u5efa\u6570\u7ec4\u7684\u5730\u65b9\uff09\uff0c\u800c\u7b2c\u4e8c\u79cd\u6280\u672f\u5728\u6bcf\u6b21\u8bfb\u53d6\u6570\u7ec4\u5143\u7d20\u65f6\u90fd\u9700\u8981\u5355\u72ec\u7684\u8f6c\u6362\u3002\u56e0\u6b64\uff0c\u7b2c\u4e00\u79cd\u6280\u672f\u662f\u53ef\u53d6\u7684\uff0c\u5728\u5b9e\u8df5\u4e2d\u66f4\u5e38\u7528\u3002\u4f46\u662f\uff0c\u5b83\u786e\u5b9e\u4f1a\u9020\u6210\u5806\u6c61\u67d3\uff08",(0,r.kt)("a",{parentName:"p",href:"./Chapter-5-Item-32-Combine-generics-and-varargs-judiciously"},"Item-32"),"\uff09\uff1a\u6570\u7ec4\u7684\u8fd0\u884c\u65f6\u7c7b\u578b\u4e0e\u5176\u7f16\u8bd1\u65f6\u7c7b\u578b\u4e0d\u5339\u914d\uff08\u9664\u975e E \u6070\u597d\u662f Object\uff09\u3002\u5c3d\u7ba1\u5806\u6c61\u67d3\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\u662f\u65e0\u5bb3\u7684\uff0c\u4f46\u8fd9\u4f7f\u5f97\u4e00\u4e9b\u7a0b\u5e8f\u5458\u611f\u5230\u975e\u5e38\u4e0d\u5b89\uff0c\u56e0\u6b64\u4ed6\u4eec\u9009\u62e9\u4e86\u7b2c\u4e8c\u79cd\u6280\u672f\u3002"),(0,r.kt)("p",null,"The following program demonstrates the use of our generic Stack class. The program prints its command line arguments in reverse order and converted to uppercase. No explicit cast is necessary to invoke String\u2019s toUpperCase method on the elements popped from the stack, and the automatically generated cast is guaranteed to succeed:"),(0,r.kt)("p",null,"\u4e0b\u9762\u7684\u7a0b\u5e8f\u6f14\u793a\u4e86\u901a\u7528 Stack \u7684\u4f7f\u7528\u3002\u7a0b\u5e8f\u4ee5\u76f8\u53cd\u7684\u987a\u5e8f\u6253\u5370\u5b83\u7684\u547d\u4ee4\u884c\u53c2\u6570\u5e76\u8f6c\u6362\u4e3a\u5927\u5199\u3002\u5728\u4ece\u5806\u6808\u5f39\u51fa\u7684\u5143\u7d20\u4e0a\u8c03\u7528 String \u7684 toUpperCase \u65b9\u6cd5\u4e0d\u9700\u8981\u663e\u5f0f\u8f6c\u6362\uff0c\u81ea\u52a8\u751f\u6210\u7684\u8f6c\u6362\u4fdd\u8bc1\u6210\u529f\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"// Little program to exercise our generic Stack\npublic static void main(String[] args) {\n    Stack<String> stack = new Stack<>();\n    for (String arg : args)\n        stack.push(arg);\n    while (!stack.isEmpty())\n        System.out.println(stack.pop().toUpperCase());\n}\n")),(0,r.kt)("p",null,"The foregoing example may appear to contradict Item 28, which encourages the use of lists in preference to arrays. It is not always possible or desirable to use lists inside your generic types. Java doesn\u2019t support lists natively, so some generic types, such as ArrayList, must be implemented atop arrays. Other generic types, such as HashMap, are implemented atop arrays for performance. The great majority of generic types are like our Stack example in that their type parameters have no restrictions: you can create a ",(0,r.kt)("inlineCode",{parentName:"p"},"Stack<Object>"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Stack<int[]>"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Stack<List<String>>"),", or Stack of any other object reference type. Note that you can\u2019t create a Stack of a primitive type: trying to create a ",(0,r.kt)("inlineCode",{parentName:"p"},"Stack<int>")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"Stack<double>")," will result in a compile-time error."),(0,r.kt)("p",null,"\u524d\u9762\u7684\u4f8b\u5b50\u53ef\u80fd\u4e0e ",(0,r.kt)("a",{parentName:"p",href:"./Chapter-5-Item-28-Prefer-lists-to-arrays"},"Item-28")," \u76f8\u77db\u76fe\uff0cItem-28 \u9f13\u52b1\u4f18\u5148\u4f7f\u7528\u5217\u8868\u800c\u4e0d\u662f\u6570\u7ec4\u3002\u5728\u6cdb\u578b\u4e2d\u4f7f\u7528\u5217\u8868\u5e76\u4e0d\u603b\u662f\u53ef\u80fd\u7684\u6216\u53ef\u53d6\u7684\u3002Java \u672c\u8eab\u4e0d\u652f\u6301\u5217\u8868\uff0c\u56e0\u6b64\u4e00\u4e9b\u6cdb\u578b\uff08\u5982 ArrayList\uff09\u5fc5\u987b\u5728\u6570\u7ec4\u4e4b\u4e0a\u5b9e\u73b0\u3002\u5176\u4ed6\u6cdb\u578b\uff08\u5982 HashMap\uff09\u662f\u5728\u6570\u7ec4\u4e4b\u4e0a\u5b9e\u73b0\u7684\uff0c\u4ee5\u63d0\u9ad8\u6027\u80fd\u3002\u5927\u591a\u6570\u6cdb\u578b\u4e0e\u6211\u4eec\u7684 Stack \u793a\u4f8b\u76f8\u4f3c\uff0c\u56e0\u4e3a\u5b83\u4eec\u7684\u7c7b\u578b\u53c2\u6570\u6ca1\u6709\u9650\u5236\uff1a\u4f60\u53ef\u4ee5\u521b\u5efa ",(0,r.kt)("inlineCode",{parentName:"p"},"Stack<Object>"),"\u3001",(0,r.kt)("inlineCode",{parentName:"p"},"Stack<int[]>"),"\u3001",(0,r.kt)("inlineCode",{parentName:"p"},"Stack<List<String>>")," \u6216\u4efb\u4f55\u5176\u4ed6\u5bf9\u8c61\u5f15\u7528\u7c7b\u578b\u7684\u5806\u6808\u3002\u6ce8\u610f\uff0c\u4e0d\u80fd\u521b\u5efa\u57fa\u672c\u7c7b\u578b\u7684 Stack\uff1a\u8bd5\u56fe\u521b\u5efa ",(0,r.kt)("inlineCode",{parentName:"p"},"Stack<int>")," \u6216 ",(0,r.kt)("inlineCode",{parentName:"p"},"Stack<double>")," \u5c06\u5bfc\u81f4\u7f16\u8bd1\u65f6\u9519\u8bef\u3002"),(0,r.kt)("p",null,"This is a fundamental limitation of Java\u2019s generic type system. You can work around this restriction by using boxed primitive types (Item 61). There are some generic types that restrict the permissible values of their type parameters. For example, consider java.util.concurrent.DelayQueue, whose declaration looks like this:"),(0,r.kt)("p",null,"\u8fd9\u662f Java \u6cdb\u578b\u7cfb\u7edf\u7684\u4e00\u4e2a\u57fa\u672c\u9650\u5236\u3002\u4f60\u53ef\u4ee5\u901a\u8fc7\u4f7f\u7528\u88c5\u7bb1\u7684\u57fa\u672c\u7c7b\u578b\uff08",(0,r.kt)("a",{parentName:"p",href:"./Chapter-9-Item-61-Prefer-primitive-types-to-boxed-primitives"},"Item-61"),"\uff09\u6765\u7ed5\u8fc7\u8fd9\u4e00\u9650\u5236\u3002\u6709\u4e00\u4e9b\u6cdb\u578b\u9650\u5236\u4e86\u5176\u7c7b\u578b\u53c2\u6570\u7684\u5141\u8bb8\u503c\u3002\u4f8b\u5982\uff0c\u8003\u8651 java.util.concurrent.DelayQueue\uff0c\u5176\u58f0\u660e\u5982\u4e0b\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"class DelayQueue<E extends Delayed> implements BlockingQueue<E>\n")),(0,r.kt)("p",null,"The type parameter list (",(0,r.kt)("inlineCode",{parentName:"p"},"<E extends Delayed>"),") requires that the actual type parameter E be a subtype of java.util.concurrent.Delayed. This allows the DelayQueue implementation and its clients to take advantage of Delayed methods on the elements of a DelayQueue, without the need for explicit casting or the risk of a ClassCastException. The type parameter E is known as a bounded type parameter. Note that the subtype relation is defined so that every type is a subtype of itself ","[JLS, 4.10]",", so it is legal to create a ",(0,r.kt)("inlineCode",{parentName:"p"},"DelayQueue<Delayed>"),"."),(0,r.kt)("p",null,"\u7c7b\u578b\u53c2\u6570\u5217\u8868\uff08",(0,r.kt)("inlineCode",{parentName:"p"},"<E extends Delayed>"),"\uff09\u8981\u6c42\u5b9e\u9645\u7684\u7c7b\u578b\u53c2\u6570 E \u662f java.util.concurrent.Delayed \u7684\u4e00\u4e2a\u5b50\u7c7b\u578b\u3002\u8fd9\u5141\u8bb8 DelayQueue \u5b9e\u73b0\u53ca\u5176\u5ba2\u6237\u7aef\u5229\u7528 DelayQueue \u5143\u7d20\u4e0a\u7684 Delayed \u65b9\u6cd5\uff0c\u800c\u4e0d\u9700\u8981\u663e\u5f0f\u8f6c\u6362\u6216 ClassCastException \u7684\u98ce\u9669\u3002\u7c7b\u578b\u53c2\u6570 E \u79f0\u4e3a\u6709\u754c\u7c7b\u578b\u53c2\u6570\u3002\u6ce8\u610f\uff0c\u5b50\u7c7b\u578b\u5173\u7cfb\u7684\u5b9a\u4e49\u4f7f\u5f97\u6bcf\u4e2a\u7c7b\u578b\u90fd\u662f\u5b83\u81ea\u5df1\u7684\u5b50\u7c7b\u578b ","[JLS, 4.10]","\uff0c\u6240\u4ee5\u521b\u5efa ",(0,r.kt)("inlineCode",{parentName:"p"},"DelayQueue<Delayed>")," \u662f\u5408\u6cd5\u7684\u3002"),(0,r.kt)("p",null,"In summary, generic types are safer and easier to use than types that require casts in client code. When you design new types, make sure that they can be used without such casts. This will often mean making the types generic. If you have any existing types that should be generic but aren\u2019t, generify them. This will make life easier for new users of these types without breaking existing clients (Item 26)."),(0,r.kt)("p",null,"\u603b\u4e4b\uff0c\u6cdb\u578b\u6bd4\u9700\u8981\u5728\u5ba2\u6237\u7aef\u4ee3\u7801\u4e2d\u8f6c\u6362\u7684\u7c7b\u578b\u66f4\u5b89\u5168\u3001\u66f4\u5bb9\u6613\u4f7f\u7528\u3002\u5728\u8bbe\u8ba1\u65b0\u7c7b\u578b\u65f6\uff0c\u8bf7\u786e\u4fdd\u53ef\u4ee5\u5728\u4e0d\u4f7f\u7528\u6b64\u7c7b\u7c7b\u578b\u8f6c\u6362\u7684\u60c5\u51b5\u4e0b\u4f7f\u7528\u5b83\u4eec\u3002\u8fd9\u901a\u5e38\u610f\u5473\u7740\u4f7f\u7c7b\u578b\u5177\u6709\u901a\u7528\u6027\u3002\u5982\u679c\u4f60\u6709\u4efb\u4f55\u5e94\u8be5\u662f\u6cdb\u578b\u4f46\u4e0d\u662f\u6cdb\u578b\u7684\u73b0\u6709\u7c7b\u578b\uff0c\u8bf7\u5bf9\u5b83\u4eec\u8fdb\u884c\u6cdb\u578b\u3002\u8fd9\u5c06\u4f7f\u8fd9\u4e9b\u7c7b\u578b\u7684\u65b0\u7528\u6237\u5728\u4e0d\u7834\u574f\u73b0\u6709\u5ba2\u6237\u7aef\uff08",(0,r.kt)("a",{parentName:"p",href:"./Chapter-5-Item-26-Do-not-use-raw-types"},"Item-26"),"\uff09\u7684\u60c5\u51b5\u4e0b\u66f4\u5bb9\u6613\u4f7f\u7528\u3002"),(0,r.kt)("hr",null),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"./Chapter-5-Introduction"},"Back to contents of the chapter\uff08\u8fd4\u56de\u7ae0\u8282\u76ee\u5f55\uff09"))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Previous Item\uff08\u4e0a\u4e00\u6761\u76ee\uff09\uff1a",(0,r.kt)("a",{parentName:"strong",href:"./Chapter-5-Item-28-Prefer-lists-to-arrays"},"Item 28: Prefer lists to arrays\uff08list \u4f18\u4e8e\u6570\u7ec4\uff09"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Next Item\uff08\u4e0b\u4e00\u6761\u76ee\uff09\uff1a",(0,r.kt)("a",{parentName:"strong",href:"./Chapter-5-Item-30-Favor-generic-methods"},"Item 30: Favor generic methods\uff08\u4f18\u5148\u4f7f\u7528\u6cdb\u578b\u65b9\u6cd5\uff09")))))}u.isMDXComponent=!0}}]);