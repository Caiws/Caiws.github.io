"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[9176],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>p});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=c(n),p=a,m=u["".concat(l,".").concat(p)]||u[p]||h[p]||o;return n?r.createElement(m,i(i({ref:t},d),{},{components:n})):r.createElement(m,i({ref:t},d))}));function p(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},4556:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var r=n(7462),a=(n(7294),n(3905));const o={},i=void 0,s={unversionedId:"Books/EffectiveJava3/Chapter-11/Chapter-11-Item-79-Avoid-excessive-synchronization",id:"Books/EffectiveJava3/Chapter-11/Chapter-11-Item-79-Avoid-excessive-synchronization",title:"Chapter-11-Item-79-Avoid-excessive-synchronization",description:"Chapter 11. Concurrency\uff08\u5e76\u53d1\uff09",source:"@site/docs/Books/EffectiveJava3/Chapter-11/Chapter-11-Item-79-Avoid-excessive-synchronization.md",sourceDirName:"Books/EffectiveJava3/Chapter-11",slug:"/Books/EffectiveJava3/Chapter-11/Chapter-11-Item-79-Avoid-excessive-synchronization",permalink:"/docs/Books/EffectiveJava3/Chapter-11/Chapter-11-Item-79-Avoid-excessive-synchronization",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Books/EffectiveJava3/Chapter-11/Chapter-11-Item-79-Avoid-excessive-synchronization.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Chapter-11-Item-78-Synchronize-access-to-shared-mutable-data",permalink:"/docs/Books/EffectiveJava3/Chapter-11/Chapter-11-Item-78-Synchronize-access-to-shared-mutable-data"},next:{title:"Chapter-11-Item-80-Prefer-executors,-tasks,-and-streams-to-threads",permalink:"/docs/Books/EffectiveJava3/Chapter-11/Chapter-11-Item-80-Prefer-executors,-tasks,-and-streams-to-threads"}},l={},c=[{value:"Chapter 11. Concurrency\uff08\u5e76\u53d1\uff09",id:"chapter-11-concurrency\u5e76\u53d1",level:2},{value:"Item 79: Avoid excessive synchronization\uff08\u907f\u514d\u8fc7\u5ea6\u540c\u6b65\uff09",id:"item-79-avoid-excessive-synchronization\u907f\u514d\u8fc7\u5ea6\u540c\u6b65",level:3}],d={toc:c};function h(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"chapter-11-concurrency\u5e76\u53d1"},"Chapter 11. Concurrency\uff08\u5e76\u53d1\uff09"),(0,a.kt)("h3",{id:"item-79-avoid-excessive-synchronization\u907f\u514d\u8fc7\u5ea6\u540c\u6b65"},"Item 79: Avoid excessive synchronization\uff08\u907f\u514d\u8fc7\u5ea6\u540c\u6b65\uff09"),(0,a.kt)("p",null,"Item 78 warns of the dangers of insufficient synchronization. This item concerns the opposite problem. Depending on the situation, excessive synchronization can cause reduced performance, deadlock, or even nondeterministic behavior."),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"./Chapter-11/Chapter-11-Item-78-Synchronize-access-to-shared-mutable-data"},"Item-78")," \u8b66\u544a\u6211\u4eec\u540c\u6b65\u4e0d\u5230\u4f4d\u7684\u5371\u9669\u3002\u672c\u6761\u76ee\u6d89\u53ca\u76f8\u53cd\u7684\u95ee\u9898\u3002\u6839\u636e\u4e0d\u540c\u7684\u60c5\u51b5\uff0c\u8fc7\u5ea6\u7684\u540c\u6b65\u53ef\u80fd\u5bfc\u81f4\u6027\u80fd\u4e0b\u964d\u3001\u6b7b\u9501\u751a\u81f3\u4e0d\u786e\u5b9a\u884c\u4e3a\u3002"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"To avoid liveness and safety failures, never cede control to the client within a synchronized method or block.")," In other words, inside a synchronized region, do not invoke a method that is designed to be overridden, or one provided by a client in the form of a function object (Item 24). From the perspective of the class with the synchronized region, such methods are alien. The class has no knowledge of what the method does and has no control over it. Depending on what an alien method does, calling it from a synchronized region can cause exceptions, deadlocks, or data corruption."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"\u4e3a\u907f\u514d\u6d3b\u6027\u5931\u8d25\u548c\u5b89\u5168\u6545\u969c\uff0c\u6c38\u8fdc\u4e0d\u8981\u5728\u540c\u6b65\u65b9\u6cd5\u6216\u5757\u4e2d\u5c06\u63a7\u5236\u6743\u4ea4\u7ed9\u5ba2\u6237\u7aef\u3002")," \u6362\u53e5\u8bdd\u8bf4\uff0c\u5728\u540c\u6b65\u533a\u57df\u5185\uff0c\u4e0d\u8981\u8c03\u7528\u4e00\u4e2a\u8bbe\u8ba1\u4e3a\u88ab\u8986\u76d6\u7684\u65b9\u6cd5\uff0c\u6216\u8005\u4e00\u4e2a\u7531\u5ba2\u6237\u7aef\u4ee5\u51fd\u6570\u5bf9\u8c61\u7684\u5f62\u5f0f\u63d0\u4f9b\u7684\u65b9\u6cd5\uff08",(0,a.kt)("a",{parentName:"p",href:"./Chapter-4-Item-24-Favor-static-member-classes-over-nonstatic"},"Item-24"),"\uff09\u3002\u4ece\u5177\u6709\u540c\u6b65\u533a\u57df\u7684\u7c7b\u7684\u89d2\u5ea6\u6765\u770b\uff0c\u8fd9\u79cd\u65b9\u6cd5\u662f\u4e0d\u4e00\u6837\u7684\u3002\u7c7b\u4e0d\u77e5\u9053\u8be5\u65b9\u6cd5\u505a\u4ec0\u4e48\uff0c\u4e5f\u65e0\u6cd5\u63a7\u5236\u5b83\u3002Depending on what an alien method does\uff0c\u4ece\u540c\u6b65\u533a\u57df\u8c03\u7528\u5b83\u53ef\u80fd\u4f1a\u5bfc\u81f4\u5f02\u5e38\u3001\u6b7b\u9501\u6216\u6570\u636e\u635f\u574f\u3002"),(0,a.kt)("p",null,"To make this concrete, consider the following class, which implements an observable set wrapper. It allows clients to subscribe to notifications when elements are added to the set. This is the Observer pattern ","[Gamma95]",". For brevity\u2019s sake, the class does not provide notifications when elements are removed from the set, but it would be a simple matter to provide them. This class is implemented atop the reusable ForwardingSet from Item 18 (page 90):"),(0,a.kt)("p",null,"\u8981\u4f7f\u8fd9\u4e2a\u95ee\u9898\u5177\u4f53\u5316\uff0c\u8bf7\u8003\u8651\u4e0b\u9762\u7684\u7c7b\uff0c\u5b83\u5b9e\u73b0\u4e86\u4e00\u4e2a\u53ef\u89c6 Set \u5305\u88c5\u5668\u3002\u5f53\u5143\u7d20\u88ab\u6dfb\u52a0\u5230\u96c6\u5408\u4e2d\u65f6\uff0c\u5b83\u5141\u8bb8\u5ba2\u6237\u7aef\u8ba2\u9605\u901a\u77e5\u3002\u8fd9\u662f\u89c2\u5bdf\u8005\u6a21\u5f0f ","[Gamma95]","\u3002\u4e3a\u4e86\u7b80\u5355\u8d77\u89c1\uff0c\u5f53\u5143\u7d20\u4ece\u96c6\u5408\u4e2d\u5220\u9664\u65f6\uff0c\u8be5\u7c7b\u4e0d\u63d0\u4f9b\u901a\u77e5\uff0c\u5373\u4f7f\u8981\u63d0\u4f9b\u901a\u77e5\u4e5f\u5f88\u7b80\u5355\u3002\u8fd9\u4e2a\u7c7b\u662f\u5728 ",(0,a.kt)("a",{parentName:"p",href:"./Chapter-4-Item-18-Favor-composition-over-inheritance"},"Item-18"),"\uff08\u7b2c 90 \u9875\uff09\u7684\u53ef\u590d\u7528 ForwardingSet \u4e0a\u5b9e\u73b0\u7684\uff1a"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"// Broken - invokes alien method from synchronized block!\npublic class ObservableSet<E> extends ForwardingSet<E> {\n    public ObservableSet(Set<E> set) { super(set); }\n\n    private final List<SetObserver<E>> observers= new ArrayList<>();\n\n    public void addObserver(SetObserver<E> observer) {\n        synchronized(observers) {\n            observers.add(observer);\n        }\n    }\n\n    public boolean removeObserver(SetObserver<E> observer) {\n        synchronized(observers) {\n            return observers.remove(observer);\n        }\n    }\n\n    private void notifyElementAdded(E element) {\n        synchronized(observers) {\n            for (SetObserver<E> observer : observers)\n                observer.added(this, element);\n        }\n    }\n\n    @Override\n    public boolean add(E element) {\n        boolean added = super.add(element);\n        if (added)\n            notifyElementAdded(element);\n        return added;\n    }\n\n    @Override\n    public boolean addAll(Collection<? extends E> c) {\n        boolean result = false;\n        for (E element : c)\n            result |= add(element); // Calls notifyElementAdded\n        return result;\n    }\n}\n")),(0,a.kt)("p",null,"Observers subscribe to notifications by invoking the addObserver method and unsubscribe by invoking the removeObserver method. In both cases, an instance of this callback interface is passed to the method."),(0,a.kt)("p",null,"\u89c2\u5bdf\u8005\u901a\u8fc7\u8c03\u7528 addObserver \u65b9\u6cd5\u8ba2\u9605\u901a\u77e5\uff0c\u901a\u8fc7\u8c03\u7528 removeObserver \u65b9\u6cd5\u53d6\u6d88\u8ba2\u9605\u3002\u5728\u8fd9\u4e24\u79cd\u60c5\u51b5\u4e0b\uff0c\u90fd\u4f1a\u5c06\u6b64\u56de\u8c03\u63a5\u53e3\u7684\u5b9e\u4f8b\u4f20\u9012\u7ed9\u65b9\u6cd5\u3002"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"@FunctionalInterface\npublic interface SetObserver<E> {\n    // Invoked when an element is added to the observable set\n    void added(ObservableSet<E> set, E element);\n}\n")),(0,a.kt)("p",null,"This interface is structurally identical to ",(0,a.kt)("inlineCode",{parentName:"p"},"BiConsumer<ObservableSet<E>,E>"),". We chose to define a custom functional interface because the interface and method names make the code more readable and because the interface could evolve to incorporate multiple callbacks. That said, a reasonable argument could also be made for using BiConsumer (Item 44)."),(0,a.kt)("p",null,"\u8fd9\u4e2a\u63a5\u53e3\u5728\u7ed3\u6784\u4e0a\u4e0e ",(0,a.kt)("inlineCode",{parentName:"p"},"BiConsumer<ObservableSet<E>,E>")," \u76f8\u540c\u3002\u6211\u4eec\u9009\u62e9\u5b9a\u4e49\u4e00\u4e2a\u81ea\u5b9a\u4e49\u51fd\u6570\u5f0f\u63a5\u53e3\uff0c\u56e0\u4e3a\u63a5\u53e3\u548c\u65b9\u6cd5\u540d\u79f0\u4f7f\u4ee3\u7801\u66f4\u5177\u53ef\u8bfb\u6027\uff0c\u800c\u4e14\u63a5\u53e3\u53ef\u4ee5\u6f14\u5316\u4e3a\u5305\u542b\u591a\u4e2a\u56de\u8c03\u3002\u4e5f\u5c31\u662f\u8bf4\uff0c\u4f7f\u7528 BiConsumer \u4e5f\u662f\u5408\u7406\u7684\uff08",(0,a.kt)("a",{parentName:"p",href:"./Chapter-7-Item-44-Favor-the-use-of-standard-functional-interfaces"},"Item-44"),"\uff09\u3002"),(0,a.kt)("p",null,"On cursory inspection, ObservableSet appears to work fine. For example, the following program prints the numbers from 0 through 99:"),(0,a.kt)("p",null,"\u7c97\u7565\u5730\u68c0\u67e5\u4e00\u4e0b\uff0cObservableSet \u4f3c\u4e4e\u5de5\u4f5c\u5f97\u5f88\u597d\u3002\u4f8b\u5982\uff0c\u4e0b\u9762\u7684\u7a0b\u5e8f\u6253\u5370\u4ece 0 \u5230 99 \u7684\u6570\u5b57\uff1a"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"public static void main(String[] args) {\n    ObservableSet<Integer> set =new ObservableSet<>(new HashSet<>());\n    set.addObserver((s, e) -> System.out.println(e));\n    for (int i = 0; i < 100; i++)\n        set.add(i);\n}\n")),(0,a.kt)("p",null,"Now let\u2019s try something a bit fancier. Suppose we replace the addObserver call with one that passes an observer that prints the Integer value that was added to the set and removes itself if the value is 23:"),(0,a.kt)("p",null,"\u73b0\u5728\u8ba9\u6211\u4eec\u5c1d\u8bd5\u4e00\u4e9b\u66f4\u5947\u7279\u7684\u4e1c\u897f\u3002\u5047\u8bbe\u6211\u4eec\u5c06 addObserver \u8c03\u7528\u66ff\u6362\u4e3a\u4e00\u4e2a\u4f20\u9012\u89c2\u5bdf\u8005\u7684\u8c03\u7528\uff0c\u8be5\u89c2\u5bdf\u8005\u6253\u5370\u6dfb\u52a0\u5230\u96c6\u5408\u4e2d\u7684\u6574\u6570\u503c\uff0c\u5982\u679c\u8be5\u503c\u4e3a 23\uff0c\u5219\u8be5\u8c03\u7528\u5c06\u5220\u9664\u81ea\u8eab\uff1a"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"set.addObserver(new SetObserver<>() {\n    public void added(ObservableSet<Integer> s, Integer e) {\n        System.out.println(e);\n        if (e == 23)\n            s.removeObserver(this);\n    }\n});\n")),(0,a.kt)("p",null,"Note that this call uses an anonymous class instance in place of the lambda used in the previous call. That is because the function object needs to pass itself to s.removeObserver, and lambdas cannot access themselves (Item 42)."),(0,a.kt)("p",null,"\u6ce8\u610f\uff0c\u8fd9\u4e2a\u8c03\u7528\u4f7f\u7528\u4e00\u4e2a\u533f\u540d\u7c7b\u5b9e\u4f8b\u6765\u4ee3\u66ff\u524d\u9762\u8c03\u7528\u4e2d\u4f7f\u7528\u7684 lambda \u8868\u8fbe\u5f0f\u3002\u8fd9\u662f\u56e0\u4e3a\u51fd\u6570\u5bf9\u8c61\u9700\u8981\u5c06\u81ea\u5df1\u4f20\u9012\u7ed9 ",(0,a.kt)("inlineCode",{parentName:"p"},"s.removeObserver"),"\uff0c\u800c lambda \u8868\u8fbe\u5f0f\u4e0d\u80fd\u8bbf\u95ee\u81ea\u8eab\uff08",(0,a.kt)("a",{parentName:"p",href:"./Chapter-7-Item-42-Prefer-lambdas-to-anonymous-classes"},"Item-42"),"\uff09\u3002"),(0,a.kt)("p",null,"You might expect the program to print the numbers 0 through 23, after which the observer would unsubscribe and the program would terminate silently. In fact, it prints these numbers and then throws a ConcurrentModificationException. The problem is that notifyElementAdded is in the process of iterating over the observers list when it invokes the observer\u2019s added method. The added method calls the observable set\u2019s removeObserver method, which in turn calls the method observers.remove. Now we\u2019re in trouble. We are trying to remove an element from a list in the midst of iterating over it, which is illegal. The iteration in the notifyElementAdded method is in a synchronized block to prevent concurrent modification, but it doesn\u2019t prevent the iterating thread itself from calling back into the observable set and modifying its observers list."),(0,a.kt)("p",null,"\u4f60\u53ef\u80fd\u5e0c\u671b\u7a0b\u5e8f\u6253\u5370\u6570\u5b57 0 \u5230 23\uff0c\u7136\u540e\u89c2\u5bdf\u8005\u5c06\u53d6\u6d88\u8ba2\u9605\uff0c\u7a0b\u5e8f\u5c06\u65e0\u58f0\u5730\u7ec8\u6b62\u3002\u5b9e\u9645\u4e0a\uff0c\u5b83\u6253\u5370\u8fd9\u4e9b\u6570\u5b57\uff0c\u7136\u540e\u629b\u51fa ConcurrentModificationException\u3002\u95ee\u9898\u5728\u4e8e notifyElementAdded \u5728\u8c03\u7528\u89c2\u5bdf\u8005\u7684 added \u65b9\u6cd5\u65f6\uff0c\u6b63\u5728\u904d\u5386 observers \u5217\u8868\u3002added \u65b9\u6cd5\u8c03\u7528\u53ef\u89c2\u5bdf\u96c6\u7684 removeObserver \u65b9\u6cd5\uff0c\u8be5\u65b9\u6cd5\u53cd\u8fc7\u6765\u8c03\u7528\u65b9\u6cd5 ",(0,a.kt)("inlineCode",{parentName:"p"},"observers.remove"),"\u3002\u73b0\u5728\u6211\u4eec\u6709\u9ebb\u70e6\u4e86\u3002\u6211\u4eec\u8bd5\u56fe\u5728\u904d\u5386\u5217\u8868\u7684\u8fc7\u7a0b\u4e2d\u4ece\u5217\u8868\u4e2d\u5220\u9664\u4e00\u4e2a\u5143\u7d20\uff0c\u8fd9\u662f\u975e\u6cd5\u7684\u3002notifyElementAdded \u65b9\u6cd5\u4e2d\u7684\u8fed\u4ee3\u4f4d\u4e8e\u4e00\u4e2a\u540c\u6b65\u5757\u4e2d\uff0c\u4ee5\u9632\u6b62\u5e76\u53d1\u4fee\u6539\uff0c\u4f46\u662f\u65e0\u6cd5\u9632\u6b62\u8fed\u4ee3\u7ebf\u7a0b\u672c\u8eab\u56de\u8c03\u5230\u53ef\u89c2\u5bdf\u7684\u96c6\u5408\u4e2d\uff0c\u4e5f\u65e0\u6cd5\u9632\u6b62\u4fee\u6539\u5b83\u7684 observers \u5217\u8868\u3002"),(0,a.kt)("p",null,"Now let\u2019s try something odd: let\u2019s write an observer that tries to unsubscribe, but instead of calling removeObserver directly, it engages the services of another thread to do the deed. This observer uses an executor service (Item 80):"),(0,a.kt)("p",null,"\u73b0\u5728\u8ba9\u6211\u4eec\u5c1d\u8bd5\u4e00\u4e9b\u5947\u602a\u7684\u4e8b\u60c5\uff1a\u8ba9\u6211\u4eec\u7f16\u5199\u4e00\u4e2a\u89c2\u5bdf\u8005\u6765\u5c1d\u8bd5\u53d6\u6d88\u8ba2\u9605\uff0c\u4f46\u662f\u5b83\u6ca1\u6709\u76f4\u63a5\u8c03\u7528 removeObserver\uff0c\u800c\u662f\u4f7f\u7528\u53e6\u4e00\u4e2a\u7ebf\u7a0b\u7684\u670d\u52a1\u6765\u6267\u884c\u8fd9\u4e2a\u64cd\u4f5c\u3002\u8be5\u89c2\u5bdf\u8005\u4f7f\u7528 executor \u670d\u52a1\uff08",(0,a.kt)("a",{parentName:"p",href:"./Chapter-11/Chapter-11-Item-80-Prefer-executors,-tasks,-and-streams-to-threads"},"Item-80"),"\uff09\uff1a"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"// Observer that uses a background thread needlessly\nset.addObserver(new SetObserver<>() {\n    public void added(ObservableSet<Integer> s, Integer e) {\n        System.out.println(e);\n        if (e == 23) {\n            ExecutorService exec = Executors.newSingleThreadExecutor();\n            try {\n                exec.submit(() -> s.removeObserver(this)).get();\n            } catch (ExecutionException | InterruptedException ex) {\n                throw new AssertionError(ex);\n            } finally {\n                exec.shutdown();\n            }\n        }\n    }\n});\n")),(0,a.kt)("p",null,"Incidentally, note that this program catches two different exception types in one catch clause. This facility, informally known as multi-catch, was added in Java 7. It can greatly increase the clarity and reduce the size of programs that behave the same way in response to multiple exception types."),(0,a.kt)("p",null,"\u987a\u4fbf\u63d0\u4e00\u4e0b\uff0c\u6ce8\u610f\u8fd9\u4e2a\u7a0b\u5e8f\u5728\u4e00\u4e2a catch \u5b50\u53e5\u4e2d\u6355\u83b7\u4e86\u4e24\u79cd\u4e0d\u540c\u7684\u5f02\u5e38\u7c7b\u578b\u3002\u8fd9\u4e2a\u529f\u80fd\u5728 Java 7 \u4e2d\u6dfb\u52a0\u4e86\uff0c\u975e\u6b63\u5f0f\u540d\u79f0\u4e3a multi-catch\u3002\u5b83\u53ef\u4ee5\u6781\u5927\u5730\u63d0\u9ad8\u6e05\u6670\u5ea6\uff0c\u5e76\u51cf\u5c11\u5728\u54cd\u5e94\u591a\u79cd\u5f02\u5e38\u7c7b\u578b\u65f6\u8868\u73b0\u76f8\u540c\u7684\u7a0b\u5e8f\u7684\u5927\u5c0f\u3002"),(0,a.kt)("p",null,"When we run this program, we don\u2019t get an exception; we get a deadlock. The background thread calls s.removeObserver, which attempts to lock observers, but it can\u2019t acquire the lock, because the main thread already has the lock. All the while, the main thread is waiting for the background thread to finish removing the observer, which explains the deadlock."),(0,a.kt)("p",null,"\u5f53\u6211\u4eec\u8fd0\u884c\u8fd9\u4e2a\u7a0b\u5e8f\u65f6\uff0c\u6211\u4eec\u4e0d\u4f1a\u5f97\u5230\u5f02\u5e38\uff1b\u800c\u662f\u906d\u9047\u4e86\u6b7b\u9501\u3002\u540e\u53f0\u7ebf\u7a0b\u8c03\u7528 ",(0,a.kt)("inlineCode",{parentName:"p"},"s.removeObserver"),"\uff0c\u5b83\u8bd5\u56fe\u9501\u5b9a\u89c2\u5bdf\u8005\uff0c\u4f46\u65e0\u6cd5\u83b7\u53d6\u9501\uff0c\u56e0\u4e3a\u4e3b\u7ebf\u7a0b\u5df2\u7ecf\u62e5\u6709\u9501\u3002\u4e00\u76f4\u4ee5\u6765\uff0c\u4e3b\u7ebf\u7a0b\u90fd\u5728\u7b49\u5f85\u540e\u53f0\u7ebf\u7a0b\u5b8c\u6210\u5220\u9664\u89c2\u5bdf\u8005\u7684\u64cd\u4f5c\uff0c\u8fd9\u5c31\u89e3\u91ca\u4e86\u6b7b\u9501\u7684\u539f\u56e0\u3002"),(0,a.kt)("p",null,"This example is contrived because there is no reason for the observer to use a background thread to unsubscribe itself, but the problem is real. Invoking alien methods from within synchronized regions has caused many deadlocks in real systems, such as GUI toolkits."),(0,a.kt)("p",null,"\u8fd9\u4e2a\u4f8b\u5b50\u662f\u4eba\u4e3a\u8bbe\u8ba1\u7684\uff0c\u56e0\u4e3a\u89c2\u5bdf\u8005\u6ca1\u6709\u7406\u7531\u4f7f\u7528\u540e\u53f0\u7ebf\u7a0b\u6765\u53d6\u6d88\u8ba2\u9605\u672c\u8eab\uff0c\u4f46\u662f\u95ee\u9898\u662f\u771f\u5b9e\u7684\u3002\u5728\u5b9e\u9645\u7cfb\u7edf\u4e2d\uff0c\u4ece\u540c\u6b65\u533a\u57df\u5185\u8c03\u7528\u5916\u6765\u65b9\u6cd5\u4f1a\u5bfc\u81f4\u8bb8\u591a\u6b7b\u9501\uff0c\u6bd4\u5982 GUI \u5de5\u5177\u5305\u3002"),(0,a.kt)("p",null,"In both of the previous examples (the exception and the deadlock) we were lucky. The resource that was guarded by the synchronized region (observers) was in a consistent state when the alien method (added) was invoked. Suppose you were to invoke an alien method from a synchronized region while the invariant protected by the synchronized region was temporarily invalid. Because locks in the Java programming language are reentrant, such calls won\u2019t deadlock. As in the first example, which resulted in an exception, the calling thread already holds the lock, so the thread will succeed when it tries to reacquire the lock, even though another conceptually unrelated operation is in progress on the data guarded by the lock. The consequences of such a failure can be catastrophic. In essence, the lock has failed to do its job. Reentrant locks simplify the construction of multithreaded object-oriented programs, but they can turn liveness failures into safety failures."),(0,a.kt)("p",null,"\u5728\u524d\u9762\u7684\u4e24\u4e2a\u4f8b\u5b50\u4e2d\uff08\u5f02\u5e38\u548c\u6b7b\u9501\uff09\uff0c\u6211\u4eec\u90fd\u5f88\u5e78\u8fd0\u3002\u8c03\u7528\u5916\u6765\u65b9\u6cd5\uff08added\uff09\u65f6\uff0c\u7531\u540c\u6b65\u533a\u57df\uff08\u89c2\u5bdf\u8005\uff09\u4fdd\u62a4\u7684\u8d44\u6e90\u5904\u4e8e\u4e00\u81f4\u72b6\u6001\u3002\u5047\u8bbe\u4f60\u8981\u4ece\u540c\u6b65\u533a\u57df\u8c03\u7528\u4e00\u4e2a\u5916\u6765\u65b9\u6cd5\uff0c\u800c\u540c\u6b65\u533a\u57df\u4fdd\u62a4\u7684\u4e0d\u53d8\u91cf\u6682\u65f6\u65e0\u6548\u3002\u56e0\u4e3a Java \u7f16\u7a0b\u8bed\u8a00\u4e2d\u7684\u9501\u662f\u53ef\u91cd\u5165\u7684\uff0c\u6240\u4ee5\u8fd9\u6837\u7684\u8c03\u7528\u4e0d\u4f1a\u6b7b\u9501\u3002\u4e0e\u7b2c\u4e00\u4e2a\u5bfc\u81f4\u5f02\u5e38\u7684\u793a\u4f8b\u4e00\u6837\uff0c\u8c03\u7528\u7ebf\u7a0b\u5df2\u7ecf\u6301\u6709\u9501\uff0c\u6240\u4ee5\u5f53\u5b83\u8bd5\u56fe\u91cd\u65b0\u83b7\u5f97\u9501\u65f6\uff0c\u7ebf\u7a0b\u5c06\u6210\u529f\uff0c\u5373\u4f7f\u53e6\u4e00\u4e2a\u6982\u5ff5\u4e0a\u4e0d\u76f8\u5173\u7684\u64cd\u4f5c\u6b63\u5728\u5bf9\u9501\u4fdd\u62a4\u7684\u6570\u636e\u8fdb\u884c\u4e2d\u3002\u8fd9\u79cd\u5931\u8d25\u7684\u540e\u679c\u53ef\u80fd\u662f\u707e\u96be\u6027\u7684\u3002\u4ece\u672c\u8d28\u4e0a\u8bf4\uff0c\u8fd9\u628a\u9501\u6ca1\u80fd\u53d1\u6325\u5b83\u7684\u4f5c\u7528\u3002\u53ef\u91cd\u5165\u9501\u7b80\u5316\u4e86\u591a\u7ebf\u7a0b\u9762\u5411\u5bf9\u8c61\u7a0b\u5e8f\u7684\u6784\u9020\uff0c\u4f46\u5b83\u4eec\u53ef\u4ee5\u5c06\u6d3b\u52a8\u6545\u969c\u8f6c\u5316\u4e3a\u5b89\u5168\u6545\u969c\u3002"),(0,a.kt)("p",null,"Luckily, it is usually not too hard to fix this sort of problem by moving alien method invocations out of synchronized blocks. For the notifyElementAdded method, this involves taking a \u201csnapshot\u201d of the observers list that can then be safely traversed without a lock. With this change, both of the previous examples run without exception or deadlock:"),(0,a.kt)("p",null,"\u5e78\u8fd0\u7684\u662f\uff0c\u901a\u8fc7\u5c06\u5916\u6765\u65b9\u6cd5\u8c03\u7528\u79fb\u51fa\u540c\u6b65\u5757\u6765\u89e3\u51b3\u8fd9\u7c7b\u95ee\u9898\u901a\u5e38\u5e76\u4e0d\u96be\u3002\u5bf9\u4e8e notifyElementAdded \u65b9\u6cd5\uff0c\u8fd9\u6d89\u53ca\u5230\u83b7\u53d6\u89c2\u5bdf\u8005\u5217\u8868\u7684\u300c\u5feb\u7167\u300d\uff0c\u7136\u540e\u53ef\u4ee5\u5728\u6ca1\u6709\u9501\u7684\u60c5\u51b5\u4e0b\u5b89\u5168\u5730\u904d\u5386\u8be5\u5217\u8868\u3002\u6709\u4e86\u8fd9\u4e2a\u6539\u53d8\uff0c\u524d\u9762\u7684\u4e24\u4e2a\u4f8b\u5b50\u90fd\u53ef\u4ee5\u518d\u4e5f\u4e0d\u4f1a\u51fa\u73b0\u5f02\u5e38\u6216\u8005\u6b7b\u9501\u4e86\uff1a"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"// Alien method moved outside of synchronized block - open calls\nprivate void notifyElementAdded(E element) {\n    List<SetObserver<E>> snapshot = null;\n    synchronized(observers) {\n        snapshot = new ArrayList<>(observers);\n    }\n    for (SetObserver<E> observer :snapshot)\n        observer.added(this, element);\n}\n")),(0,a.kt)("p",null,"In fact, there\u2019s a better way to move the alien method invocations out of the synchronized block. The libraries provide a concurrent collection (Item 81) known as CopyOnWriteArrayList that is tailor-made for this purpose. This List implementation is a variant of ArrayList in which all modification operations are implemented by making a fresh copy of the entire underlying array. Because the internal array is never modified, iteration requires no locking and is very fast. For most uses, the performance of CopyOnWriteArrayList would be atrocious, but it\u2019s perfect for observer lists, which are rarely modified and often traversed."),(0,a.kt)("p",null,"\u5b9e\u9645\u4e0a\uff0c\u6709\u4e00\u79cd\u66f4\u597d\u7684\u65b9\u6cd5\u53ef\u4ee5\u5c06\u5916\u6765\u65b9\u6cd5\u8c03\u7528\u79fb\u51fa\u540c\u6b65\u5757\u3002\u5e93\u63d0\u4f9b\u4e86\u4e00\u4e2a\u540d\u4e3a CopyOnWriteArrayList \u7684\u5e76\u53d1\u96c6\u5408\uff08",(0,a.kt)("a",{parentName:"p",href:"./Chapter-11/Chapter-11-Item-81-Prefer-concurrency-utilities-to-wait-and-notify"},"Item-81"),"\uff09\uff0c\u8be5\u96c6\u5408\u662f\u4e3a\u6b64\u76ee\u7684\u91cf\u8eab\u5b9a\u5236\u7684\u3002\u6b64\u5217\u8868\u5b9e\u73b0\u662f ArrayList \u7684\u53d8\u4f53\uff0c\u5176\u4e2d\u6240\u6709\u4fee\u6539\u64cd\u4f5c\u90fd\u662f\u901a\u8fc7\u590d\u5236\u6574\u4e2a\u5e95\u5c42\u6570\u7ec4\u6765\u5b9e\u73b0\u7684\u3002\u56e0\u4e3a\u4ece\u4e0d\u4fee\u6539\u5185\u90e8\u6570\u7ec4\uff0c\u6240\u4ee5\u8fed\u4ee3\u4e0d\u9700\u8981\u9501\u5b9a\uff0c\u800c\u4e14\u901f\u5ea6\u975e\u5e38\u5feb\u3002\u5982\u679c\u5927\u91cf\u4f7f\u7528\uff0cCopyOnWriteArrayList \u7684\u6027\u80fd\u4f1a\u5f88\u5dee\uff0c\u4f46\u662f\u5bf9\u4e8e\u5f88\u5c11\u4fee\u6539\u548c\u7ecf\u5e38\u904d\u5386\u7684\u89c2\u5bdf\u8005\u5217\u8868\u6765\u8bf4\uff0c\u5b83\u662f\u5b8c\u7f8e\u7684\u3002"),(0,a.kt)("p",null,"The add and addAll methods of ObservableSet need not be changed if the list is modified to use CopyOnWriteArrayList. Here is how the remainder of the class looks. Notice that there is no explicit synchronization whatsoever:"),(0,a.kt)("p",null,"\u5982\u679c\u5c06 list \u4fee\u6539\u4e3a\u4f7f\u7528 CopyOnWriteArrayList\uff0c\u5219\u4e0d\u9700\u8981\u66f4\u6539 ObservableSet \u7684 add \u548c addAll \u65b9\u6cd5\u3002\u4e0b\u9762\u662f\u7c7b\u7684\u5176\u4f59\u90e8\u5206\u3002\u8bf7\u6ce8\u610f\uff0c\u6ca1\u6709\u4efb\u4f55\u663e\u5f0f\u540c\u6b65\uff1a"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"// Thread-safe observable set with CopyOnWriteArrayList\nprivate final List<SetObserver<E>> observers =new CopyOnWriteArrayList<>();\n\npublic void addObserver(SetObserver<E> observer) {\n    observers.add(observer);\n}\n\npublic boolean removeObserver(SetObserver<E> observer) {\n    return observers.remove(observer);\n}\n\nprivate void notifyElementAdded(E element) {\n    for (SetObserver<E> observer : observers)\n        observer.added(this, element);\n}\n")),(0,a.kt)("p",null,"An alien method invoked outside of a synchronized region is known as an open call ","[Goetz06, 10.1.4]",". Besides preventing failures, open calls can greatly increase concurrency. An alien method might run for an arbitrarily long period. If the alien method were invoked from a synchronized region, other threads would be denied access to the protected resource unnecessarily."),(0,a.kt)("p",null,"\u5728\u540c\u6b65\u533a\u57df\u4e4b\u5916\u8c03\u7528\u7684\u5916\u6765\u65b9\u6cd5\u79f0\u4e3a open call ","[Goetz06, 10.1.4]","\u3002\u9664\u4e86\u9632\u6b62\u5931\u8d25\u4e4b\u5916\uff0c\u5f00\u653e\u8c03\u7528\u8fd8\u53ef\u4ee5\u6781\u5927\u5730\u63d0\u9ad8\u5e76\u53d1\u6027\u3002\u4e00\u4e2a\u964c\u751f\u7684\u65b9\u6cd5\u53ef\u4ee5\u8fd0\u884c\u4efb\u610f\u957f\u7684\u65f6\u95f4\u3002\u5982\u679c\u4ece\u540c\u6b65\u533a\u57df\u8c03\u7528\u4e86\u5916\u6765\u65b9\u6cd5\uff0c\u5176\u4ed6\u7ebf\u7a0b\u5bf9\u53d7\u4fdd\u62a4\u8d44\u6e90\u7684\u8bbf\u95ee\u5c31\u4f1a\u906d\u5230\u4e0d\u5fc5\u8981\u7684\u62d2\u7edd\u3002"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"As a rule, you should do as little work as possible inside synchronized regions.")," Obtain the lock, examine the shared data, transform it as necessary, and drop the lock. If you must perform some time-consuming activity, find a way to move it out of the synchronized region without violating the guidelines in Item 78."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"\u4f5c\u4e3a\u89c4\u5219\uff0c\u4f60\u5e94\u8be5\u5728\u540c\u6b65\u533a\u57df\u5185\u505a\u5c3d\u53ef\u80fd\u5c11\u7684\u5de5\u4f5c\u3002")," \u83b7\u53d6\u9501\uff0c\u68c0\u67e5\u5171\u4eab\u6570\u636e\uff0c\u6839\u636e\u9700\u8981\u8fdb\u884c\u8f6c\u6362\uff0c\u7136\u540e\u5220\u9664\u9501\u3002\u5982\u679c\u4f60\u5fc5\u987b\u6267\u884c\u4e00\u4e9b\u8017\u65f6\u7684\u6d3b\u52a8\uff0c\u8bf7\u8bbe\u6cd5\u5c06\u5176\u79fb\u51fa\u540c\u6b65\u533a\u57df\uff0c\u800c\u4e0d\u8fdd\u53cd ",(0,a.kt)("a",{parentName:"p",href:"./Chapter-11/Chapter-11-Item-78-Synchronize-access-to-shared-mutable-data"},"Item-78")," \u4e2d\u7684\u6307\u5bfc\u539f\u5219\u3002"),(0,a.kt)("p",null,"The first part of this item was about correctness. Now let\u2019s take a brief look at performance. While the cost of synchronization has plummeted since the early days of Java, it is more important than ever not to oversynchronize. In a multicore world, the real cost of excessive synchronization is not the CPU time spent getting locks; it is contention: the lost opportunities for parallelism and the delays imposed by the need to ensure that every core has a consistent view of memory. Another hidden cost of oversynchronization is that it can limit the VM\u2019s ability to optimize code execution."),(0,a.kt)("p",null,"\u672c\u6761\u76ee\u7684\u7b2c\u4e00\u90e8\u5206\u662f\u5173\u4e8e\u6b63\u786e\u6027\u7684\u3002\u73b0\u5728\u8ba9\u6211\u4eec\u7b80\u8981\u5730\u770b\u4e00\u4e0b\u6027\u80fd\u3002\u867d\u7136\u81ea Java \u65e9\u671f\u4ee5\u6765\uff0c\u540c\u6b65\u7684\u6210\u672c\u5df2\u7ecf\u5927\u5e45\u4e0b\u964d\uff0c\u4f46\u6bd4\u4ee5\u5f80\u4efb\u4f55\u65f6\u5019\u90fd\u66f4\u91cd\u8981\u7684\u662f\uff1a\u4e0d\u8981\u8fc7\u5ea6\u540c\u6b65\u3002\u5728\u591a\u6838\u4e16\u754c\u4e2d\uff0c\u8fc7\u5ea6\u540c\u6b65\u7684\u771f\u6b63\u4ee3\u4ef7\u4e0d\u662f\u83b7\u5f97\u9501\u6240\u82b1\u8d39\u7684 CPU \u65f6\u95f4\uff1b\u8fd9\u662f\u4e00\u79cd\u4e89\u8bba\uff1a\u800c\u662f\u5931\u53bb\u4e86\u5e76\u884c\u5316\u7684\u673a\u4f1a\uff0c\u4ee5\u53ca\u7531\u4e8e\u9700\u8981\u786e\u4fdd\u6bcf\u4e2a\u6838\u5fc3\u90fd\u6709\u4e00\u4e2a\u4e00\u81f4\u7684\u5185\u5b58\u89c6\u56fe\u800c\u9020\u6210\u7684\u5ef6\u8fdf\u3002\u8fc7\u5ea6\u540c\u6b65\u7684\u53e6\u4e00\u4e2a\u9690\u85cf\u6210\u672c\u662f\uff0c\u5b83\u53ef\u80fd\u9650\u5236 VM \u4f18\u5316\u4ee3\u7801\u6267\u884c\u7684\u80fd\u529b\u3002"),(0,a.kt)("p",null,"If you are writing a mutable class, you have two options: you can omit all synchronization and allow the client to synchronize externally if concurrent use is desired, or you can synchronize internally, making the class thread-safe (Item 82). You should choose the latter option only if you can achieve significantly higher concurrency with internal synchronization than you could by having the client lock the entire object externally. The collections in java.util (with the exception of the obsolete Vector and Hashtable) take the former approach, while those in java.util.concurrent take the latter (Item 81)."),(0,a.kt)("p",null,"\u5982\u679c\u4f60\u6b63\u5728\u7f16\u5199\u4e00\u4e2a\u53ef\u53d8\u7684\u7c7b\uff0c\u4f60\u6709\u4e24\u4e2a\u9009\u62e9\uff1a\u4f60\u53ef\u4ee5\u7701\u7565\u6240\u6709\u540c\u6b65\u5e76\u5141\u8bb8\u5ba2\u6237\u7aef\u5728\u9700\u8981\u5e76\u53d1\u4f7f\u7528\u65f6\u5728\u5916\u90e8\u8fdb\u884c\u540c\u6b65\uff0c\u6216\u8005\u4f60\u53ef\u4ee5\u5728\u5185\u90e8\u8fdb\u884c\u540c\u6b65\uff0c\u4ece\u800c\u4f7f\u7c7b\u662f\u7ebf\u7a0b\u5b89\u5168\u7684\uff08",(0,a.kt)("a",{parentName:"p",href:"./Chapter-11/Chapter-11-Item-82-Document-thread-safety"},"Item-82"),"\uff09\u3002\u53ea\u6709\u5f53\u4f60\u80fd\u591f\u901a\u8fc7\u5185\u90e8\u540c\u6b65\u5b9e\u73b0\u6bd4\u901a\u8fc7\u8ba9\u5ba2\u6237\u7aef\u5728\u5916\u90e8\u9501\u5b9a\u6574\u4e2a\u5bf9\u8c61\u83b7\u5f97\u9ad8\u5f97\u591a\u7684\u5e76\u53d1\u6027\u65f6\uff0c\u624d\u5e94\u8be5\u9009\u62e9\u540e\u8005\u3002",(0,a.kt)("inlineCode",{parentName:"p"},"java.util")," \u4e2d\u7684\u96c6\u5408\uff08\u5e9f\u5f03\u7684 Vector \u548c Hashtable \u9664\u5916\uff09\u91c7\u7528\u524d\u4e00\u79cd\u65b9\u6cd5\uff0c\u800c ",(0,a.kt)("inlineCode",{parentName:"p"},"java.util.concurrent")," \u4e2d\u7684\u65b9\u6cd5\u5219\u91c7\u7528\u540e\u8005\uff08",(0,a.kt)("a",{parentName:"p",href:"./Chapter-11/Chapter-11-Item-81-Prefer-concurrency-utilities-to-wait-and-notify"},"Item-81"),"\uff09\u3002"),(0,a.kt)("p",null,"In the early days of Java, many classes violated these guidelines. For example, StringBuffer instances are almost always used by a single thread, yet they perform internal synchronization. It is for this reason that StringBuffer was supplanted by StringBuilder, which is just an unsynchronized StringBuffer. Similarly, it\u2019s a large part of the reason that the thread-safe pseudorandom number generator in java.util.Random was supplanted by the unsynchronized implementation in java.util.concurrent.ThreadLocalRandom. When in doubt, do not synchronize your class, but document that it is not thread-safe."),(0,a.kt)("p",null,"\u5728 Java \u7684\u65e9\u671f\uff0c\u8bb8\u591a\u7c7b\u8fdd\u53cd\u4e86\u8fd9\u4e9b\u51c6\u5219\u3002\u4f8b\u5982\uff0cStringBuffer \u5b9e\u4f8b\u51e0\u4e4e\u603b\u662f\u7531\u4e00\u4e2a\u7ebf\u7a0b\u4f7f\u7528\uff0c\u4f46\u662f\u5b83\u4eec\u6267\u884c\u5185\u90e8\u540c\u6b65\u3002\u6b63\u662f\u7531\u4e8e\u8fd9\u4e2a\u539f\u56e0\uff0cStringBuffer \u88ab StringBuilder \u53d6\u4ee3\uff0c\u800c StringBuilder \u53ea\u662f\u4e00\u4e2a\u672a\u540c\u6b65\u7684 StringBuffer\u3002\u7c7b\u4f3c\u5730\uff0c\u540c\u6837\uff0c",(0,a.kt)("inlineCode",{parentName:"p"},"java.util.Random")," \u4e2d\u7684\u7ebf\u7a0b\u5b89\u5168\u4f2a\u968f\u673a\u6570\u751f\u6210\u5668\u88ab ",(0,a.kt)("inlineCode",{parentName:"p"},"java.util.concurrent.ThreadLocalRandom")," \u4e2d\u7684\u975e\u540c\u6b65\u5b9e\u73b0\u6240\u53d6\u4ee3\uff0c\u8fd9\u4e5f\u662f\u539f\u56e0\u4e4b\u4e00\u3002\u5982\u679c\u6709\u7591\u95ee\uff0c\u4e0d\u8981\u540c\u6b65\u4f60\u7684\u7c7b\uff0c\u4f46\u8981\u8bb0\u5f55\u5b83\u4e0d\u662f\u7ebf\u7a0b\u5b89\u5168\u7684\u3002"),(0,a.kt)("p",null,"If you do synchronize your class internally, you can use various techniques to achieve high concurrency, such as lock splitting, lock striping, and nonblocking concurrency control. These techniques are beyond the scope of this book, but they are discussed elsewhere ","[Goetz06, Herlihy08]","."),(0,a.kt)("p",null,"\u5982\u679c\u4f60\u5728\u5185\u90e8\u540c\u6b65\u4f60\u7684\u7c7b\uff0c\u4f60\u53ef\u4ee5\u4f7f\u7528\u5404\u79cd\u6280\u672f\u6765\u5b9e\u73b0\u9ad8\u5e76\u53d1\u6027\uff0c\u4f8b\u5982\u5206\u62c6\u9501\u3001\u5206\u79bb\u9501\u548c\u975e\u963b\u585e\u5e76\u53d1\u63a7\u5236\u3002\u8fd9\u4e9b\u6280\u672f\u8d85\u51fa\u4e86\u672c\u4e66\u7684\u8303\u56f4\uff0c\u4f46\u662f\u5728\u5176\u4ed6\u5730\u65b9\u4e5f\u6709\u8ba8\u8bba ","[Goetz06, Herlihy08]","\u3002"),(0,a.kt)("p",null,"If a method modifies a static field and there is any possibility that the method will be called from multiple threads, you must synchronize access to the field internally (unless the class can tolerate nondeterministic behavior). It is not possible for a multithreaded client to perform external synchronization on such a method, because unrelated clients can invoke the method without synchronization. The field is essentially a global variable even if it is private because it can be read and modified by unrelated clients. The nextSerialNumber field used by the method generateSerialNumber in Item 78 exemplifies this situation."),(0,a.kt)("p",null,"\u5982\u679c\u4e00\u4e2a\u65b9\u6cd5\u4fee\u6539\u4e86\u4e00\u4e2a\u9759\u6001\u5b57\u6bb5\uff0c\u5e76\u4e14\u6709\u53ef\u80fd\u4ece\u591a\u4e2a\u7ebf\u7a0b\u8c03\u7528\u8be5\u65b9\u6cd5\uff0c\u5219\u5fc5\u987b\u5728\u5185\u90e8\u540c\u6b65\u5bf9\u8be5\u5b57\u6bb5\u7684\u8bbf\u95ee\uff08\u9664\u975e\u8be5\u7c7b\u80fd\u591f\u5bb9\u5fcd\u4e0d\u786e\u5b9a\u6027\u884c\u4e3a\uff09\u3002\u591a\u7ebf\u7a0b\u5ba2\u6237\u7aef\u4e0d\u53ef\u80fd\u5bf9\u8fd9\u6837\u7684\u65b9\u6cd5\u6267\u884c\u5916\u90e8\u540c\u6b65\uff0c\u56e0\u4e3a\u4e0d\u76f8\u5173\u7684\u5ba2\u6237\u7aef\u53ef\u4ee5\u5728\u4e0d\u540c\u6b65\u7684\u60c5\u51b5\u4e0b\u8c03\u7528\u8be5\u65b9\u6cd5\u3002\u5b57\u6bb5\u672c\u8d28\u4e0a\u662f\u4e00\u4e2a\u5168\u5c40\u53d8\u91cf\uff0c\u5373\u4f7f\u5b83\u662f\u79c1\u6709\u7684\uff0c\u56e0\u4e3a\u5b83\u53ef\u4ee5\u88ab\u4e0d\u76f8\u5173\u7684\u5ba2\u6237\u7aef\u8bfb\u53d6\u548c\u4fee\u6539\u3002",(0,a.kt)("a",{parentName:"p",href:"./Chapter-11/Chapter-11-Item-78-Synchronize-access-to-shared-mutable-data"},"Item-78")," \u4e2d\u7684 generateSerialNumber \u65b9\u6cd5\u4f7f\u7528\u7684 nextSerialNumber \u5b57\u6bb5\u6f14\u793a\u4e86\u8fd9\u79cd\u60c5\u51b5\u3002"),(0,a.kt)("p",null,"In summary, to avoid deadlock and data corruption, never call an alien method from within a synchronized region. More generally, keep the amount of work that you do from within synchronized regions to a minimum. When you are designing a mutable class, think about whether it should do its own synchronization. In the multicore era, it is more important than ever not to oversynchronize. Synchronize your class internally only if there is a good reason to do so, and document your decision clearly (Item 82)."),(0,a.kt)("p",null,"\u603b\u4e4b\uff0c\u4e3a\u4e86\u907f\u514d\u6b7b\u9501\u548c\u6570\u636e\u635f\u574f\uff0c\u6c38\u8fdc\u4e0d\u8981\u4ece\u540c\u6b65\u533a\u57df\u5185\u8c03\u7528\u5916\u6765\u65b9\u6cd5\u3002\u66f4\u4e00\u822c\u5730\u8bf4\uff0c\u5c06\u4f60\u5728\u540c\u6b65\u533a\u57df\u5185\u6240\u505a\u7684\u5de5\u4f5c\u91cf\u4fdd\u6301\u5728\u6700\u5c0f\u3002\u5728\u8bbe\u8ba1\u53ef\u53d8\u7c7b\u65f6\uff0c\u8bf7\u8003\u8651\u5b83\u662f\u5426\u5e94\u8be5\u6267\u884c\u81ea\u5df1\u7684\u540c\u6b65\u3002\u5728\u591a\u6838\u65f6\u4ee3\uff0c\u6bd4\u4ee5\u5f80\u4efb\u4f55\u65f6\u5019\u90fd\u66f4\u91cd\u8981\u7684\u662f\u4e0d\u8981\u8fc7\u5ea6\u540c\u6b65\u3002\u53ea\u6709\u5728\u6709\u5145\u5206\u7406\u7531\u65f6\uff0c\u624d\u5728\u5185\u90e8\u540c\u6b65\u7c7b\uff0c\u5e76\u6e05\u695a\u5730\u8bb0\u5f55\u4f60\u7684\u51b3\u5b9a\uff08",(0,a.kt)("a",{parentName:"p",href:"./Chapter-11/Chapter-11-Item-82-Document-thread-safety"},"Item-82"),"\uff09\u3002"),(0,a.kt)("hr",null),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("a",{parentName:"strong",href:"./Chapter-11/Chapter-11-Introduction"},"Back to contents of the chapter\uff08\u8fd4\u56de\u7ae0\u8282\u76ee\u5f55\uff09"))),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Previous Item\uff08\u4e0a\u4e00\u6761\u76ee\uff09\uff1a",(0,a.kt)("a",{parentName:"strong",href:"./Chapter-11/Chapter-11-Item-78-Synchronize-access-to-shared-mutable-data"},"Item 78: Synchronize access to shared mutable data\uff08\u5bf9\u5171\u4eab\u53ef\u53d8\u6570\u636e\u7684\u540c\u6b65\u8bbf\u95ee\uff09"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Next Item\uff08\u4e0b\u4e00\u6761\u76ee\uff09\uff1a",(0,a.kt)("a",{parentName:"strong",href:"./Chapter-11/Chapter-11-Item-80-Prefer-executors,-tasks,-and-streams-to-threads"},"Item 80: Prefer executors, tasks, and streams to threads\uff08Executor\u3001task\u3001\u6d41\u4f18\u4e8e\u76f4\u63a5\u4f7f\u7528\u7ebf\u7a0b\uff09")))))}h.isMDXComponent=!0}}]);