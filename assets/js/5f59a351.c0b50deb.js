"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[2323],{3905:(e,t,r)=>{r.d(t,{Zo:()=>m,kt:()=>d});var n=r(7294);function i(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){i(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,i=function(e,t){if(null==e)return{};var r,n,i={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(i[r]=e[r]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var p=n.createContext({}),l=function(e){var t=n.useContext(p),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},m=function(e){var t=l(e.components);return n.createElement(p.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var r=e.components,i=e.mdxType,a=e.originalType,p=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),c=l(r),d=i,h=c["".concat(p,".").concat(d)]||c[d]||u[d]||a;return r?n.createElement(h,o(o({ref:t},m),{},{components:r})):n.createElement(h,o({ref:t},m))}));function d(e,t){var r=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=r.length,o=new Array(a);o[0]=c;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var l=2;l<a;l++)o[l]=r[l];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}c.displayName="MDXCreateElement"},5272:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>p,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var n=r(7462),i=(r(7294),r(3905));const a={},o=void 0,s={unversionedId:"Books/EffectiveJava3/Chapter-9/Chapter-9-Item-61-Prefer-primitive-types-to-boxed-primitives",id:"Books/EffectiveJava3/Chapter-9/Chapter-9-Item-61-Prefer-primitive-types-to-boxed-primitives",title:"Chapter-9-Item-61-Prefer-primitive-types-to-boxed-primitives",description:"Chapter 9. General Programming\uff08\u901a\u7528\u7a0b\u5e8f\u8bbe\u8ba1\uff09",source:"@site/docs/Books/EffectiveJava3/Chapter-9/Chapter-9-Item-61-Prefer-primitive-types-to-boxed-primitives.md",sourceDirName:"Books/EffectiveJava3/Chapter-9",slug:"/Books/EffectiveJava3/Chapter-9/Chapter-9-Item-61-Prefer-primitive-types-to-boxed-primitives",permalink:"/docs/Books/EffectiveJava3/Chapter-9/Chapter-9-Item-61-Prefer-primitive-types-to-boxed-primitives",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Books/EffectiveJava3/Chapter-9/Chapter-9-Item-61-Prefer-primitive-types-to-boxed-primitives.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Chapter-9-Item-60-Avoid-float-and-double-if-exact-answers-are-required",permalink:"/docs/Books/EffectiveJava3/Chapter-9/Chapter-9-Item-60-Avoid-float-and-double-if-exact-answers-are-required"},next:{title:"Chapter-9-Item-62-Avoid-strings-where-other-types-are-more-appropriate",permalink:"/docs/Books/EffectiveJava3/Chapter-9/Chapter-9-Item-62-Avoid-strings-where-other-types-are-more-appropriate"}},p={},l=[{value:"Chapter 9. General Programming\uff08\u901a\u7528\u7a0b\u5e8f\u8bbe\u8ba1\uff09",id:"chapter-9-general-programming\u901a\u7528\u7a0b\u5e8f\u8bbe\u8ba1",level:2},{value:"Item 61: Prefer primitive types to boxed primitives\uff08\u57fa\u672c\u6570\u636e\u7c7b\u578b\u4f18\u4e8e\u5305\u88c5\u7c7b\uff09",id:"item-61-prefer-primitive-types-to-boxed-primitives\u57fa\u672c\u6570\u636e\u7c7b\u578b\u4f18\u4e8e\u5305\u88c5\u7c7b",level:3}],m={toc:l};function u(e){let{components:t,...r}=e;return(0,i.kt)("wrapper",(0,n.Z)({},m,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"chapter-9-general-programming\u901a\u7528\u7a0b\u5e8f\u8bbe\u8ba1"},"Chapter 9. General Programming\uff08\u901a\u7528\u7a0b\u5e8f\u8bbe\u8ba1\uff09"),(0,i.kt)("h3",{id:"item-61-prefer-primitive-types-to-boxed-primitives\u57fa\u672c\u6570\u636e\u7c7b\u578b\u4f18\u4e8e\u5305\u88c5\u7c7b"},"Item 61: Prefer primitive types to boxed primitives\uff08\u57fa\u672c\u6570\u636e\u7c7b\u578b\u4f18\u4e8e\u5305\u88c5\u7c7b\uff09"),(0,i.kt)("p",null,"Java has a two-part type system, consisting of primitives, such as int, double, and boolean, and reference types, such as String and List. Every primitive type has a corresponding reference type, called a boxed primitive. The boxed primitives corresponding to int, double, and boolean are Integer, Double, and Boolean."),(0,i.kt)("p",null,"Java \u6709\u4e00\u4e2a\u7531\u4e24\u90e8\u5206\u7ec4\u6210\u7684\u7c7b\u578b\u7cfb\u7edf\uff0c\u5305\u62ec\u57fa\u672c\u7c7b\u578b\uff08\u5982 int\u3001double \u548c boolean\uff09\u548c\u5f15\u7528\u7c7b\u578b\uff08\u5982 String \u548c List\uff09\u3002\u6bcf\u4e2a\u57fa\u672c\u7c7b\u578b\u90fd\u6709\u4e00\u4e2a\u5bf9\u5e94\u7684\u5f15\u7528\u7c7b\u578b\uff0c\u79f0\u4e3a\u5305\u88c5\u7c7b\u578b\u3002\u4e0e int\u3001double \u548c boolean \u5bf9\u5e94\u7684\u5305\u88c5\u7c7b\u662f Integer\u3001Double \u548c Boolean\u3002"),(0,i.kt)("p",null,"As mentioned in Item 6, autoboxing and auto-unboxing blur but do not erase the distinction between the primitive and boxed primitive types. There are real differences between the two, and it\u2019s important that you remain aware of which you are using and that you choose carefully between them."),(0,i.kt)("p",null,"\u6b63\u5982 ",(0,i.kt)("a",{parentName:"p",href:"./Chapter-2-Item-6-Avoid-creating-unnecessary-objects"},"Item-6")," \u4e2d\u63d0\u5230\u7684\uff0c\u81ea\u52a8\u88c5\u7bb1\u548c\u81ea\u52a8\u62c6\u7bb1\u6a21\u7cca\u4e86\u57fa\u672c\u7c7b\u578b\u548c\u5305\u88c5\u7c7b\u578b\u4e4b\u95f4\u7684\u533a\u522b\uff0c\u4f46\u4e0d\u4f1a\u6d88\u9664\u5b83\u4eec\u3002\u8fd9\u4e24\u8005\u4e4b\u95f4\u6709\u771f\u6b63\u7684\u533a\u522b\uff0c\u91cd\u8981\u7684\u662f\u4f60\u8981\u59cb\u7ec8\u610f\u8bc6\u5230\u6b63\u5728\u4f7f\u7528\u7684\u662f\u54ea\u4e00\u79cd\uff0c\u5e76\u5728\u5b83\u4eec\u4e4b\u95f4\u4ed4\u7ec6\u9009\u62e9\u3002"),(0,i.kt)("p",null,"There are three major differences between primitives and boxed primitives. First, primitives have only their values, whereas boxed primitives have identities distinct from their values. In other words, two boxed primitive instances can have the same value and different identities. Second, primitive types have only fully functional values, whereas each boxed primitive type has one nonfunctional value, which is null, in addition to all the functional values of the corresponding primitive type. Last, primitives are more time- and spaceefficient than boxed primitives. All three of these differences can get you into real trouble if you aren\u2019t careful."),(0,i.kt)("p",null,"\u57fa\u672c\u7c7b\u578b\u548c\u5305\u88c5\u7c7b\u578b\u4e4b\u95f4\u6709\u4e09\u4e2a\u4e3b\u8981\u533a\u522b\u3002\u9996\u5148\uff0c\u57fa\u672c\u7c7b\u578b\u53ea\u6709\u5b83\u4eec\u7684\u503c\uff0c\u800c\u5305\u88c5\u7c7b\u578b\u5177\u6709\u4e0e\u5176\u503c\u4e0d\u540c\u7684\u6807\u8bc6\u3002\u6362\u53e5\u8bdd\u8bf4\uff0c\u4e24\u4e2a\u5305\u88c5\u7c7b\u578b\u5b9e\u4f8b\u53ef\u4ee5\u5177\u6709\u76f8\u540c\u7684\u503c\u548c\u4e0d\u540c\u7684\u6807\u8bc6\u3002\u7b2c\u4e8c\uff0c\u57fa\u672c\u7c7b\u578b\u53ea\u6709\u5168\u529f\u80fd\u503c\uff0c\u800c\u6bcf\u4e2a\u5305\u88c5\u7c7b\u578b\u9664\u4e86\u5bf9\u5e94\u7684\u57fa\u672c\u7c7b\u578b\u7684\u6240\u6709\u529f\u80fd\u503c\u5916\uff0c\u8fd8\u6709\u4e00\u4e2a\u975e\u529f\u80fd\u503c\uff0c\u5373 null\u3002\u6700\u540e\uff0c\u57fa\u672c\u7c7b\u578b\u6bd4\u5305\u88c5\u7c7b\u578b\u66f4\u8282\u7701\u65f6\u95f4\u548c\u7a7a\u95f4\u3002\u5982\u679c\u4f60\u4e0d\u5c0f\u5fc3\u7684\u8bdd\uff0c\u8fd9\u4e09\u79cd\u5dee\u5f02\u90fd\u4f1a\u7ed9\u4f60\u5e26\u6765\u771f\u6b63\u7684\u9ebb\u70e6\u3002"),(0,i.kt)("p",null,"Consider the following comparator, which is designed to represent ascending numerical order on Integer values. (Recall that a comparator\u2019s compare method returns a number that is negative, zero, or positive, depending on whether its first argument is less than, equal to, or greater than its second.) You wouldn\u2019t need to write this comparator in practice because it implements the natural ordering on Integer, but it makes for an interesting example:"),(0,i.kt)("p",null,"\u8003\u8651\u4e0b\u9762\u7684\u6bd4\u8f83\u5668\uff0c\u5b83\u7684\u8bbe\u8ba1\u76ee\u7684\u662f\u8868\u793a Integer \u503c\u4e0a\u7684\u5347\u5e8f\u6570\u5b57\u6392\u5e8f\u3002\uff08\u56de\u60f3\u4e00\u4e0b\uff0c\u6bd4\u8f83\u5668\u7684 compare \u65b9\u6cd5\u8fd4\u56de\u4e00\u4e2a\u8d1f\u6570\u3001\u96f6\u6216\u6b63\u6570\uff0c\u8fd9\u53d6\u51b3\u4e8e\u5b83\u7684\u7b2c\u4e00\u4e2a\u53c2\u6570\u662f\u5c0f\u4e8e\u3001\u7b49\u4e8e\u8fd8\u662f\u5927\u4e8e\u7b2c\u4e8c\u4e2a\u53c2\u6570\u3002\uff09\u4f60\u4e0d\u9700\u8981\u5728\u5b9e\u9645\u4f7f\u7528\u4e2d\u7f16\u5199\u8fd9\u4e2a\u6bd4\u8f83\u5668\uff0c\u56e0\u4e3a\u5b83\u5b9e\u73b0\u4e86 Integer \u7684\u81ea\u7136\u6392\u5e8f\uff0c\u4f46\u5b83\u63d0\u4f9b\u4e86\u4e00\u4e2a\u6709\u8da3\u7684\u4f8b\u5b50\uff1a"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// Broken comparator - can you spot the flaw?\nComparator<Integer> naturalOrder =(i, j) -> (i < j) ? -1 : (i == j ? 0 : 1);\n")),(0,i.kt)("p",null,"This comparator looks like it ought to work, and it will pass many tests. For example, it can be used with Collections.sort to correctly sort a millionelement list, whether or not the list contains duplicate elements. But the comparator is deeply flawed. To convince yourself of this, merely print the value of naturalOrder.compare(new Integer(42), new Integer(42)). Both Integer instances represent the same value (42), so the value of this expression should be 0, but it\u2019s 1, which indicates that the first Integer value is greater than the second!"),(0,i.kt)("p",null,"\u8fd9\u4e2a\u6bd4\u8f83\u5668\u770b\u8d77\u6765\u5e94\u8be5\u53ef\u4ee5\u5de5\u4f5c\uff0c\u5b83\u5c06\u901a\u8fc7\u8bb8\u591a\u6d4b\u8bd5\u3002\u4f8b\u5982\uff0c\u5b83\u53ef\u4ee5\u4e0e ",(0,i.kt)("inlineCode",{parentName:"p"},"Collections.sort")," \u4e00\u8d77\u4f7f\u7528\uff0c\u4ee5\u6b63\u786e\u5730\u6392\u5e8f\u4e00\u4e2a\u767e\u4e07\u5143\u7d20\u7684 List\uff0c\u65e0\u8bba\u8be5 List \u662f\u5426\u5305\u542b\u91cd\u590d\u7684\u5143\u7d20\u3002\u4f46\u8fd9\u4e2a\u6bd4\u8f83\u5b58\u5728\u4e25\u91cd\u7f3a\u9677\u3002\u8981\u4f7f\u81ea\u5df1\u76f8\u4fe1\u8fd9\u4e00\u70b9\uff0c\u53ea\u9700\u6253\u5370 ",(0,i.kt)("inlineCode",{parentName:"p"},"naturalOrder.compare(new Integer(42), new Integer(42))")," \u7684\u503c\u3002\u4e24\u4e2a Integer \u5b9e\u4f8b\u90fd\u8868\u793a\u76f8\u540c\u7684\u503c ",(0,i.kt)("inlineCode",{parentName:"p"},"(42)"),"\uff0c\u6240\u4ee5\u8fd9\u4e2a\u8868\u8fbe\u5f0f\u7684\u503c\u5e94\u8be5\u662f 0\uff0c\u4f46\u5b83\u662f 1\uff0c\u8fd9\u8868\u660e\u7b2c\u4e00\u4e2a Integer \u503c\u5927\u4e8e\u7b2c\u4e8c\u4e2a\uff01"),(0,i.kt)("p",null,"So what\u2019s the problem? The first test in naturalOrder works fine. Evaluating the expression i < j causes the Integer instances referred to by i and j to be auto-unboxed; that is, it extracts their primitive values. The evaluation proceeds to check if the first of the resulting int values is less than the second. But suppose it is not. Then the next test evaluates the expression i==j, which performs an identity comparison on the two object references. If i and j refer to distinct Integer instances that represent the same int value, this comparison will return false, and the comparator will incorrectly return 1, indicating that the first Integer value is greater than the second. ",(0,i.kt)("strong",{parentName:"p"},"Applying the == operator to boxed primitives is almost always wrong.")),(0,i.kt)("p",null,"\u90a3\u4e48\u95ee\u9898\u51fa\u5728\u54ea\u91cc\u5462\uff1fnaturalOrder \u4e2d\u7684\u7b2c\u4e00\u4e2a\u6d4b\u8bd5\u5de5\u4f5c\u5f97\u5f88\u597d\u3002\u8ba1\u7b97\u8868\u8fbe\u5f0f ",(0,i.kt)("inlineCode",{parentName:"p"},"i < j")," \u4f1a\u4f7f i \u548c j \u5f15\u7528\u7684 Integer \u5b9e\u4f8b\u81ea\u52a8\u62c6\u7bb1\uff1b\u4e5f\u5c31\u662f\u8bf4\uff0c\u5b83\u63d0\u53d6\u5b83\u4eec\u7684\u57fa\u672c\u7c7b\u578b\u503c\u3002\u8ba1\u7b97\u7684\u76ee\u7684\u662f\u68c0\u67e5\u5f97\u5230\u7684\u7b2c\u4e00\u4e2a int \u503c\u662f\u5426\u5c0f\u4e8e\u7b2c\u4e8c\u4e2a int \u503c\u3002\u4f46\u5047\u8bbe\u5b83\u4e0d\u662f\u3002\u7136\u540e\uff0c\u4e0b\u4e00\u4e2a\u6d4b\u8bd5\u8ba1\u7b97\u8868\u8fbe\u5f0f ",(0,i.kt)("inlineCode",{parentName:"p"},"i==j"),"\uff0c\u8be5\u8868\u8fbe\u5f0f\u5bf9\u4e24\u4e2a\u5bf9\u8c61\u5f15\u7528\u6267\u884c\u6807\u8bc6\u6bd4\u8f83\u3002\u5982\u679c i \u548c j \u5f15\u7528\u8868\u793a\u76f8\u540c int \u503c\u7684\u4e0d\u540c Integer \u5b9e\u4f8b\uff0c\u8fd9\u4e2a\u6bd4\u8f83\u5c06\u8fd4\u56de false\uff0c\u6bd4\u8f83\u5668\u5c06\u9519\u8bef\u5730\u8fd4\u56de 1\uff0c\u8868\u660e\u7b2c\u4e00\u4e2a\u6574\u578b\u503c\u5927\u4e8e\u7b2c\u4e8c\u4e2a\u6574\u578b\u503c\u3002",(0,i.kt)("strong",{parentName:"p"},"\u5c06 ",(0,i.kt)("inlineCode",{parentName:"strong"},"==")," \u64cd\u4f5c\u7b26\u5e94\u7528\u4e8e\u5305\u88c5\u7c7b\u578b\u51e0\u4e4e\u90fd\u662f\u9519\u8bef\u7684\u3002")),(0,i.kt)("p",null,"In practice, if you need a comparator to describe a type\u2019s natural order, you should simply call Comparator.naturalOrder(), and if you write a comparator yourself, you should use the comparator construction methods, or the static compare methods on primitive types (Item 14). That said, you could fix the problem in the broken comparator by adding two local variables to store the primitive int values corresponding to the boxed Integer parameters, and performing all of the comparisons on these variables. This avoids the erroneous identity comparison:"),(0,i.kt)("p",null,"\u5728\u5b9e\u9645\u4f7f\u7528\u4e2d\uff0c\u5982\u679c\u4f60\u9700\u8981\u4e00\u4e2a\u6bd4\u8f83\u5668\u6765\u63cf\u8ff0\u7c7b\u578b\u7684\u81ea\u7136\u987a\u5e8f\uff0c\u4f60\u5e94\u8be5\u7b80\u5355\u5730\u8c03\u7528 ",(0,i.kt)("inlineCode",{parentName:"p"},"Comparator.naturalOrder()"),"\uff0c\u5982\u679c\u4f60\u81ea\u5df1\u7f16\u5199\u4e00\u4e2a\u6bd4\u8f83\u5668\uff0c\u4f60\u5e94\u8be5\u4f7f\u7528\u6bd4\u8f83\u5668\u6784\u9020\u65b9\u6cd5\uff0c\u6216\u8005\u5bf9\u57fa\u672c\u7c7b\u578b\u4f7f\u7528\u9759\u6001\u6bd4\u8f83\u65b9\u6cd5\uff08",(0,i.kt)("a",{parentName:"p",href:"./Chapter-3-Item-14-Consider-implementing-Comparable"},"Item-14"),"\uff09\u3002\u4e5f\u5c31\u662f\u8bf4\uff0c\u4f60\u53ef\u4ee5\u901a\u8fc7\u6dfb\u52a0\u4e24\u4e2a\u5c40\u90e8\u53d8\u91cf\u6765\u5b58\u50a8\u57fa\u672c\u7c7b\u578b int \u503c\uff0c\u5e76\u5bf9\u8fd9\u4e9b\u53d8\u91cf\u6267\u884c\u6240\u6709\u7684\u6bd4\u8f83\uff0c\u4ece\u800c\u4fee\u590d\u635f\u574f\u7684\u6bd4\u8f83\u5668\u4e2d\u7684\u95ee\u9898\u3002\u8fd9\u907f\u514d\u4e86\u9519\u8bef\u7684\u6807\u8bc6\u6bd4\u8f83\uff1a"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Comparator<Integer> naturalOrder = (iBoxed, jBoxed) -> {\n    int i = iBoxed, j = jBoxed; // Auto-unboxing\n    return i < j ? -1 : (i == j ? 0 : 1);\n};\n")),(0,i.kt)("p",null,"Next, consider this delightful little program:"),(0,i.kt)("p",null,"\u63a5\u4e0b\u6765\uff0c\u8003\u8651\u4e00\u4e0b\u8fd9\u4e2a\u6709\u8da3\u7684\u5c0f\u7a0b\u5e8f\uff1a"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'public class Unbelievable {\nstatic Integer i;\npublic static void main(String[] args) {\n    if (i == 42)\n        System.out.println("Unbelievable");\n    }\n}\n')),(0,i.kt)("p",null,"No, it doesn\u2019t print Unbelievable\u2014but what it does is almost as strange. It throws a NullPointerException when evaluating the expression i==42. The problem is that i is an Integer, not an int, and like all nonconstant object reference fields, its initial value is null. When the program evaluates the expression i==42, it is comparing an Integer to an int. In nearly every case ",(0,i.kt)("strong",{parentName:"p"},"when you mix primitives and boxed primitives in an operation, the boxed primitive is auto-unboxed.")," If a null object reference is auto-unboxed, you get a NullPointerException. As this program demonstrates, it can happen almost anywhere. Fixing the problem is as simple as declaring i to be an int instead of an Integer."),(0,i.kt)("p",null,"\u4e0d\uff0c\u5b83\u4e0d\u4f1a\u6253\u5370\u51fa\u4ee4\u4eba\u96be\u4ee5\u7f6e\u4fe1\u7684\u4e1c\u897f\uff0c\u4f46\u5b83\u7684\u884c\u4e3a\u5f88\u5947\u602a\u3002\u5b83\u5728\u8ba1\u7b97\u8868\u8fbe\u5f0f ",(0,i.kt)("inlineCode",{parentName:"p"},"i==42")," \u65f6\u629b\u51fa NullPointerException\u3002\u95ee\u9898\u662f\uff0ci \u662f Integer\uff0c\u800c\u4e0d\u662f int \u6570\uff0c\u800c\u4e14\u50cf\u6240\u6709\u975e\u5e38\u91cf\u5bf9\u8c61\u5f15\u7528\u5b57\u6bb5\u4e00\u6837\uff0c\u5b83\u7684\u521d\u503c\u4e3a null\u3002\u5f53\u7a0b\u5e8f\u8ba1\u7b97\u8868\u8fbe\u5f0f ",(0,i.kt)("inlineCode",{parentName:"p"},"i==42")," \u65f6\uff0c\u5b83\u662f\u5728\u6bd4\u8f83 Integer \u4e0e int\u3002",(0,i.kt)("strong",{parentName:"p"},"\u5728\u64cd\u4f5c\u4e2d\u6df7\u5408\u4f7f\u7528\u57fa\u672c\u7c7b\u578b\u548c\u5305\u88c5\u7c7b\u578b\u65f6\uff0c\u5305\u88c5\u7c7b\u578b\u5c31\u4f1a\u81ea\u52a8\u62c6\u7bb1"),"\uff0c\u8fd9\u79cd\u60c5\u51b5\u65e0\u4e00\u4f8b\u5916\u3002\u5982\u679c\u4e00\u4e2a\u7a7a\u5bf9\u8c61\u5f15\u7528\u81ea\u52a8\u62c6\u7bb1\uff0c\u90a3\u4e48\u4f60\u5c06\u5f97\u5230\u4e00\u4e2a NullPointerException\u3002\u6b63\u5982\u8fd9\u4e2a\u7a0b\u5e8f\u6240\u6f14\u793a\u7684\uff0c\u5b83\u51e0\u4e4e\u53ef\u4ee5\u5728\u4efb\u4f55\u5730\u65b9\u53d1\u751f\u3002\u4fee\u590d\u8fd9\u4e2a\u95ee\u9898\u975e\u5e38\u7b80\u5355\uff0c\u53ea\u9700\u5c06 i \u58f0\u660e\u4e3a int \u800c\u4e0d\u662f Integer\u3002"),(0,i.kt)("p",null,"Finally, consider the program from page 24 in Item 6:"),(0,i.kt)("p",null,"\u6700\u540e\uff0c\u8003\u8651 ",(0,i.kt)("a",{parentName:"p",href:"./Chapter-2-Item-6-Avoid-creating-unnecessary-objects"},"Item-6")," \u4e2d\u7b2c 24 \u9875\u7684\u7a0b\u5e8f\uff1a"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// Hideously slow program! Can you spot the object creation?\npublic static void main(String[] args) {\n    Long sum = 0L;\n    for (long i = 0; i < Integer.MAX_VALUE; i++) {\n        sum += i;\n    }\n    System.out.println(sum);\n}\n")),(0,i.kt)("p",null,"This program is much slower than it should be because it accidentally declares a local variable (sum) to be of the boxed primitive type Long instead of the primitive type long. The program compiles without error or warning, and the variable is repeatedly boxed and unboxed, causing the observed performance degradation."),(0,i.kt)("p",null,"\u8fd9\u4e2a\u7a0b\u5e8f\u6bd4\u5b83\u9884\u671f\u7684\u901f\u5ea6\u6162\u5f97\u591a\uff0c\u56e0\u4e3a\u5b83\u610f\u5916\u5730\u58f0\u660e\u4e86\u4e00\u4e2a\u5c40\u90e8\u53d8\u91cf ",(0,i.kt)("inlineCode",{parentName:"p"},"(sum)"),"\uff0c\u5b83\u662f\u5305\u88c5\u7c7b\u578b Long\uff0c\u800c\u4e0d\u662f\u57fa\u672c\u7c7b\u578b long\u3002\u7a0b\u5e8f\u5728\u6ca1\u6709\u9519\u8bef\u6216\u8b66\u544a\u7684\u60c5\u51b5\u4e0b\u7f16\u8bd1\uff0c\u53d8\u91cf\u88ab\u53cd\u590d\u88c5\u7bb1\u548c\u62c6\u7bb1\uff0c\u5bfc\u81f4\u4ea7\u751f\u660e\u663e\u7684\u6027\u80fd\u4e0b\u964d\u3002"),(0,i.kt)("p",null,"In all three of the programs discussed in this item, the problem was the same: the programmer ignored the distinction between primitives and boxed primitives and suffered the consequences. In the first two programs, the consequences were outright failure; in the third, severe performance problems."),(0,i.kt)("p",null,"\u5728\u672c\u6761\u76ee\u4e2d\u8ba8\u8bba\u7684\u6240\u6709\u4e09\u4e2a\u7a0b\u5e8f\u4e2d\uff0c\u95ee\u9898\u90fd\u662f\u4e00\u6837\u7684\uff1a\u7a0b\u5e8f\u5458\u5ffd\u7565\u4e86\u57fa\u672c\u7c7b\u578b\u548c\u5305\u88c5\u7c7b\u578b\u4e4b\u95f4\u7684\u533a\u522b\uff0c\u5e76\u627f\u62c5\u4e86\u6076\u679c\u3002\u5728\u524d\u4e24\u4e2a\u9879\u76ee\u4e2d\uff0c\u7ed3\u679c\u662f\u5f7b\u5e95\u7684\u5931\u8d25\uff1b\u7b2c\u4e09\u4e2a\u4f8b\u5b50\u8fd8\u4ea7\u751f\u4e86\u4e25\u91cd\u7684\u6027\u80fd\u95ee\u9898\u3002"),(0,i.kt)("p",null,"So when should you use boxed primitives? They have several legitimate uses. The first is as elements, keys, and values in collections. You can\u2019t put primitives in collections, so you\u2019re forced to use boxed primitives. This is a special case of a more general one. You must use boxed primitives as type parameters in parameterized types and methods (Chapter 5), because the language does not permit you to use primitives. For example, you cannot declare a variable to be of type ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadLocal<int>"),", so you must use ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadLocal<Integer>")," instead. Finally, you must use boxed primitives when making reflective method invocations (Item 65)."),(0,i.kt)("p",null,"\u90a3\u4e48\uff0c\u4ec0\u4e48\u65f6\u5019\u5e94\u8be5\u4f7f\u7528\u5305\u88c5\u7c7b\u578b\u5462\uff1f\u5b83\u4eec\u6709\u51e0\u4e2a\u5408\u6cd5\u7684\u7528\u9014\u3002\u7b2c\u4e00\u4e2a\u662f\u4f5c\u4e3a\u96c6\u5408\u4e2d\u7684\u5143\u7d20\u3001\u952e\u548c\u503c\u3002\u4e0d\u80fd\u5c06\u57fa\u672c\u7c7b\u578b\u653e\u5728\u96c6\u5408\u4e2d\uff0c\u56e0\u6b64\u5fc5\u987b\u4f7f\u7528\u5305\u88c5\u7c7b\u578b\u3002\u8fd9\u662f\u4e00\u822c\u60c5\u51b5\u4e0b\u7684\u7279\u4f8b\u3002\u5728\u53c2\u6570\u5316\u7c7b\u578b\u548c\u65b9\u6cd5\uff08Chapter 5\uff09\u4e2d\uff0c\u5fc5\u987b\u4f7f\u7528\u5305\u88c5\u7c7b\u578b\u4f5c\u4e3a\u7c7b\u578b\u53c2\u6570\uff0c\u56e0\u4e3a Java \u4e0d\u5141\u8bb8\u4f7f\u7528\u57fa\u672c\u7c7b\u578b\u3002\u4f8b\u5982\uff0c\u4e0d\u80fd\u5c06\u53d8\u91cf\u58f0\u660e\u4e3a ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadLocal<int>")," \u7c7b\u578b\uff0c\u56e0\u6b64\u5fc5\u987b\u4f7f\u7528 ",(0,i.kt)("inlineCode",{parentName:"p"},"ThreadLocal<Integer>"),"\u3002\u6700\u540e\uff0c\u5728\u8fdb\u884c\u53cd\u5c04\u65b9\u6cd5\u8c03\u7528\u65f6\uff0c\u5fc5\u987b\u4f7f\u7528\u5305\u88c5\u7c7b\u578b\uff08",(0,i.kt)("a",{parentName:"p",href:"./Chapter-9-Item-65-Prefer-interfaces-to-reflection"},"Item-65"),"\uff09\u3002"),(0,i.kt)("p",null,"In summary, use primitives in preference to boxed primitives whenever you have the choice. Primitive types are simpler and faster. If you must use boxed primitives, be careful! ",(0,i.kt)("strong",{parentName:"p"},"Autoboxing reduces the verbosity, but not the danger, of using boxed primitives.")," When your program compares two boxed primitives with the == operator, it does an identity comparison, which is almost certainly not what you want. When your program does mixed-type computations involving boxed and unboxed primitives, it does unboxing, and ",(0,i.kt)("strong",{parentName:"p"},"when your program does unboxing, it can throw a NullPointerException.")," Finally, when your program boxes primitive values, it can result in costly and unnecessary object creations."),(0,i.kt)("p",null,"\u603b\u4e4b\uff0c\u53ea\u8981\u6709\u9009\u62e9\uff0c\u5c31\u5e94\u8be5\u4f18\u5148\u4f7f\u7528\u57fa\u672c\u7c7b\u578b\uff0c\u800c\u4e0d\u662f\u5305\u88c5\u7c7b\u578b\u3002\u57fa\u672c\u7c7b\u578b\u66f4\u7b80\u5355\u3001\u66f4\u5feb\u3002\u5982\u679c\u5fc5\u987b\u4f7f\u7528\u5305\u88c5\u7c7b\u578b\uff0c\u8bf7\u5c0f\u5fc3\uff01",(0,i.kt)("strong",{parentName:"p"},"\u81ea\u52a8\u88c5\u7bb1\u51cf\u5c11\u4e86\u4f7f\u7528\u5305\u88c5\u7c7b\u578b\u7684\u5197\u957f\uff0c\u4f46\u6ca1\u6709\u51cf\u5c11\u5371\u9669\u3002")," \u5f53\u4f60\u7684\u7a0b\u5e8f\u4f7f\u7528 ",(0,i.kt)("inlineCode",{parentName:"p"},"==")," \u64cd\u4f5c\u7b26\u6bd4\u8f83\u4e24\u4e2a\u5305\u88c5\u7c7b\u578b\u65f6\uff0c\u5b83\u4f1a\u6267\u884c\u6807\u8bc6\u6bd4\u8f83\uff0c\u8fd9\u51e0\u4e4e\u80af\u5b9a\u4e0d\u662f\u4f60\u60f3\u8981\u7684\u3002\u5f53\u4f60\u7684\u7a0b\u5e8f\u6267\u884c\u5305\u542b\u5305\u88c5\u7c7b\u578b\u548c\u57fa\u672c\u7c7b\u578b\u7684\u6df7\u5408\u7c7b\u578b\u8ba1\u7b97\u65f6\uff0c\u5b83\u5c06\u8fdb\u884c\u62c6\u7bb1\uff0c",(0,i.kt)("strong",{parentName:"p"},"\u5f53\u4f60\u7684\u7a0b\u5e8f\u6267\u884c\u62c6\u7bb1\u65f6\uff0c\u5c06\u629b\u51fa NullPointerException\u3002")," \u6700\u540e\uff0c\u5f53\u4f60\u7684\u7a0b\u5e8f\u5c06\u57fa\u672c\u7c7b\u578b\u88c5\u7bb1\u65f6\uff0c\u53ef\u80fd\u4f1a\u5bfc\u81f4\u4ee3\u4ef7\u9ad8\u6602\u4e14\u4e0d\u5fc5\u8981\u7684\u5bf9\u8c61\u521b\u5efa\u3002"),(0,i.kt)("hr",null),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("a",{parentName:"strong",href:"./Chapter-9-Introduction"},"Back to contents of the chapter\uff08\u8fd4\u56de\u7ae0\u8282\u76ee\u5f55\uff09"))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Previous Item\uff08\u4e0a\u4e00\u6761\u76ee\uff09\uff1a",(0,i.kt)("a",{parentName:"strong",href:"./Chapter-9-Item-60-Avoid-float-and-double-if-exact-answers-are-required"},"Item 60: Avoid float and double if exact answers are required\uff08\u82e5\u9700\u8981\u7cbe\u786e\u7b54\u6848\u5c31\u5e94\u907f\u514d\u4f7f\u7528 float \u548c double \u7c7b\u578b\uff09"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Next Item\uff08\u4e0b\u4e00\u6761\u76ee\uff09\uff1a",(0,i.kt)("a",{parentName:"strong",href:"./Chapter-9-Item-62-Avoid-strings-where-other-types-are-more-appropriate"},"Item 62: Avoid strings where other types are more appropriate\uff08\u5176\u4ed6\u7c7b\u578b\u66f4\u5408\u9002\u65f6\u5e94\u907f\u514d\u4f7f\u7528\u5b57\u7b26\u4e32\uff09")))))}u.isMDXComponent=!0}}]);