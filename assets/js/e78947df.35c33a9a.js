"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[5860],{3905:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>m});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var p=n.createContext({}),s=function(e){var t=n.useContext(p),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},d=function(e){var t=s(e.components);return n.createElement(p.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,p=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),u=s(a),m=r,h=u["".concat(p,".").concat(m)]||u[m]||c[m]||i;return a?n.createElement(h,o(o({ref:t},d),{},{components:a})):n.createElement(h,o({ref:t},d))}));function m(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=u;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var s=2;s<i;s++)o[s]=a[s];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},436:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>p,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>l,toc:()=>s});var n=a(7462),r=(a(7294),a(3905));const i={},o=void 0,l={unversionedId:"Books/EffectiveJava3/Chapter-5/Chapter-5-Item-31-Use-bounded-wildcards-to-increase-API-flexibility",id:"Books/EffectiveJava3/Chapter-5/Chapter-5-Item-31-Use-bounded-wildcards-to-increase-API-flexibility",title:"Chapter-5-Item-31-Use-bounded-wildcards-to-increase-API-flexibility",description:"Chapter 5. Generics\uff08\u6cdb\u578b\uff09",source:"@site/docs/Books/EffectiveJava3/Chapter-5/Chapter-5-Item-31-Use-bounded-wildcards-to-increase-API-flexibility.md",sourceDirName:"Books/EffectiveJava3/Chapter-5",slug:"/Books/EffectiveJava3/Chapter-5/Chapter-5-Item-31-Use-bounded-wildcards-to-increase-API-flexibility",permalink:"/docs/Books/EffectiveJava3/Chapter-5/Chapter-5-Item-31-Use-bounded-wildcards-to-increase-API-flexibility",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Books/EffectiveJava3/Chapter-5/Chapter-5-Item-31-Use-bounded-wildcards-to-increase-API-flexibility.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Chapter-5-Item-30-Favor-generic-methods",permalink:"/docs/Books/EffectiveJava3/Chapter-5/Chapter-5-Item-30-Favor-generic-methods"},next:{title:"Chapter-5-Item-32-Combine-generics-and-varargs-judiciously",permalink:"/docs/Books/EffectiveJava3/Chapter-5/Chapter-5-Item-32-Combine-generics-and-varargs-judiciously"}},p={},s=[{value:"Chapter 5. Generics\uff08\u6cdb\u578b\uff09",id:"chapter-5-generics\u6cdb\u578b",level:2},{value:"Item 31: Use bounded wildcards to increase API flexibility\uff08\u4f7f\u7528\u6709\u754c\u901a\u914d\u7b26\u589e\u52a0 API \u7684\u7075\u6d3b\u6027\uff09",id:"item-31-use-bounded-wildcards-to-increase-api-flexibility\u4f7f\u7528\u6709\u754c\u901a\u914d\u7b26\u589e\u52a0-api-\u7684\u7075\u6d3b\u6027",level:3}],d={toc:s};function c(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"chapter-5-generics\u6cdb\u578b"},"Chapter 5. Generics\uff08\u6cdb\u578b\uff09"),(0,r.kt)("h3",{id:"item-31-use-bounded-wildcards-to-increase-api-flexibility\u4f7f\u7528\u6709\u754c\u901a\u914d\u7b26\u589e\u52a0-api-\u7684\u7075\u6d3b\u6027"},"Item 31: Use bounded wildcards to increase API flexibility\uff08\u4f7f\u7528\u6709\u754c\u901a\u914d\u7b26\u589e\u52a0 API \u7684\u7075\u6d3b\u6027\uff09"),(0,r.kt)("p",null,"As noted in Item 28, parameterized types are invariant. In other words, for any two distinct types ",(0,r.kt)("inlineCode",{parentName:"p"},"Type1")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Type2"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"List<Type1>")," is neither a subtype nor a supertype of ",(0,r.kt)("inlineCode",{parentName:"p"},"List<Type2>"),". Although it is counterintuitive that ",(0,r.kt)("inlineCode",{parentName:"p"},"List<String>")," is not a subtype of ",(0,r.kt)("inlineCode",{parentName:"p"},"List<Object>"),", it really does make sense. You can put any object into a ",(0,r.kt)("inlineCode",{parentName:"p"},"List<Object>"),", but you can put only strings into a ",(0,r.kt)("inlineCode",{parentName:"p"},"List<String>"),". Since a ",(0,r.kt)("inlineCode",{parentName:"p"},"List<String>")," can\u2019t do everything a ",(0,r.kt)("inlineCode",{parentName:"p"},"List<Object>")," can, it isn\u2019t a subtype (by the Liskov substitution principal, Item 10)."),(0,r.kt)("p",null,"\u5982 ",(0,r.kt)("a",{parentName:"p",href:"./Chapter-5-Item-28-Prefer-lists-to-arrays"},"Item-28")," \u6240\u793a\uff0c\u53c2\u6570\u5316\u7c7b\u578b\u662f\u4e0d\u53ef\u53d8\u7684\u3002\u6362\u53e5\u8bdd\u8bf4\uff0c\u5bf9\u4e8e\u4efb\u610f\u4e24\u79cd\u4e0d\u540c\u7c7b\u578b ",(0,r.kt)("inlineCode",{parentName:"p"},"Type1")," \u548c ",(0,r.kt)("inlineCode",{parentName:"p"},"Type2"),"\uff0c",(0,r.kt)("inlineCode",{parentName:"p"},"List<Type1>")," \u65e2\u4e0d\u662f ",(0,r.kt)("inlineCode",{parentName:"p"},"List<Type2>")," \u7684\u5b50\u7c7b\u578b\uff0c\u4e5f\u4e0d\u662f\u5b83\u7684\u7236\u7c7b\u3002\u867d\u7136 ",(0,r.kt)("inlineCode",{parentName:"p"},"List<String>")," \u4e0d\u662f ",(0,r.kt)("inlineCode",{parentName:"p"},"List<Object>")," \u7684\u5b50\u7c7b\u578b\uff0c\u8fd9\u548c\u4e60\u60ef\u7684\u76f4\u89c9\u4e0d\u7b26\uff0c\u4f46\u5b83\u786e\u5b9e\u6709\u610f\u4e49\u3002\u4f60\u53ef\u4ee5\u5c06\u4efb\u4f55\u5bf9\u8c61\u653e\u5165 ",(0,r.kt)("inlineCode",{parentName:"p"},"List<Object>"),"\uff0c\u4f46\u53ea\u80fd\u5c06\u5b57\u7b26\u4e32\u653e\u5165 ",(0,r.kt)("inlineCode",{parentName:"p"},"List<String>"),"\u3002\u56e0\u4e3a ",(0,r.kt)("inlineCode",{parentName:"p"},"List<String>")," \u4e0d\u80fd\u505a ",(0,r.kt)("inlineCode",{parentName:"p"},"List<Object>")," \u80fd\u505a\u7684\u6240\u6709\u4e8b\u60c5\uff0c\u6240\u4ee5\u5b83\u4e0d\u662f\u5b50\u7c7b\u578b\uff08\u53ef\u901a\u8fc7 Liskov \u66ff\u6362\u539f\u5219\u6765\u7406\u89e3\u8fd9\u4e00\u70b9\uff0c",(0,r.kt)("a",{parentName:"p",href:"./Chapter-3-Item-10-Obey-the-general-contract-when-overriding-equals"},"Item-10"),"\uff09\u3002"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u8bd1\u6ce8\uff1a\u91cc\u6c0f\u66ff\u6362\u539f\u5219\uff08Liskov Substitution Principle\uff0cLSP\uff09\u9762\u5411\u5bf9\u8c61\u8bbe\u8ba1\u7684\u57fa\u672c\u539f\u5219\u4e4b\u4e00\u3002\u91cc\u6c0f\u66ff\u6362\u539f\u5219\u6307\u51fa\uff1a\u4efb\u4f55\u7236\u7c7b\u53ef\u4ee5\u51fa\u73b0\u7684\u5730\u65b9\uff0c\u5b50\u7c7b\u4e00\u5b9a\u53ef\u4ee5\u51fa\u73b0\u3002LSP \u662f\u7ee7\u627f\u590d\u7528\u7684\u57fa\u77f3\uff0c\u53ea\u6709\u5f53\u884d\u751f\u7c7b\u53ef\u4ee5\u66ff\u6362\u6389\u7236\u7c7b\uff0c\u8f6f\u4ef6\u5355\u4f4d\u7684\u529f\u80fd\u4e0d\u53d7\u5230\u5f71\u54cd\u65f6\uff0c\u7236\u7c7b\u624d\u80fd\u771f\u6b63\u88ab\u590d\u7528\uff0c\u800c\u884d\u751f\u7c7b\u4e5f\u80fd\u591f\u5728\u7236\u7c7b\u7684\u57fa\u7840\u4e0a\u589e\u52a0\u65b0\u7684\u884c\u4e3a\u3002")),(0,r.kt)("p",null,"Sometimes you need more flexibility than invariant typing can provide. Consider the Stack class from Item 29. To refresh your memory, here is its public API:"),(0,r.kt)("p",null,"\u6709\u65f6\u4f60\u9700\u8981\u83b7\u5f97\u6bd4\u4e0d\u53ef\u53d8\u7c7b\u578b\u66f4\u591a\u7684\u7075\u6d3b\u6027\u3002\u8003\u8651 ",(0,r.kt)("a",{parentName:"p",href:"./Chapter-5-Item-29-Favor-generic-types"},"Item-29")," \u4e2d\u7684\u5806\u6808\u7c7b\u3002\u4ee5\u4e0b\u662f\u5b83\u7684\u516c\u5171 API\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"public class Stack<E> {\n    public Stack();\n    public void push(E e);\n    public E pop();\n    public boolean isEmpty();\n}\n")),(0,r.kt)("p",null,"Suppose we want to add a method that takes a sequence of elements and pushes them all onto the stack. Here\u2019s a first attempt:"),(0,r.kt)("p",null,"\u5047\u8bbe\u6211\u4eec\u60f3\u6dfb\u52a0\u4e00\u4e2a\u65b9\u6cd5\uff0c\u8be5\u65b9\u6cd5\u63a5\u53d7\u4e00\u7cfb\u5217\u5143\u7d20\u5e76\u5c06\u5b83\u4eec\u5168\u90e8\u63a8\u5165\u5806\u6808\u3002\u8fd9\u662f\u7b2c\u4e00\u6b21\u5c1d\u8bd5\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"// pushAll method without wildcard type - deficient!\npublic void pushAll(Iterable<E> src) {\n    for (E e : src)\n        push(e);\n}\n")),(0,r.kt)("p",null,"This method compiles cleanly, but it isn\u2019t entirely satisfactory. If the element type of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Iterable src")," exactly matches that of the stack, it works fine. But suppose you have a ",(0,r.kt)("inlineCode",{parentName:"p"},"Stack<Number>")," and you invoke ",(0,r.kt)("inlineCode",{parentName:"p"},"push(intVal)"),", where ",(0,r.kt)("inlineCode",{parentName:"p"},"intVal")," is of type ",(0,r.kt)("inlineCode",{parentName:"p"},"Integer"),". This works because ",(0,r.kt)("inlineCode",{parentName:"p"},"Integer")," is a subtype of ",(0,r.kt)("inlineCode",{parentName:"p"},"Number"),". So logically, it seems that this should work, too:"),(0,r.kt)("p",null,"\u8be5\u65b9\u6cd5\u80fd\u591f\u6b63\u786e\u7f16\u8bd1\uff0c\u4f46\u5e76\u4e0d\u5b8c\u5168\u4ee4\u4eba\u6ee1\u610f\u3002\u5982\u679c ",(0,r.kt)("inlineCode",{parentName:"p"},"Iterable src")," \u7684\u5143\u7d20\u7c7b\u578b\u4e0e\u5806\u6808\u7684\u5143\u7d20\u7c7b\u578b\u5b8c\u5168\u5339\u914d\uff0c\u90a3\u4e48\u5b83\u6b63\u5e38\u5de5\u4f5c\u3002\u4f46\u662f\u5047\u8bbe\u4f60\u6709\u4e00\u4e2a ",(0,r.kt)("inlineCode",{parentName:"p"},"Stack<Number>"),"\uff0c\u5e76\u4e14\u8c03\u7528 ",(0,r.kt)("inlineCode",{parentName:"p"},"push(intVal)"),"\uff0c\u5176\u4e2d ",(0,r.kt)("inlineCode",{parentName:"p"},"intVal")," \u7684\u7c7b\u578b\u662f ",(0,r.kt)("inlineCode",{parentName:"p"},"Integer"),"\u3002\u8fd9\u662f\u53ef\u884c\u7684\uff0c\u56e0\u4e3a ",(0,r.kt)("inlineCode",{parentName:"p"},"Integer")," \u662f ",(0,r.kt)("inlineCode",{parentName:"p"},"Number")," \u7684\u5b50\u7c7b\u578b\u3002\u56e0\u6b64\uff0c\u4ece\u903b\u8f91\u4e0a\u8bb2\uff0c\u8fd9\u4f3c\u4e4e\u4e5f\u5e94\u8be5\u594f\u6548\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Stack<Number> numberStack = new Stack<>();\nIterable<Integer> integers = ... ;\nnumberStack.pushAll(integers);\n")),(0,r.kt)("p",null,"If you try it, however, you\u2019ll get this error message because parameterized types are invariant:"),(0,r.kt)("p",null,"\u4f46\u662f\uff0c\u5982\u679c\u4f60\u5c1d\u8bd5\u4e00\u4e0b\uff0c\u5c06\u4f1a\u5f97\u5230\u8fd9\u4e2a\u9519\u8bef\u6d88\u606f\uff0c\u56e0\u4e3a\u53c2\u6570\u5316\u7c7b\u578b\u662f\u4e0d\u53ef\u53d8\u7684\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"StackTest.java:7: error: incompatible types: Iterable<Integer>\ncannot be converted to Iterable<Number>\n        numberStack.pushAll(integers);\n                    ^\n")),(0,r.kt)("p",null,"Luckily, there\u2019s a way out. The language provides a special kind of parameterized type call a bounded wildcard type to deal with situations like this. The type of the input parameter to pushAll should not be \u201cIterable of E\u201d but \u201cIterable of some subtype of E,\u201d and there is a wildcard type that means precisely that: Iterable<? extends E>. (The use of the keyword extends is slightly misleading: recall from Item 29 that subtype is defined so that every type is a subtype of itself, even though it does not extend itself.) Let\u2019s modify pushAll to use this type:"),(0,r.kt)("p",null,"\u5e78\u8fd0\u7684\u662f\uff0c\u6709\u4e00\u79cd\u89e3\u51b3\u65b9\u6cd5\u3002Java \u63d0\u4f9b\u4e86\u4e00\u79cd\u7279\u6b8a\u7684\u53c2\u6570\u5316\u7c7b\u578b\uff0c",(0,r.kt)("inlineCode",{parentName:"p"},"\u6709\u754c\u901a\u914d\u7b26\u7c7b\u578b"),"\u6765\u5904\u7406\u8fd9\u79cd\u60c5\u51b5\u3002pushAll \u7684\u8f93\u5165\u53c2\u6570\u7684\u7c7b\u578b\u4e0d\u5e94\u8be5\u662f\u300cE \u7684 Iterable \u63a5\u53e3\u300d\uff0c\u800c\u5e94\u8be5\u662f\u300cE \u7684\u67d0\u4e2a\u5b50\u7c7b\u578b\u7684 Iterable \u63a5\u53e3\u300d\uff0c\u5e76\u4e14\u6709\u4e00\u4e2a\u901a\u914d\u7b26\u7c7b\u578b\uff0c\u5b83\u7684\u786e\u5207\u542b\u4e49\u662f\uff1a",(0,r.kt)("inlineCode",{parentName:"p"},"Iterable<? extends E>"),"\uff08\u5173\u952e\u5b57 extends \u7684\u4f7f\u7528\u7a0d\u5fae\u6709\u4e9b\u8bef\u5bfc\uff1a\u56de\u60f3\u4e00\u4e0b ",(0,r.kt)("a",{parentName:"p",href:"./Chapter-5-Item-29-Favor-generic-types"},"Item-29"),"\uff0c\u5b9a\u4e49\u4e86\u5b50\u7c7b\u578b\uff0c\u4ee5\u4fbf\u6bcf\u4e2a\u7c7b\u578b\u90fd\u662f\u5176\u672c\u8eab\u7684\u5b50\u7c7b\u578b\uff0c\u5373\u4f7f\u5b83\u6ca1\u6709\u6269\u5c55\u81ea\u5df1\u3002\uff09\u8ba9\u6211\u4eec\u4fee\u6539 pushAll \u6765\u4f7f\u7528\u8fd9\u79cd\u7c7b\u578b\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"// Wildcard type for a parameter that serves as an E producer\npublic void pushAll(Iterable<? extends E> src) {\n    for (E e : src)\n        push(e);\n}\n")),(0,r.kt)("p",null,"With this change, not only does Stack compile cleanly, but so does the client code that wouldn\u2019t compile with the original pushAll declaration. Because Stack and its client compile cleanly, you know that everything is typesafe. Now suppose you want to write a popAll method to go with pushAll. The popAll method pops each element off the stack and adds the elements to the given collection. Here\u2019s how a first attempt at writing the popAll method might look:"),(0,r.kt)("p",null,"\u66f4\u6539\u4e4b\u540e\uff0c\u4e0d\u4ec5 Stack \u53ef\u4ee5\u6b63\u786e\u7f16\u8bd1\uff0c\u800c\u4e14\u4e0d\u80fd\u7528\u539f\u59cb pushAll \u58f0\u660e\u7f16\u8bd1\u7684\u5ba2\u6237\u7aef\u4ee3\u7801\u4e5f\u53ef\u4ee5\u6b63\u786e\u7f16\u8bd1\u3002\u56e0\u4e3a Stack \u548c\u5b83\u7684\u5ba2\u6237\u7aef\u53ef\u4ee5\u6b63\u786e\u7f16\u8bd1\uff0c\u6240\u4ee5\u4f60\u77e5\u9053\u6240\u6709\u4e1c\u897f\u90fd\u662f\u7c7b\u578b\u5b89\u5168\u7684\u3002\u73b0\u5728\u5047\u8bbe\u4f60\u60f3\u7f16\u5199\u4e00\u4e2a\u4e0e pushAll \u4e00\u8d77\u4f7f\u7528\u7684 popAll \u65b9\u6cd5\u3002popAll \u65b9\u6cd5\u5c06\u6bcf\u4e2a\u5143\u7d20\u4ece\u5806\u6808\u4e2d\u5f39\u51fa\uff0c\u5e76\u5c06\u8fd9\u4e9b\u5143\u7d20\u6dfb\u52a0\u5230\u7ed9\u5b9a\u7684\u96c6\u5408\u4e2d\u3002\u4e0b\u9762\u662f\u7f16\u5199 popAll \u65b9\u6cd5\u7684\u7b2c\u4e00\u6b21\u5c1d\u8bd5\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"// popAll method without wildcard type - deficient!\npublic void popAll(Collection<E> dst) {\n    while (!isEmpty())\n        dst.add(pop());\n}\n")),(0,r.kt)("p",null,"Again, this compiles cleanly and works fine if the element type of the destination collection exactly matches that of the stack. But again, it isn\u2019t entirely satisfactory. Suppose you have a ",(0,r.kt)("inlineCode",{parentName:"p"},"Stack<Number>")," and variable of type Object. If you pop an element from the stack and store it in the variable, it compiles and runs without error. So shouldn\u2019t you be able to do this, too?"),(0,r.kt)("p",null,"\u540c\u6837\uff0c\u5982\u679c\u76ee\u6807\u96c6\u5408\u7684\u5143\u7d20\u7c7b\u578b\u4e0e\u5806\u6808\u7684\u5143\u7d20\u7c7b\u578b\u5b8c\u5168\u5339\u914d\uff0c\u90a3\u4e48\u8fd9\u79cd\u65b9\u6cd5\u53ef\u4ee5\u5f88\u597d\u5730\u7f16\u8bd1\u3002\u4f46\u8fd9\u4e5f\u4e0d\u662f\u5b8c\u5168\u4ee4\u4eba\u6ee1\u610f\u3002\u5047\u8bbe\u4f60\u6709\u4e00\u4e2a ",(0,r.kt)("inlineCode",{parentName:"p"},"Stack<Number>")," \u548c Object \u7c7b\u578b\u7684\u53d8\u91cf\u3002\u5982\u679c\u4ece\u5806\u6808\u4e2d\u53d6\u51fa\u4e00\u4e2a\u5143\u7d20\u5e76\u5c06\u5176\u5b58\u50a8\u5728\u53d8\u91cf\u4e2d\uff0c\u90a3\u4e48\u5b83\u5c06\u7f16\u8bd1\u5e76\u8fd0\u884c\uff0c\u4e0d\u4f1a\u51fa\u9519\u3002\u6240\u4ee5\u4f60\u4e0d\u80fd\u4e5f\u8fd9\u6837\u505a\u5417\uff1f"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Stack<Number> numberStack = new Stack<Number>();\nCollection<Object> objects = ... ;\nnumberStack.popAll(objects);\n")),(0,r.kt)("p",null,"If you try to compile this client code against the version of popAll shown earlier, you\u2019ll get an error very similar to the one that we got with our first version of pushAll: ",(0,r.kt)("inlineCode",{parentName:"p"},"Collection<Object>")," is not a subtype of ",(0,r.kt)("inlineCode",{parentName:"p"},"Collection<Number>"),". Once again, wildcard types provide a way out. The type of the input parameter to popAll should not be \u201ccollection of E\u201d but \u201ccollection of some supertype of E\u201d (where supertype is defined such that E is a supertype of itself ","[JLS, 4.10]","). Again, there is a wildcard type that means precisely that: Collection<? super E>. Let\u2019s modify popAll to use it:"),(0,r.kt)("p",null,"\u5982\u679c\u4f60\u5c1d\u8bd5\u6839\u636e\u524d\u9762\u663e\u793a\u7684 popAll \u7248\u672c\u7f16\u8bd1\u6b64\u5ba2\u6237\u7aef\u4ee3\u7801\uff0c\u4f60\u5c06\u5f97\u5230\u4e00\u4e2a\u4e0e\u7b2c\u4e00\u4e2a\u7248\u672c\u7684 pushAll \u975e\u5e38\u76f8\u4f3c\u7684\u9519\u8bef\uff1a",(0,r.kt)("inlineCode",{parentName:"p"},"Collection<Object>"),"\u4e0d\u662f ",(0,r.kt)("inlineCode",{parentName:"p"},"Collection<Number>")," \u7684\u5b50\u7c7b\u578b\u3002\u540c\u6837\uff0c\u901a\u914d\u7b26\u7c7b\u578b\u63d0\u4f9b\u89e3\u51b3\u65b9\u6cd5\u3002popAll \u7684\u8f93\u5165\u53c2\u6570\u7684\u7c7b\u578b\u4e0d\u5e94\u8be5\u662f\u300cE \u7684\u96c6\u5408\u300d\uff0c\u800c\u5e94\u8be5\u662f\u300cE \u7684\u67d0\u4e2a\u8d85\u7c7b\u578b\u7684\u96c6\u5408\u300d\uff08\u5176\u4e2d\u7684\u8d85\u7c7b\u578b\u5b9a\u4e49\u4e3a E \u672c\u8eab\u662f\u4e00\u4e2a\u8d85\u7c7b\u578b","[JLS, 4.10]","\uff09\u3002\u540c\u6837\uff0c\u6709\u4e00\u4e2a\u901a\u914d\u7b26\u7c7b\u578b\uff0c\u5b83\u7684\u786e\u5207\u542b\u4e49\u662f\uff1a",(0,r.kt)("inlineCode",{parentName:"p"},"Collection<? super E>"),"\u3002\u8ba9\u6211\u4eec\u4fee\u6539 popAll \u6765\u4f7f\u7528\u5b83\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"// Wildcard type for parameter that serves as an E consumer\npublic void popAll(Collection<? super E> dst) {\n  while (!isEmpty())\n    dst.add(pop());\n}\n")),(0,r.kt)("p",null,"With this change, both Stack and the client code compile cleanly."),(0,r.kt)("p",null,"\u901a\u8fc7\u6b64\u66f4\u6539\uff0cStack \u7c7b\u548c\u5ba2\u6237\u7aef\u4ee3\u7801\u90fd\u53ef\u4ee5\u6b63\u786e\u7f16\u8bd1\u3002"),(0,r.kt)("p",null,"The lesson is clear. ",(0,r.kt)("strong",{parentName:"p"},"For maximum flexibility, use wildcard types on input parameters that represent producers or consumers.")," If an input parameter is both a producer and a consumer, then wildcard types will do you no good: you need an exact type match, which is what you get without any wildcards. Here is a mnemonic to help you remember which wildcard type to use:"),(0,r.kt)("p",null,"\u6559\u8bad\u662f\u6e05\u695a\u7684\u3002\u4e3a\u4e86\u83b7\u5f97\u6700\u5927\u7684\u7075\u6d3b\u6027\uff0c\u5e94\u5728\u8868\u793a\u751f\u4ea7\u8005\u6216\u6d88\u8d39\u8005\u7684\u8f93\u5165\u53c2\u6570\u4e0a\u4f7f\u7528\u901a\u914d\u7b26\u7c7b\u578b\u3002\u5982\u679c\u8f93\u5165\u53c2\u6570\u65e2\u662f\u751f\u4ea7\u8005\u53c8\u662f\u6d88\u8d39\u8005\uff0c\u90a3\u4e48\u901a\u914d\u7b26\u7c7b\u578b\u5bf9\u4f60\u6ca1\u6709\u4efb\u4f55\u597d\u5904\uff1a\u4f60\u9700\u8981\u4e00\u4e2a\u7cbe\u786e\u7684\u7c7b\u578b\u5339\u914d\uff0c\u8fd9\u5c31\u662f\u5728\u6ca1\u6709\u901a\u914d\u7b26\u7684\u60c5\u51b5\u4e0b\u5f97\u5230\u7684\u7ed3\u679c\u3002\u8fd9\u91cc\u6709\u4e00\u4e2a\u52a9\u8bb0\u7b26\u5e2e\u52a9\u4f60\u8bb0\u4f4f\u4f7f\u7528\u54ea\u79cd\u901a\u914d\u7b26\u7c7b\u578b\uff1a"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"PECS stands for producer-extends, consumer-super.")),(0,r.kt)("p",null,"PECS \u8868\u793a\u751f\u4ea7\u8005\u5e94\u4f7f\u7528 extends\uff0c\u6d88\u8d39\u8005\u5e94\u4f7f\u7528 super\u3002"),(0,r.kt)("p",null,"In other words, if a parameterized type represents a T producer, use ",(0,r.kt)("inlineCode",{parentName:"p"},"<? extends T>"),"; if it represents a T consumer, use ",(0,r.kt)("inlineCode",{parentName:"p"},"<? super T>"),". In our Stack example, pushAll\u2019s src parameter produces E instances for use by the Stack, so the appropriate type for src is ",(0,r.kt)("inlineCode",{parentName:"p"},"Iterable<? extends E>"),"; popAll\u2019s dst parameter consumes E instances from the Stack, so the appropriate type for dst is ",(0,r.kt)("inlineCode",{parentName:"p"},"Collection<? super E>"),". The PECS mnemonic captures the fundamental principle that guides the use of wild-card types. Naftalin and Wadler call it the Get and Put Principle ","[Naftalin07, 2.4]","."),(0,r.kt)("p",null,"\u6362\u53e5\u8bdd\u8bf4\uff0c\u5982\u679c\u53c2\u6570\u5316\u7c7b\u578b\u8868\u793a T \u751f\u6210\u5668\uff0c\u5219\u4f7f\u7528 ",(0,r.kt)("inlineCode",{parentName:"p"},"<? extends T>"),"\uff1b\u5982\u679c\u5b83\u8868\u793a\u4e00\u4e2a T \u6d88\u8d39\u8005\uff0c\u5219\u4f7f\u7528 ",(0,r.kt)("inlineCode",{parentName:"p"},"<? super T>"),"\u3002\u5728\u6211\u4eec\u7684 Stack \u793a\u4f8b\u4e2d\uff0cpushAll \u7684 src \u53c2\u6570\u751f\u6210 E \u7684\u5b9e\u4f8b\u4f9b Stack \u4f7f\u7528\uff0c\u56e0\u6b64 src \u7684\u9002\u5f53\u7c7b\u578b\u662f ",(0,r.kt)("inlineCode",{parentName:"p"},"Iterable<? extends E>"),"\uff1bpopAll \u7684 dst \u53c2\u6570\u4f7f\u7528 Stack \u4e2d\u7684 E \u5b9e\u4f8b\uff0c\u56e0\u6b64\u9002\u5408 dst \u7684\u7c7b\u578b\u662f ",(0,r.kt)("inlineCode",{parentName:"p"},"Collection<? super E>"),"\u3002PECS \u52a9\u8bb0\u7b26\u6355\u83b7\u4e86\u6307\u5bfc\u901a\u914d\u7b26\u7c7b\u578b\u4f7f\u7528\u7684\u57fa\u672c\u539f\u5219\u3002Naftalin \u548c Wadler \u79f0\u4e4b\u4e3a Get and Put \u539f\u5219","[Naftalin07, 2.4]","\u3002"),(0,r.kt)("p",null,"With this mnemonic in mind, let\u2019s take a look at some method and constructor declarations from previous items in this chapter. The Chooser constructor in Item 28 has this declaration:"),(0,r.kt)("p",null,"\u8bb0\u4f4f\u8fd9\u4e2a\u52a9\u8bb0\u7b26\u540e\uff0c\u518d\u8ba9\u6211\u4eec\u770b\u4e00\u770b\u672c\u7ae0\u524d\u9762\u63d0\u53ca\u7684\u4e00\u4e9b\u65b9\u6cd5\u548c\u6784\u9020\u51fd\u6570\u58f0\u660e\u3002",(0,r.kt)("a",{parentName:"p",href:"./Chapter-5-Item-28-Prefer-lists-to-arrays"},"Item-28")," \u4e2d\u7684 Chooser \u6784\u9020\u51fd\u6570\u6709\u5982\u4e0b\u58f0\u660e\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"public Chooser(Collection<T> choices)\n")),(0,r.kt)("p",null,"This constructor uses the collection choices only to produce values of type T (and stores them for later use), so its declaration should use a wildcard type that ",(0,r.kt)("strong",{parentName:"p"},"extends T.")," Here\u2019s the resulting constructor declaration:"),(0,r.kt)("p",null,"\u8fd9\u4e2a\u6784\u9020\u51fd\u6570\u53ea\u4f7f\u7528\u96c6\u5408\u9009\u9879\u6765\u751f\u6210\u7c7b\u578b T \u7684\u503c\uff08\u5e76\u5b58\u50a8\u5b83\u4eec\u4ee5\u4f9b\u4ee5\u540e\u4f7f\u7528\uff09\uff0c\u56e0\u6b64\u5b83\u7684\u58f0\u660e\u5e94\u8be5\u4f7f\u7528\u6269\u5c55 T \u7684\u901a\u914d\u7b26\u7c7b\u578b ",(0,r.kt)("strong",{parentName:"p"},"extends T"),"\u3002\u4e0b\u9762\u662f\u751f\u6210\u7684\u6784\u9020\u51fd\u6570\u58f0\u660e\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"// Wildcard type for parameter that serves as an T producer\npublic Chooser(Collection<? extends T> choices)\n")),(0,r.kt)("p",null,"And would this change make any difference in practice? Yes, it would. Suppose you have a ",(0,r.kt)("inlineCode",{parentName:"p"},"List<Integer>"),", and you want to pass it in to the constructor for a ",(0,r.kt)("inlineCode",{parentName:"p"},"Chooser<Number>"),". This would not compile with the original declaration, but it does once you add the bounded wildcard type to the declaration."),(0,r.kt)("p",null,"\u8fd9\u79cd\u6539\u53d8\u5728\u5b9e\u8df5\u4e2d\u4f1a\u6709\u4ec0\u4e48\u4e0d\u540c\u5417\uff1f\u662f\u7684\uff0c\u5b83\u4f1a\u3002\u5047\u8bbe\u4f60\u6709\u4e00\u4e2a ",(0,r.kt)("inlineCode",{parentName:"p"},"List<Integer>"),"\uff0c\u5e76\u4e14\u5e0c\u671b\u5c06\u5176\u4f20\u9012\u7ed9 ",(0,r.kt)("inlineCode",{parentName:"p"},"Chooser<Number>")," \u7684\u6784\u9020\u51fd\u6570\u3002\u8fd9\u4e0d\u4f1a\u4e0e\u539f\u59cb\u58f0\u660e\u4e00\u8d77\u7f16\u8bd1\uff0c\u4f46\u662f\u4e00\u65e6\u4f60\u5c06\u6709\u754c\u901a\u914d\u7b26\u7c7b\u578b\u6dfb\u52a0\u5230\u58f0\u660e\u4e2d\uff0c\u5b83\u5c31\u4f1a\u7f16\u8bd1\u3002"),(0,r.kt)("p",null,"Now let\u2019s look at the union method from Item 30. Here is the declaration:"),(0,r.kt)("p",null,"\u73b0\u5728\u8ba9\u6211\u4eec\u770b\u770b ",(0,r.kt)("a",{parentName:"p",href:"./Chapter-5-Item-30-Favor-generic-methods"},"Item-30")," \u4e2d\u7684 union \u65b9\u6cd5\u3002\u4ee5\u4e0b\u662f\u58f0\u660e\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"public static <E> Set<E> union(Set<E> s1, Set<E> s2)\n")),(0,r.kt)("p",null,"Both parameters, s1 and s2, are E producers, so the PECS mnemonic tells us that the declaration should be as follows:"),(0,r.kt)("p",null,"\u53c2\u6570 s1 \u548c s2 \u90fd\u662f E \u7684\u751f\u4ea7\u8005\uff0c\u56e0\u6b64 PECS \u52a9\u8bb0\u7b26\u544a\u8bc9\u6211\u4eec\u58f0\u660e\u5e94\u8be5\u5982\u4e0b\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"public static <E> Set<E> union(Set<? extends E> s1,Set<? extends E> s2)\n")),(0,r.kt)("p",null,"Note that the return type is still ",(0,r.kt)("inlineCode",{parentName:"p"},"Set<E>"),". ",(0,r.kt)("strong",{parentName:"p"},"Do not use bounded wildcard types as return types.")," Rather than providing additional flexibility for your users, it would force them to use wildcard types in client code. With the revised declaration, this code will compile cleanly:"),(0,r.kt)("p",null,"\u6ce8\u610f\uff0c\u8fd4\u56de\u7c7b\u578b\u4ecd\u7136\u8bbe\u7f6e\u4e3a ",(0,r.kt)("inlineCode",{parentName:"p"},"Set<E>"),"\u3002",(0,r.kt)("strong",{parentName:"p"},"\u4e0d\u8981\u4f7f\u7528\u6709\u754c\u901a\u914d\u7b26\u7c7b\u578b\u4f5c\u4e3a\u8fd4\u56de\u7c7b\u578b\u3002")," \u5b83\u5c06\u5f3a\u5236\u7528\u6237\u5728\u5ba2\u6237\u7aef\u4ee3\u7801\u4e2d\u4f7f\u7528\u901a\u914d\u7b26\u7c7b\u578b\uff0c\u800c\u4e0d\u662f\u4e3a\u7528\u6237\u63d0\u4f9b\u989d\u5916\u7684\u7075\u6d3b\u6027\u3002\u7ecf\u4fee\u8ba2\u540e\u7684\u58f0\u660e\u53ef\u6b63\u786e\u7f16\u8bd1\u4ee5\u4e0b\u4ee3\u7801\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Set<Integer> integers = Set.of(1, 3, 5);\nSet<Double> doubles = Set.of(2.0, 4.0, 6.0);\nSet<Number> numbers = union(integers, doubles);\n")),(0,r.kt)("p",null,"Properly used, wildcard types are nearly invisible to the users of a class. They cause methods to accept the parameters they should accept and reject those they should reject. ",(0,r.kt)("strong",{parentName:"p"},"If the user of a class has to think about wildcard types, there is probably something wrong with its API.")),(0,r.kt)("p",null,"\u5982\u679c\u4f7f\u7528\u5f97\u5f53\uff0c\u901a\u914d\u7b26\u7c7b\u578b\u5bf9\u4e8e\u7c7b\u7684\u7528\u6237\u51e0\u4e4e\u662f\u4e0d\u53ef\u89c1\u7684\u3002\u5b83\u4eec\u8ba9\u65b9\u6cd5\u63a5\u53d7\u5b83\u4eec\u5e94\u8be5\u63a5\u53d7\u7684\u53c2\u6570\uff0c\u62d2\u7edd\u5e94\u8be5\u62d2\u7edd\u7684\u53c2\u6570\u3002",(0,r.kt)("strong",{parentName:"p"},"\u5982\u679c\u7c7b\u7684\u7528\u6237\u5fc5\u987b\u8003\u8651\u901a\u914d\u7b26\u7c7b\u578b\uff0c\u90a3\u4e48\u5b83\u7684 API \u53ef\u80fd\u6709\u95ee\u9898\u3002")),(0,r.kt)("p",null,"Prior to Java 8, the type inference rules were not clever enough to handle the previous code fragment, which requires the compiler to use the contextually specified return type (or target type) to infer the type of E. The target type of the union invocation shown earlier is ",(0,r.kt)("inlineCode",{parentName:"p"},"Set<Number>"),". If you try to compile the fragment in an earlier version of Java (with an appropriate replacement for the Set.of factory), you\u2019ll get a long, convoluted error message like this:"),(0,r.kt)("p",null,"\u5728 Java 8 \u4e4b\u524d\uff0c\u7c7b\u578b\u63a8\u65ad\u89c4\u5219\u8fd8\u4e0d\u8db3\u4ee5\u5904\u7406\u524d\u9762\u7684\u4ee3\u7801\u7247\u6bb5\uff0c\u8fd9\u8981\u6c42\u7f16\u8bd1\u5668\u4f7f\u7528\u4e0a\u4e0b\u6587\u6307\u5b9a\u7684\u8fd4\u56de\u7c7b\u578b\uff08\u6216\u76ee\u6807\u7c7b\u578b\uff09\u6765\u63a8\u65ad E \u7684\u7c7b\u578b\u3002\u524d\u9762\u663e\u793a\u7684 union \u8c03\u7528\u7684\u76ee\u6807\u7c7b\u578b\u8bbe\u7f6e\u4e3a ",(0,r.kt)("inlineCode",{parentName:"p"},"Set<Number>")," \u5982\u679c\u4f60\u5c1d\u8bd5\u5728 Java \u7684\u65e9\u671f\u7248\u672c\u4e2d\u7f16\u8bd1\u8be5\u7247\u6bb5\uff08\u4f7f\u7528 Set.of factory \u7684\u9002\u5f53\u66ff\u4ee3\uff09\uff0c\u4f60\u5c06\u5f97\u5230\u4e00\u6761\u957f\u800c\u590d\u6742\u7684\u9519\u8bef\u6d88\u606f\uff0c\u5982\u4e0b\u6240\u793a\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Union.java:14: error: incompatible types\nSet<Number> numbers = union(integers, doubles);\n^ required: Set<Number>\nfound: Set<INT#1>\nwhere INT#1,INT#2 are intersection types:\nINT#1 extends Number,Comparable<? extends INT#2>\nINT#2 extends Number,Comparable<?>\n")),(0,r.kt)("p",null,"Luckily there is a way to deal with this sort of error. If the compiler doesn\u2019t infer the correct type, you can always tell it what type to use with an explicit type argument ","[JLS, 15.12]",". Even prior to the introduction of target typing in Java 8, this isn\u2019t something that you had to do often, which is good because explicit type arguments aren\u2019t very pretty. With the addition of an explicit type argument, as shown here, the code fragment compiles cleanly in versions prior to Java 8:"),(0,r.kt)("p",null,"\u5e78\u8fd0\u7684\u662f\uff0c\u6709\u4e00\u79cd\u65b9\u6cd5\u53ef\u4ee5\u5904\u7406\u8fd9\u79cd\u9519\u8bef\u3002\u5982\u679c\u7f16\u8bd1\u5668\u6ca1\u6709\u63a8\u65ad\u51fa\u6b63\u786e\u7684\u7c7b\u578b\uff0c\u4f60\u603b\u662f\u53ef\u4ee5\u544a\u8bc9\u5b83\u4f7f\u7528\u663e\u5f0f\u7c7b\u578b\u53c2\u6570","[JLS, 15.12]","\u4f7f\u7528\u4ec0\u4e48\u7c7b\u578b\u3002\u5373\u4f7f\u5728 Java 8 \u4e2d\u5f15\u5165\u76ee\u6807\u7c7b\u578b\u4e4b\u524d\uff0c\u8fd9\u4e5f\u4e0d\u662f\u5fc5\u987b\u7ecf\u5e38\u505a\u7684\u4e8b\u60c5\uff0c\u8fd9\u5f88\u597d\uff0c\u56e0\u4e3a\u663e\u5f0f\u7c7b\u578b\u53c2\u6570\u4e0d\u662f\u5f88\u6f02\u4eae\u3002\u901a\u8fc7\u6dfb\u52a0\u663e\u5f0f\u7c7b\u578b\u53c2\u6570\uff0c\u5982\u4e0b\u6240\u793a\uff0c\u4ee3\u7801\u7247\u6bb5\u53ef\u4ee5\u5728 Java 8 \u4e4b\u524d\u7684\u7248\u672c\u4e2d\u6b63\u786e\u7f16\u8bd1\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"// Explicit type parameter - required prior to Java 8\nSet<Number> numbers = Union.<Number>union(integers, doubles);\n")),(0,r.kt)("p",null,"Next let\u2019s turn our attention to the max method in Item 30. Here is the original declaration:"),(0,r.kt)("p",null,"\u63a5\u4e0b\u6765\u8ba9\u6211\u4eec\u5c06\u6ce8\u610f\u529b\u8f6c\u5230 ",(0,r.kt)("a",{parentName:"p",href:"./Chapter-5-Item-30-Favor-generic-methods"},"Item-30")," \u4e2d\u7684 max \u65b9\u6cd5\u3002\u4ee5\u4e0b\u662f\u539f\u59cb\u58f0\u660e\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"public static <T extends Comparable<T>> T max(List<T> list)\n")),(0,r.kt)("p",null,"Here is a revised declaration that uses wildcard types:"),(0,r.kt)("p",null,"\u4e0b\u9762\u662f\u4f7f\u7528\u901a\u914d\u7b26\u7c7b\u578b\u7684\u4fee\u6b63\u58f0\u660e\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"public static <T extends Comparable<? super T>> T max(List<? extends T> list)\n")),(0,r.kt)("p",null,"To get the revised declaration from the original, we applied the PECS heuristic twice. The straightforward application is to the parameter list. It produces T instances, so we change the type from ",(0,r.kt)("inlineCode",{parentName:"p"},"List<T>")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"List<? extends T>"),". The tricky application is to the type parameter T. This is the first time we\u2019ve seen a wildcard applied to a type parameter. Originally, T was specified to extend ",(0,r.kt)("inlineCode",{parentName:"p"},"Comparable<T>"),", but a comparable of T consumes T instances (and produces integers indicating order relations). Therefore, the parameterized type ",(0,r.kt)("inlineCode",{parentName:"p"},"Comparable<T>")," is replaced by the bounded wildcard type ",(0,r.kt)("inlineCode",{parentName:"p"},"Comparable<? super T>"),". Comparables are always consumers, so you should generally ",(0,r.kt)("strong",{parentName:"p"},"use ",(0,r.kt)("inlineCode",{parentName:"strong"},"Comparable<? super T>")," in preference to ",(0,r.kt)("inlineCode",{parentName:"strong"},"Comparable<T>"),".")," The same is true of comparators; therefore, you should generally ",(0,r.kt)("strong",{parentName:"p"},"use ",(0,r.kt)("inlineCode",{parentName:"strong"},"Comparator<? super T>")," in preference to ",(0,r.kt)("inlineCode",{parentName:"strong"},"Comparator<T>"),".")),(0,r.kt)("p",null,"\u4e3a\u4e86\u4ece\u539f\u59cb\u58f0\u660e\u4e2d\u5f97\u5230\u4fee\u6539\u540e\u7684\u58f0\u660e\uff0c\u6211\u4eec\u4e24\u6b21\u5e94\u7528\u4e86 PECS \u542f\u53d1\u5f0f\u3002\u76f4\u63a5\u7684\u5e94\u7528\u7a0b\u5e8f\u662f\u53c2\u6570\u5217\u8868\u3002\u5b83\u751f\u6210 T \u7684\u5b9e\u4f8b\uff0c\u6240\u4ee5\u6211\u4eec\u5c06\u7c7b\u578b\u4ece ",(0,r.kt)("inlineCode",{parentName:"p"},"List<T>")," \u66f4\u6539\u4e3a ",(0,r.kt)("inlineCode",{parentName:"p"},"List<? extends T>"),"\u3002\u590d\u6742\u7684\u5e94\u7528\u662f\u7c7b\u578b\u53c2\u6570 T\u3002\u8fd9\u662f\u6211\u4eec\u7b2c\u4e00\u6b21\u770b\u5230\u901a\u914d\u7b26\u5e94\u7528\u4e8e\u7c7b\u578b\u53c2\u6570\u3002\u6700\u521d\uff0cT \u88ab\u6307\u5b9a\u4e3a\u6269\u5c55 ",(0,r.kt)("inlineCode",{parentName:"p"},"Comparable<T>"),"\uff0c\u4f46\u662f T \u7684 Comparable \u6d88\u8d39 T \u5b9e\u4f8b\uff08\u5e76\u751f\u6210\u6307\u793a\u987a\u5e8f\u5173\u7cfb\u7684\u6574\u6570\uff09\u3002\u56e0\u6b64\uff0c\u5c06\u53c2\u6570\u5316\u7c7b\u578b ",(0,r.kt)("inlineCode",{parentName:"p"},"Comparable<T>")," \u66ff\u6362\u4e3a\u6709\u754c\u901a\u914d\u7b26\u7c7b\u578b ",(0,r.kt)("inlineCode",{parentName:"p"},"Comparable<? super T>"),"\uff0cComparables \u59cb\u7ec8\u662f\u6d88\u8d39\u8005\uff0c\u6240\u4ee5\u4e00\u822c\u5e94",(0,r.kt)("strong",{parentName:"p"},"\u4f18\u5148\u4f7f\u7528 ",(0,r.kt)("inlineCode",{parentName:"strong"},"Comparable<? super T>")," \u800c\u4e0d\u662f ",(0,r.kt)("inlineCode",{parentName:"strong"},"Comparable<T>")),"\uff0c\u6bd4\u8f83\u5668\u4e5f\u662f\u5982\u6b64\uff1b\u56e0\u6b64\uff0c\u901a\u5e38\u5e94\u8be5",(0,r.kt)("strong",{parentName:"p"},"\u4f18\u5148\u4f7f\u7528 ",(0,r.kt)("inlineCode",{parentName:"strong"},"Comparator<? super T>")," \u800c\u4e0d\u662f ",(0,r.kt)("inlineCode",{parentName:"strong"},"Comparator<T>"),"\u3002")),(0,r.kt)("p",null,"The revised max declaration is probably the most complex method declaration in this book. Does the added complexity really buy you anything? Again, it does. Here is a simple example of a list that would be excluded by the original declaration but is permitted by the revised one:"),(0,r.kt)("p",null,"\u4fee\u8ba2\u540e\u7684 max \u58f0\u660e\u53ef\u80fd\u662f\u672c\u4e66\u4e2d\u6700\u590d\u6742\u7684\u65b9\u6cd5\u58f0\u660e\u3002\u589e\u52a0\u7684\u590d\u6742\u6027\u771f\u7684\u80fd\u7ed9\u4f60\u5e26\u6765\u4ec0\u4e48\u597d\u5904\u5417\uff1f\u662f\u7684\uff0c\u5b83\u518d\u6b21\u751f\u6548\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u7684\u5217\u8868\u6848\u4f8b\uff0c\u5b83\u5728\u539f\u6765\u7684\u58f0\u660e\u4e2d\u4e0d\u5141\u8bb8\u4f7f\u7528\uff0c\u4f46\u7ecf\u8ba2\u6b63\u7684\u58f0\u660e\u5141\u8bb8\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"List<ScheduledFuture<?>> scheduledFutures = ... ;\n")),(0,r.kt)("p",null,"The reason that you can\u2019t apply the original method declaration to this list is that ScheduledFuture does not implement ",(0,r.kt)("inlineCode",{parentName:"p"},"Comparable<ScheduledFuture>"),". Instead, it is a subinterface of Delayed, which extends ",(0,r.kt)("inlineCode",{parentName:"p"},"Comparable<Delayed>"),". In other words, a ScheduledFuture instance isn\u2019t merely comparable to other ScheduledFuture instances; it is comparable to any Delayed instance, and that\u2019s enough to cause the original declaration to reject it. More generally, the wildcard is required to support types that do not implement Comparable (or Comparator) directly but extend a type that does."),(0,r.kt)("p",null,"\u4e0d\u80fd\u5c06\u539f\u59cb\u65b9\u6cd5\u58f0\u660e\u5e94\u7528\u4e8e\u6b64\u5217\u8868\u7684\u539f\u56e0\u662f ScheduledFuture \u6ca1\u6709\u5b9e\u73b0 ",(0,r.kt)("inlineCode",{parentName:"p"},"Comparable<ScheduledFuture>"),"\u3002\u76f8\u53cd\uff0c\u5b83\u662f Delayed \u7684\u4e00\u4e2a\u5b50\u63a5\u53e3\uff0c\u6269\u5c55\u4e86 ",(0,r.kt)("inlineCode",{parentName:"p"},"Comparable<Delayed>"),"\u3002\u6362\u53e5\u8bdd\u8bf4\uff0cScheduledFuture \u7684\u5b9e\u4f8b\u4e0d\u4ec5\u4ec5\u53ef\u4ee5\u4e0e\u5176\u4ed6 ScheduledFuture \u5b9e\u4f8b\u8fdb\u884c\u6bd4\u8f83\uff1b\u5b83\u53ef\u4ee5\u4e0e\u4efb\u4f55 Delayed \u5b9e\u4f8b\u76f8\u6bd4\u8f83\uff0c\u8fd9\u8db3\u4ee5\u5bfc\u81f4\u521d\u59cb\u58f0\u660e\u65f6\u88ab\u62d2\u7edd\u3002\u66f4\u901a\u4fd7\u6765\u8bf4\uff0c\u901a\u914d\u7b26\u7528\u4e8e\u652f\u6301\u4e0d\u76f4\u63a5\u5b9e\u73b0 Comparable\uff08\u6216 Comparator\uff09\u4f46\u6269\u5c55\u4e86\u5b9e\u73b0 Comparable\uff08\u6216 Comparator\uff09\u7684\u7c7b\u578b\u7684\u7c7b\u578b\u3002"),(0,r.kt)("p",null,"There is one more wildcard-related topic that bears discussing. There is a duality between type parameters and wildcards, and many methods can be declared using one or the other. For example, here are two possible declarations for a static method to swap two indexed items in a list. The first uses an unbounded type parameter (Item 30) and the second an unbounded wildcard:"),(0,r.kt)("p",null,"\u8fd8\u6709\u4e00\u4e2a\u4e0e\u901a\u914d\u7b26\u76f8\u5173\u7684\u4e3b\u9898\u503c\u5f97\u8ba8\u8bba\u3002\u7c7b\u578b\u53c2\u6570\u548c\u901a\u914d\u7b26\u4e4b\u95f4\u5b58\u5728\u5bf9\u5076\u6027\uff0c\u53ef\u4ee5\u4f7f\u7528\u5176\u4e2d\u4e00\u79cd\u65b9\u6cd5\u58f0\u660e\u8bb8\u591a\u65b9\u6cd5\u3002\u4f8b\u5982\uff0c\u4e0b\u9762\u662f\u9759\u6001\u65b9\u6cd5\u7684\u4e24\u79cd\u53ef\u80fd\u58f0\u660e\uff0c\u7528\u4e8e\u4ea4\u6362\u5217\u8868\u4e2d\u7684\u4e24\u4e2a\u7d22\u5f15\u9879\u3002\u7b2c\u4e00\u4e2a\u4f7f\u7528\u65e0\u754c\u7c7b\u578b\u53c2\u6570\uff08",(0,r.kt)("a",{parentName:"p",href:"./Chapter-5-Item-30-Favor-generic-methods"},"Item-30"),"\uff09\uff0c\u7b2c\u4e8c\u4e2a\u4f7f\u7528\u65e0\u754c\u901a\u914d\u7b26\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"// Two possible declarations for the swap method\npublic static <E> void swap(List<E> list, int i, int j);\npublic static void swap(List<?> list, int i, int j);\n")),(0,r.kt)("p",null,"Which of these two declarations is preferable, and why? In a public API, the second is better because it\u2019s simpler. You pass in a list\u2014any list\u2014and the method swaps the indexed elements. There is no type parameter to worry about. As a rule, ",(0,r.kt)("strong",{parentName:"p"},"if a type parameter appears only once in a method declaration, replace it with a wildcard.")," If it\u2019s an unbounded type parameter, replace it with an unbounded wildcard; if it\u2019s a bounded type parameter, replace it with a bounded wildcard."),(0,r.kt)("p",null,"\u8fd9\u4e24\u4e2a\u58f0\u660e\u4e2d\u54ea\u4e2a\u66f4\u597d\uff0c\u4e3a\u4ec0\u4e48\uff1f\u5728\u516c\u5171 API \u4e2d\u7b2c\u4e8c\u4e2a\u66f4\u597d\uff0c\u56e0\u4e3a\u5b83\u66f4\u7b80\u5355\u3002\u4f20\u5165\u4e00\u4e2a\u5217\u8868\uff08\u4efb\u610f\u5217\u8868\uff09\uff0c\u8be5\u65b9\u6cd5\u4ea4\u6362\u7d22\u5f15\u5143\u7d20\u3002\u4e0d\u9700\u8981\u62c5\u5fc3\u7c7b\u578b\u53c2\u6570\u3002\u901a\u5e38\uff0c\u5982\u679c\u7c7b\u578b\u53c2\u6570\u5728\u65b9\u6cd5\u58f0\u660e\u4e2d\u53ea\u51fa\u73b0\u4e00\u6b21\uff0c\u5219\u7528\u901a\u914d\u7b26\u66ff\u6362\u5b83\u3002",(0,r.kt)("strong",{parentName:"p"},"\u5982\u679c\u5b83\u662f\u4e00\u4e2a\u65e0\u754c\u7c7b\u578b\u53c2\u6570\uff0c\u7528\u4e00\u4e2a\u65e0\u754c\u901a\u914d\u7b26\u66ff\u6362\u5b83\uff1b")," \u5982\u679c\u5b83\u662f\u6709\u754c\u7c7b\u578b\u53c2\u6570\uff0c\u5219\u7528\u6709\u754c\u901a\u914d\u7b26\u66ff\u6362\u5b83\u3002"),(0,r.kt)("p",null,"There\u2019s one problem with the second declaration for swap. The straightforward implementation won\u2019t compile:"),(0,r.kt)("p",null,"\u4ea4\u6362\u7684\u7b2c\u4e8c\u4e2a\u58f0\u660e\u6709\u4e00\u4e2a\u95ee\u9898\u3002\u8fd9\u4e2a\u7b80\u5355\u7684\u5b9e\u73b0\u65e0\u6cd5\u7f16\u8bd1\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"public static void swap(List<?> list, int i, int j) {\n  list.set(i, list.set(j, list.get(i)));\n}\n")),(0,r.kt)("p",null,"Trying to compile it produces this less-than-helpful error message:"),(0,r.kt)("p",null,"\u8bd5\u56fe\u7f16\u8bd1\u5b83\u4f1a\u4ea7\u751f\u4e00\u4e2a\u4e0d\u592a\u6709\u7528\u7684\u9519\u8bef\u6d88\u606f\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Swap.java:5: error: incompatible types: Object cannot be\nconverted to CAP#1\nlist.set(i, list.set(j, list.get(i)));\n^ where CAP#1\nis a fresh type-variable: CAP#1 extends Object from capture of ?\n")),(0,r.kt)("p",null,"It doesn\u2019t seem right that we can\u2019t put an element back into the list that we just took it out of. The problem is that the type of list is ",(0,r.kt)("inlineCode",{parentName:"p"},"List<?>"),", and you can\u2019t put any value except null into a ",(0,r.kt)("inlineCode",{parentName:"p"},"List<?>"),". Fortunately, there is a way to implement this method without resorting to an unsafe cast or a raw type. The idea is to write a private helper method to capture the wildcard type. The helper method must be a generic method in order to capture the type. Here\u2019s how it looks:"),(0,r.kt)("p",null,"\u6211\u4eec\u4e0d\u80fd\u628a\u4e00\u4e2a\u5143\u7d20\u653e\u56de\u521a\u521a\u53d6\u51fa\u7684\u5217\u8868\u4e2d\uff0c\u8fd9\u770b\u8d77\u6765\u662f\u4e0d\u6b63\u786e\u7684\u3002\u95ee\u9898\u662f list \u7684\u7c7b\u578b\u662f ",(0,r.kt)("inlineCode",{parentName:"p"},"List<?>"),"\uff0c\u4f60\u4e0d\u80fd\u5728 ",(0,r.kt)("inlineCode",{parentName:"p"},"List<?>")," \u4e2d\u653e\u5165\u9664 null \u4ee5\u5916\u7684\u4efb\u4f55\u503c\u3002\u5e78\u8fd0\u7684\u662f\uff0c\u6709\u4e00\u79cd\u65b9\u6cd5\u53ef\u4ee5\u5b9e\u73b0\uff0c\u800c\u65e0\u9700\u6c42\u52a9\u4e8e\u4e0d\u5b89\u5168\u7684\u5f3a\u5236\u8f6c\u6362\u6216\u539f\u59cb\u7c7b\u578b\u3002\u5176\u601d\u60f3\u662f\u7f16\u5199\u4e00\u4e2a\u79c1\u6709\u52a9\u624b\u65b9\u6cd5\u6765\u6355\u83b7\u901a\u914d\u7b26\u7c7b\u578b\u3002\u4e3a\u4e86\u6355\u83b7\u7c7b\u578b\uff0chelper \u65b9\u6cd5\u5fc5\u987b\u662f\u6cdb\u578b\u65b9\u6cd5\u3002\u5b83\u770b\u8d77\u6765\u662f\u8fd9\u6837\u7684\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"public static void swap(List<?> list, int i, int j) {\n  swapHelper(list, i, j);\n}\n// Private helper method for wildcard capture\nprivate static <E> void swapHelper(List<E> list, int i, int j) {\n  list.set(i, list.set(j, list.get(i)));\n}\n")),(0,r.kt)("p",null,"The swapHelper method knows that list is a ",(0,r.kt)("inlineCode",{parentName:"p"},"List<E>"),". Therefore, it knows that any value it gets out of this list is of type E and that it\u2019s safe to put any value of type E into the list. This slightly convoluted implementation of swap compiles cleanly. It allows us to export the nice wildcard-based declaration, while taking advantage of the more complex generic method internally. Clients of the swap method don\u2019t have to confront the more complex swapHelper declaration, but they do benefit from it. It is worth noting that the helper method has precisely the signature that we dismissed as too complex for the public method."),(0,r.kt)("p",null,"swapHelper \u65b9\u6cd5\u77e5\u9053 list \u662f\u4e00\u4e2a ",(0,r.kt)("inlineCode",{parentName:"p"},"List<E>"),"\u3002\u56e0\u6b64\uff0c\u5b83\u77e5\u9053\u5b83\u4ece\u8fd9\u4e2a\u5217\u8868\u4e2d\u5f97\u5230\u7684\u4efb\u4f55\u503c\u90fd\u662f E \u7c7b\u578b\u7684\uff0c\u5e76\u4e14\u5c06 E \u7c7b\u578b\u7684\u4efb\u4f55\u503c\u653e\u5165\u8fd9\u4e2a\u5217\u8868\u4e2d\u90fd\u662f\u5b89\u5168\u7684\u3002\u8fd9\u4e2a\u7a0d\u5fae\u590d\u6742\u7684\u5b9e\u73b0\u80fd\u591f\u6b63\u786e\u7f16\u8bd1\u3002\u5b83\u5141\u8bb8\u6211\u4eec\u5bfc\u51fa\u57fa\u4e8e \u901a\u914d\u7b26\u7684\u58f0\u660e\uff0c\u540c\u65f6\u5728\u5185\u90e8\u5229\u7528\u66f4\u590d\u6742\u7684\u6cdb\u578b\u65b9\u6cd5\u3002swap \u65b9\u6cd5\u7684\u5ba2\u6237\u7aef\u4e0d\u5fc5\u9762\u5bf9\u66f4\u590d\u6742\u7684 swapHelper \u58f0\u660e\uff0c\u4f46\u5b83\u4eec\u786e\u5b9e\u4ece\u4e2d\u53d7\u76ca\u3002\u503c\u5f97\u6ce8\u610f\u7684\u662f\uff0chelper \u65b9\u6cd5\u5177\u6709\u6211\u4eec\u8ba4\u4e3a\u5bf9\u4e8e\u516c\u5171\u65b9\u6cd5\u8fc7\u4e8e\u590d\u6742\u800c\u5ffd\u7565\u7684\u7b7e\u540d\u3002"),(0,r.kt)("p",null,"In summary, using wildcard types in your APIs, while tricky, makes the APIs far more flexible. If you write a library that will be widely used, the proper use of wildcard types should be considered mandatory. Remember the basic rule: producer-extends, consumer-super (PECS). Also remember that all comparables and comparators are consumers."),(0,r.kt)("p",null,"\u603b\u4e4b\uff0c\u5728 API \u4e2d\u4f7f\u7528\u901a\u914d\u7b26\u7c7b\u578b\u867d\u7136\u5f88\u68d8\u624b\uff0c\u4f46\u53ef\u4ee5\u4f7f\u5176\u66f4\u52a0\u7075\u6d3b\u3002\u5982\u679c\u4f60\u7f16\u5199\u7684\u5e93\u5c06\u88ab\u5e7f\u6cdb\u4f7f\u7528\uff0c\u5219\u5fc5\u987b\u8003\u8651\u901a\u914d\u7b26\u7c7b\u578b\u7684\u6b63\u786e\u4f7f\u7528\u3002\u8bb0\u4f4f\u57fa\u672c\u89c4\u5219\uff1a\u751f\u4ea7\u8005\u4f7f\u7528 extends\uff0c\u6d88\u8d39\u8005\u4f7f\u7528 super\uff08PECS\uff09\u3002\u8fd8\u8981\u8bb0\u4f4f\uff0c\u6240\u6709\u7684 comparable \u548c comparator \u90fd\u662f\u6d88\u8d39\u8005\u3002"),(0,r.kt)("hr",null),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"./Chapter-5-Introduction"},"Back to contents of the chapter\uff08\u8fd4\u56de\u7ae0\u8282\u76ee\u5f55\uff09"))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Previous Item\uff08\u4e0a\u4e00\u6761\u76ee\uff09\uff1a",(0,r.kt)("a",{parentName:"strong",href:"./Chapter-5-Item-30-Favor-generic-methods"},"Item 30: Favor generic methods\uff08\u4f18\u5148\u4f7f\u7528\u6cdb\u578b\u65b9\u6cd5\uff09"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Next Item\uff08\u4e0b\u4e00\u6761\u76ee\uff09\uff1a",(0,r.kt)("a",{parentName:"strong",href:"./Chapter-5-Item-32-Combine-generics-and-varargs-judiciously"},"Item 32: Combine generics and varargs judiciously\uff08\u660e\u667a\u5730\u5408\u7528\u6cdb\u578b\u548c\u53ef\u53d8\u53c2\u6570\uff09")))))}c.isMDXComponent=!0}}]);