"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[3786],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>u});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),d=p(n),u=o,h=d["".concat(l,".").concat(u)]||d[u]||m[u]||i;return n?a.createElement(h,s(s({ref:t},c),{},{components:n})):a.createElement(h,s({ref:t},c))}));function u(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,s=new Array(i);s[0]=d;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:o,s[1]=r;for(var p=2;p<i;p++)s[p]=n[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},2832:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>i,metadata:()=>r,toc:()=>p});var a=n(7462),o=(n(7294),n(3905));const i={},s=void 0,r={unversionedId:"Books/EffectiveJava3/Chapter-6/Chapter-6-Item-39-Prefer-annotations-to-naming-patterns",id:"Books/EffectiveJava3/Chapter-6/Chapter-6-Item-39-Prefer-annotations-to-naming-patterns",title:"Chapter-6-Item-39-Prefer-annotations-to-naming-patterns",description:"Chapter 6. Enums and Annotations\uff08\u679a\u4e3e\u548c\u6ce8\u89e3\uff09",source:"@site/docs/Books/EffectiveJava3/Chapter-6/Chapter-6-Item-39-Prefer-annotations-to-naming-patterns.md",sourceDirName:"Books/EffectiveJava3/Chapter-6",slug:"/Books/EffectiveJava3/Chapter-6/Chapter-6-Item-39-Prefer-annotations-to-naming-patterns",permalink:"/docs/Books/EffectiveJava3/Chapter-6/Chapter-6-Item-39-Prefer-annotations-to-naming-patterns",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Books/EffectiveJava3/Chapter-6/Chapter-6-Item-39-Prefer-annotations-to-naming-patterns.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Chapter-6-Item-38-Emulate-extensible-enums-with-interfaces",permalink:"/docs/Books/EffectiveJava3/Chapter-6/Chapter-6-Item-38-Emulate-extensible-enums-with-interfaces"},next:{title:"Chapter-6-Item-40-Consistently-use-the-Override-annotation",permalink:"/docs/Books/EffectiveJava3/Chapter-6/Chapter-6-Item-40-Consistently-use-the-Override-annotation"}},l={},p=[{value:"Chapter 6. Enums and Annotations\uff08\u679a\u4e3e\u548c\u6ce8\u89e3\uff09",id:"chapter-6-enums-and-annotations\u679a\u4e3e\u548c\u6ce8\u89e3",level:2},{value:"Item 39: Prefer annotations to naming patterns\uff08\u6ce8\u89e3\u4f18\u4e8e\u547d\u540d\u6a21\u5f0f\uff09",id:"item-39-prefer-annotations-to-naming-patterns\u6ce8\u89e3\u4f18\u4e8e\u547d\u540d\u6a21\u5f0f",level:3}],c={toc:p};function m(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"chapter-6-enums-and-annotations\u679a\u4e3e\u548c\u6ce8\u89e3"},"Chapter 6. Enums and Annotations\uff08\u679a\u4e3e\u548c\u6ce8\u89e3\uff09"),(0,o.kt)("h3",{id:"item-39-prefer-annotations-to-naming-patterns\u6ce8\u89e3\u4f18\u4e8e\u547d\u540d\u6a21\u5f0f"},"Item 39: Prefer annotations to naming patterns\uff08\u6ce8\u89e3\u4f18\u4e8e\u547d\u540d\u6a21\u5f0f\uff09"),(0,o.kt)("p",null,"Historically, it was common to use naming patterns to indicate that some program elements demanded special treatment by a tool or framework. For example, prior to release 4, the JUnit testing framework required its users to designate test methods by beginning their names with the characters test ","[Beck04]",". This technique works, but it has several big disadvantages. First, typographical errors result in silent failures. For example, suppose you accidentally named a test method tsetSafetyOverride instead of testSafetyOverride. JUnit 3 wouldn\u2019t complain, but it wouldn\u2019t execute the test either, leading to a false sense of security."),(0,o.kt)("p",null,"\u4ece\u5386\u53f2\u4e0a\u770b\uff0c\u4f7f\u7528\u547d\u540d\u6a21\u5f0f\u6765\u6807\u660e\u67d0\u4e9b\u7a0b\u5e8f\u5143\u7d20\u9700\u8981\u5de5\u5177\u6216\u6846\u67b6\u7279\u6b8a\u5904\u7406\u7684\u65b9\u5f0f\u662f\u5f88\u5e38\u89c1\u7684\u3002\u4f8b\u5982\uff0c\u5728\u7248\u672c 4 \u4e4b\u524d\uff0cJUnit \u6d4b\u8bd5\u6846\u67b6\u8981\u6c42\u5176\u7528\u6237\u901a\u8fc7\u4ee5\u5b57\u7b26 test ","[Beck04]"," \u5f00\u5934\u7684\u540d\u79f0\u6765\u6307\u5b9a\u6d4b\u8bd5\u65b9\u6cd5\u3002\u8fd9\u79cd\u6280\u672f\u662f\u6709\u6548\u7684\uff0c\u4f46\u662f\u5b83\u6709\u51e0\u4e2a\u5f88\u5927\u7684\u7f3a\u70b9\u3002\u9996\u5148\uff0c\u6392\u7248\u9519\u8bef\u4f1a\u5bfc\u81f4\u6ca1\u6709\u63d0\u793a\u7684\u5931\u8d25\u3002\u4f8b\u5982\uff0c\u5047\u8bbe\u4f60\u610f\u5916\u5730\u5c06\u4e00\u4e2a\u6d4b\u8bd5\u65b9\u6cd5\u547d\u540d\u4e3a tsetSafetyOverride\uff0c\u800c\u4e0d\u662f testSafetyOverride\u3002JUnit 3 \u4e0d\u4f1a\u62a5\u9519\uff0c\u4f46\u5b83\u4e5f\u4e0d\u4f1a\u6267\u884c\u6d4b\u8bd5\uff0c\u8fd9\u5bfc\u81f4\u4e00\u79cd\u6b63\u786e\u6267\u884c\u4e86\u6d4b\u8bd5\u7684\u5047\u8c61\u3002"),(0,o.kt)("p",null,"A second disadvantage of naming patterns is that there is no way to ensure that they are used only on appropriate program elements. For example, suppose you called a class TestSafetyMechanisms in hopes that JUnit 3 would automatically test all of its methods, regardless of their names. Again, JUnit 3 wouldn\u2019t complain, but it wouldn\u2019t execute the tests either."),(0,o.kt)("p",null,"\u547d\u540d\u6a21\u5f0f\u7684\u7b2c\u4e8c\u4e2a\u7f3a\u70b9\u662f\uff0c\u65e0\u6cd5\u786e\u4fdd\u53ea\u5728\u76f8\u5e94\u7684\u7a0b\u5e8f\u5143\u7d20\u4e0a\u4f7f\u7528\u5b83\u4eec\u3002\u4f8b\u5982\uff0c\u5047\u8bbe\u4f60\u8c03\u7528\u4e86\u4e00\u4e2a\u7c7b TestSafetyMechanisms\uff0c\u5e0c\u671b JUnit 3 \u80fd\u591f\u81ea\u52a8\u6d4b\u8bd5\u5b83\u7684\u6240\u6709\u65b9\u6cd5\uff0c\u800c\u4e0d\u7ba1\u5b83\u4eec\u7684\u540d\u79f0\u662f\u4ec0\u4e48\u3002\u540c\u6837\uff0cJUnit 3 \u4e0d\u4f1a\u62a5\u9519\uff0c\u4f46\u5b83\u4e5f\u4e0d\u4f1a\u6267\u884c\u6d4b\u8bd5\u3002"),(0,o.kt)("p",null,"A third disadvantage of naming patterns is that they provide no good way to associate parameter values with program elements. For example, suppose you want to support a category of test that succeeds only if it throws a particular exception. The exception type is essentially a parameter of the test. You could encode the exception type name into the test method name using some elaborate naming pattern, but this would be ugly and fragile (Item 62). The compiler would have no way of knowing to check that the string that was supposed to name an exception actually did. If the named class didn\u2019t exist or wasn\u2019t an exception, you wouldn\u2019t find out until you tried to run the test."),(0,o.kt)("p",null,"\u547d\u540d\u6a21\u5f0f\u7684\u7b2c\u4e09\u4e2a\u7f3a\u70b9\u662f\uff0c\u5b83\u4eec\u6ca1\u6709\u63d0\u4f9b\u5c06\u53c2\u6570\u503c\u4e0e\u7a0b\u5e8f\u5143\u7d20\u5173\u8054\u7684\u597d\u65b9\u6cd5\u3002\u4f8b\u5982\uff0c\u5047\u8bbe\u4f60\u5e0c\u671b\u652f\u6301\u53ea\u6709\u5728\u629b\u51fa\u7279\u5b9a\u5f02\u5e38\u65f6\u624d\u6210\u529f\u7684\u6d4b\u8bd5\u7c7b\u522b\u3002\u5f02\u5e38\u7c7b\u578b\u672c\u8d28\u4e0a\u662f\u6d4b\u8bd5\u7684\u4e00\u4e2a\u53c2\u6570\u3002\u4f60\u53ef\u4ee5\u4f7f\u7528\u4e00\u4e9b\u7cbe\u5fc3\u8bbe\u8ba1\u7684\u547d\u540d\u6a21\u5f0f\uff0c\u5c06\u5f02\u5e38\u7c7b\u578b\u540d\u79f0\u7f16\u7801\u5230\u6d4b\u8bd5\u65b9\u6cd5\u540d\u79f0\u4e2d\uff0c\u4f46\u8fd9\u6837\u7684\u4ee3\u7801\u5c06\u4e0d\u597d\u770b\u4e14\u8106\u5f31\uff08",(0,o.kt)("a",{parentName:"p",href:"./Chapter-9-Item-62-Avoid-strings-where-other-types-are-more-appropriate"},"Item-62"),"\uff09\u3002\u7f16\u8bd1\u5668\u5c06\u65e0\u6cd5\u68c0\u67e5\u8fd9\u4e9b\u7528\u4e8e\u547d\u540d\u5f02\u5e38\u7684\u5b57\u7b26\u4e32\u662f\u5426\u786e\u5b9e\u6267\u884c\u4e86\u3002\u5982\u679c\u6307\u5b9a\u7684\u7c7b\u4e0d\u5b58\u5728\u6216\u4e0d\u662f\u5f02\u5e38\uff0c\u5219\u5728\u8fd0\u884c\u6d4b\u8bd5\u4e4b\u524d\u4e0d\u4f1a\u88ab\u53d1\u73b0\u3002"),(0,o.kt)("p",null,"Annotations ","[JLS, 9.7]"," solve all of these problems nicely, and JUnit adopted them starting with release 4. In this item, we\u2019ll write our own toy testing framework to show how annotations work. Suppose you want to define an annotation type to designate simple tests that are run automatically and fail if they throw an exception. Here\u2019s how such an annotation type, named Test, might look:"),(0,o.kt)("p",null,"\u6ce8\u89e3 ","[JLS, 9.7]"," \u5f88\u597d\u5730\u89e3\u51b3\u4e86\u6240\u6709\u8fd9\u4e9b\u95ee\u9898\uff0cJUnit \u4ece\u7248\u672c 4 \u5f00\u59cb\u5c31\u91c7\u7528\u4e86\u5b83\u4eec\u3002\u5728\u672c\u6761\u76ee\u4e2d\uff0c\u6211\u4eec\u5c06\u7f16\u5199\u81ea\u5df1\u7684\u793a\u4f8b\u6d4b\u8bd5\u6846\u67b6\u6765\u5c55\u793a\u6ce8\u89e3\u662f\u5982\u4f55\u5de5\u4f5c\u7684\u3002\u5047\u8bbe\u4f60\u5e0c\u671b\u5b9a\u4e49\u6ce8\u89e3\u7c7b\u578b\uff0c\u4ee5\u6307\u5b9a\u81ea\u52a8\u8fd0\u884c\u7684\u7b80\u5355\u6d4b\u8bd5\uff0c\u5e76\u5728\u629b\u51fa\u5f02\u5e38\u65f6\u5931\u8d25\u3002\u4e0b\u9762\u662f\u8fd9\u79cd\u540d\u4e3a Test \u7684\u6ce8\u89e3\u7c7b\u578b\u7684\u6982\u8c8c\uff1a"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"// Marker annotation type declaration\nimport java.lang.annotation.*;\n\n/**\n* Indicates that the annotated method is a test method.\n* Use only on parameterless static methods.\n*/\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface Test {\n\n}\n")),(0,o.kt)("p",null,"The declaration for the Test annotation type is itself annotated with Retention and Target annotations. Such annotations on annotation type declarations are known as meta-annotations. The @Retention(RetentionPolicy.RUNTIME) meta-annotation indicates that Test annotations should be retained at runtime. Without it, Test annotations would be invisible to the test tool. The @Target.get(ElementType.METHOD) meta-annotation indicates that the Test annotation is legal only on method declarations: it cannot be applied to class declarations, field declarations, or other program elements."),(0,o.kt)("p",null,"Test \u6ce8\u89e3\u7c7b\u578b\u7684\u58f0\u660e\u672c\u8eab\u5e26\u6709 Retention \u6ce8\u89e3\u548c Target \u6ce8\u89e3\u3002\u8fd9\u79cd\u6ce8\u89e3\u7c7b\u578b\u58f0\u660e\u4e0a\u7684\u6ce8\u89e3\u79f0\u4e3a\u5143\u6ce8\u89e3\u3002",(0,o.kt)("inlineCode",{parentName:"p"},"@Retention(RetentionPolicy.RUNTIME)")," \u5143\u6ce8\u89e3\u8868\u660e\u6d4b\u8bd5\u6ce8\u89e3\u5e94\u8be5\u5728\u8fd0\u884c\u65f6\u4fdd\u7559\u3002\u6ca1\u6709\u5b83\uff0c\u6d4b\u8bd5\u5de5\u5177\u5c06\u65e0\u6cd5\u8bc6\u522b\u6d4b\u8bd5\u6ce8\u89e3\u3002",(0,o.kt)("inlineCode",{parentName:"p"},"@Target.get(ElementType.METHOD)")," \u5143\u6ce8\u89e3\u8868\u660e\u6d4b\u8bd5\u6ce8\u89e3\u4ec5\u5bf9\u65b9\u6cd5\u58f0\u660e\u5408\u6cd5\uff1a\u5b83\u4e0d\u80fd\u5e94\u7528\u4e8e\u7c7b\u58f0\u660e\u3001\u5b57\u6bb5\u58f0\u660e\u6216\u5176\u4ed6\u7a0b\u5e8f\u5143\u7d20\u3002"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"\u8bd1\u6ce8 1\uff1a\u6ce8\u89e3\u7684\u4fdd\u7559\u7b56\u7565")),(0,o.kt)("p",null,"\u4fdd\u7559\u7b56\u7565\u51b3\u5b9a\u4e86\u5728\u4ec0\u4e48\u4f4d\u7f6e\u4e22\u5f03\u6ce8\u89e3\u3002Java \u5b9a\u4e49\u4e86 3 \u79cd\u7b56\u7565\uff0c\u5b83\u4eec\u88ab\u5c01\u88c5\u5230 ",(0,o.kt)("inlineCode",{parentName:"p"},"java.lang.annotation.RetentionPolicy")," \u679a\u4e3e\u4e2d\u3002\u8fd9 3 \u79cd\u7b56\u7565\u5206\u522b\u662f SOURCE\u3001CLASS \u548c RUNTIME\u3002"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"\u4f7f\u7528 SOURCE \u4fdd\u7559\u7b56\u7565\u7684\u6ce8\u89e3\uff0c\u53ea\u5728\u6e90\u6587\u4ef6\u4e2d\u4fdd\u7559\uff0c\u5728\u7f16\u8bd1\u671f\u95f4\u4f1a\u88ab\u629b\u5f03\u3002"),(0,o.kt)("li",{parentName:"ul"},"\u4f7f\u7528 CLASS \u4fdd\u7559\u7b56\u7565\u7684\u6ce8\u89e3\uff0c\u5728\u7f16\u8bd1\u65f6\u88ab\u5b58\u50a8\u5230 ",(0,o.kt)("inlineCode",{parentName:"li"},".class")," \u6587\u4ef6\u4e2d\u3002\u4f46\u662f\uff0c\u5728\u8fd0\u884c\u65f6\u4e0d\u80fd\u901a\u8fc7 JVM \u5f97\u5230\u8fd9\u4e9b\u6ce8\u89e3\u3002"),(0,o.kt)("li",{parentName:"ul"},"\u4f7f\u7528 RUNTIME \u4fdd\u7559\u7b56\u7565\u7684\u6ce8\u89e3\uff0c\u5728\u7f16\u8bd1\u65f6\u88ab\u5b58\u50a8\u5230 ",(0,o.kt)("inlineCode",{parentName:"li"},".class")," \u6587\u4ef6\u4e2d\uff0c\u5e76\u4e14\u5728\u8fd0\u884c\u65f6\u53ef\u4ee5\u901a\u8fc7 JVM \u83b7\u53d6\u8fd9\u4e9b\u6ce8\u89e3\u3002\u56e0\u6b64\uff0cRUNTIME \u4fdd\u7559\u7b56\u7565\u63d0\u4f9b\u4e86\u6700\u6c38\u4e45\u7684\u6ce8\u89e3\u3002")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"\u8bd1\u6ce8 2\uff1aElementType \u5404\u5e38\u91cf\u5b9a\u4e49\u7684\u8303\u56f4")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"ElementType.TYPE",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Class, interface (including annotation type), or enum declaration\uff08\u7c7b\u3001\u63a5\u53e3\u3001\u6ce8\u89e3\u3001\u679a\u4e3e\uff09"))),(0,o.kt)("li",{parentName:"ul"},"ElementType.FIELD",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Field declaration (includes enum constants)\uff08\u5b57\u6bb5\u3001\u679a\u4e3e\u5e38\u91cf\uff09"))),(0,o.kt)("li",{parentName:"ul"},"ElementType.METHOD",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Method declaration\uff08\u65b9\u6cd5\uff09"))),(0,o.kt)("li",{parentName:"ul"},"ElementType.PARAMETER",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Formal parameter declaration\uff08\u65b9\u6cd5\u53c2\u6570\uff09"))),(0,o.kt)("li",{parentName:"ul"},"ElementType.CONSTRUCTOR",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Constructor declaration\uff08\u6784\u9020\uff09"))),(0,o.kt)("li",{parentName:"ul"},"ElementType.LOCAL_VARIABLE",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Local variable declaration\uff08\u5c40\u90e8\u53d8\u91cf\uff09"))),(0,o.kt)("li",{parentName:"ul"},"ElementType.ANNOTATION_TYPE",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Annotation type declaration\uff08\u6ce8\u89e3\uff09"))),(0,o.kt)("li",{parentName:"ul"},"ElementType.PACKAGE",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Package declaration\uff08\u5305\uff09"))),(0,o.kt)("li",{parentName:"ul"},"ElementType.TYPE_PARAMETER",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Type parameter declaration\uff08\u6cdb\u578b\u53c2\u6570\uff09"),(0,o.kt)("li",{parentName:"ul"},"Since: 1.8"))),(0,o.kt)("li",{parentName:"ul"},"ElementType.TYPE_USE",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Use of a type\uff08\u4efb\u610f\u7c7b\u578b\uff0c\u83b7\u53d6 class \u5bf9\u8c61\u548c import \u4e24\u79cd\u60c5\u51b5\u9664\u5916\uff09"),(0,o.kt)("li",{parentName:"ul"},"Since: 1.8"))),(0,o.kt)("li",{parentName:"ul"},"ElementType.MODULE",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Module declaration\uff08",(0,o.kt)("a",{parentName:"li",href:"https://docs.oracle.com/javase/9/whatsnew/toc.htm#JSNEW-GUID-C23AFD78-C777-460B-8ACE-58BE5EA681F6"},"\u6a21\u5757"),"\uff09"),(0,o.kt)("li",{parentName:"ul"},"Since: 9")))),(0,o.kt)("p",null,"The comment before the Test annotation declaration says, \u201cUse only on parameterless static methods.\u201d It would be nice if the compiler could enforce this, but it can\u2019t, unless you write an annotation processor to do so. For more on this topic, see the documentation for javax.annotation.processing. In the absence of such an annotation processor, if you put a Test annotation on the declaration of an instance method or on a method with one or more parameters, the test program will still compile, leaving it to the testing tool to deal with the problem at runtime."),(0,o.kt)("p",null,"Test \u6ce8\u89e3\u58f0\u660e\u4e4b\u524d\u7684\u4ee3\u7801\u6ce8\u91ca\u662f\u8fd9\u4e48\u63cf\u8ff0\u7684:\u300cUse only on parameterless static methods.\uff08\u53ea\u5bf9\u65e0\u53c2\u6570\u7684\u9759\u6001\u65b9\u6cd5\u4f7f\u7528\uff09\u300d\u5982\u679c\u7f16\u8bd1\u5668\u80fd\u591f\u5f3a\u5236\u6267\u884c\u8fd9\u4e00\u70b9\uff0c\u90a3\u5c31\u592a\u597d\u4e86\uff0c\u4f46\u662f\u5b83\u4e0d\u80fd\uff0c\u9664\u975e\u4f60\u7f16\u5199\u4ee3\u7801\u6ce8\u91ca\u5904\u7406\u5668\u6765\u6267\u884c\u3002\u6709\u5173\u6b64\u4e3b\u9898\u7684\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 ",(0,o.kt)("inlineCode",{parentName:"p"},"javax.annotation.processing")," \u7684\u6587\u6863\u3002\u5728\u6ca1\u6709\u8fd9\u6837\u7684\u4ee3\u7801\u6ce8\u91ca\u5904\u7406\u7a0b\u5e8f\u7684\u60c5\u51b5\u4e0b\uff0c\u5982\u679c\u4f60\u5c06 Test \u6ce8\u89e3\u653e\u5728\u5b9e\u4f8b\u65b9\u6cd5\u7684\u58f0\u660e\u4e0a\uff0c\u6216\u8005\u653e\u5728\u5e26\u6709\u4e00\u4e2a\u6216\u591a\u4e2a\u53c2\u6570\u7684\u65b9\u6cd5\u4e0a\uff0c\u6d4b\u8bd5\u7a0b\u5e8f\u4ecd\u7136\u4f1a\u7f16\u8bd1\uff0c\u8ba9\u6d4b\u8bd5\u5de5\u5177\u5728\u8fd0\u884c\u65f6\u5904\u7406\u3002"),(0,o.kt)("p",null,"Here is how the Test annotation looks in practice. It is called a marker annotation because it has no parameters but simply \u201cmarks\u201d the annotated element. If the programmer were to misspell Test or to apply the Test annotation to a program element other than a method declaration, the program wouldn\u2019t compile:"),(0,o.kt)("p",null,"\u4e0b\u9762\u662f Test \u6ce8\u89e3\u5b9e\u9645\u4f7f\u7528\u65f6\u7684\u6837\u5b50\u3002\u5b83\u88ab\u79f0\u4e3a\u6807\u8bb0\u6ce8\u89e3\uff0c\u56e0\u4e3a\u5b83\u6ca1\u6709\u53c2\u6570\uff0c\u53ea\u662f\u5bf9\u5e26\u6ce8\u89e3\u7684\u5143\u7d20\u8fdb\u884c\u300c\u6807\u8bb0\u300d\u3002\u5982\u679c\u7a0b\u5e8f\u5458\u62fc\u9519 Test \u6216\u5c06 Test \u6ce8\u89e3\u5e94\u7528\u4e8e\u9664\u65b9\u6cd5\u58f0\u660e\u4e4b\u5916\u7684\u7a0b\u5e8f\u5143\u7d20\uff0c\u7a0b\u5e8f\u5c06\u65e0\u6cd5\u7f16\u8bd1\uff1a"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'// Program containing marker annotations\npublic class Sample {\n    @Test\n    public static void m1() { } // Test should pass\n\n    public static void m2() { }\n\n    @Test\n    public static void m3() { // Test should fail\n        throw new RuntimeException("Boom");\n    }\n\n    public static void m4() { }\n\n    @Test\n    public void m5() { } // INVALID USE: nonstatic method\n\n    public static void m6() { }\n\n    @Test\n    public static void m7() { // Test should fail\n        throw new RuntimeException("Crash");\n    }\n\n    public static void m8() { }\n}\n')),(0,o.kt)("p",null,"The Sample class has seven static methods, four of which are annotated as tests. Two of these, m3 and m7, throw exceptions, and two, m1 and m5, do not. But one of the annotated methods that does not throw an exception, m5, is an instance method, so it is not a valid use of the annotation. In sum, Sample contains four tests: one will pass, two will fail, and one is invalid. The four methods that are not annotated with the Test annotation will be ignored by the testing tool."),(0,o.kt)("p",null,"Sample \u7c7b\u6709 7 \u4e2a\u9759\u6001\u65b9\u6cd5\uff0c\u5176\u4e2d 4 \u4e2a\u88ab\u6ce8\u89e3\u4e3a Test\u3002\u5176\u4e2d\u4e24\u4e2a\u65b9\u6cd5 m3 \u548c m7 \u629b\u51fa\u5f02\u5e38\uff0c\u53e6\u5916\u4e24\u4e2a m1 \u548c m5 \u6ca1\u6709\u629b\u51fa\u5f02\u5e38\u3002\u4f46\u662f\uff0c\u4e0d\u629b\u51fa\u5f02\u5e38\u7684\u5e26\u6ce8\u89e3\u7684\u65b9\u6cd5 m5 \u662f\u4e00\u4e2a\u5b9e\u4f8b\u65b9\u6cd5\uff0c\u56e0\u6b64\u5b83\u4e0d\u662f\u6ce8\u89e3\u7684\u6709\u6548\u4f7f\u7528\u3002\u603b\u4e4b\uff0cSample \u5305\u542b\u56db\u4e2a\u6d4b\u8bd5\uff1a\u4e00\u4e2a\u901a\u8fc7\uff0c\u4e24\u4e2a\u5931\u8d25\uff0c\u4e00\u4e2a\u65e0\u6548\u3002\u6ca1\u6709\u4f7f\u7528 Test \u6ce8\u91ca\u7684\u56db\u4e2a\u65b9\u6cd5\u5c06\u88ab\u6d4b\u8bd5\u5de5\u5177\u5ffd\u7565\u3002"),(0,o.kt)("p",null,"The Test annotations have no direct effect on the semantics of the Sample class. They serve only to provide information for use by interested programs. More generally, annotations don\u2019t change the semantics of the annotated code but enable it for special treatment by tools such as this simple test runner:"),(0,o.kt)("p",null,"Test \u6ce8\u89e3\u5bf9 Sample \u7c7b\u7684\u8bed\u4e49\u6ca1\u6709\u76f4\u63a5\u5f71\u54cd\u3002\u5b83\u4eec\u4ec5\u7528\u4e8e\u5411\u76f8\u5173\u7a0b\u5e8f\u63d0\u4f9b\u4fe1\u606f\u3002\u66f4\u666e\u904d\u7684\u662f\uff0c\u6ce8\u89e3\u4e0d\u4f1a\u6539\u53d8\u88ab\u6ce8\u89e3\u4ee3\u7801\u7684\u8bed\u4e49\uff0c\u800c\u662f\u901a\u8fc7\u5de5\u5177\uff08\u5c31\u50cf\u5982\u4e0b\u8fd9\u4e2a\u7b80\u5355\u7684 RunTests \u7c7b\uff09\u5bf9\u5176\u8fdb\u884c\u7279\u6b8a\u5904\u7406\uff1a"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'// Program to process marker annotations\nimport java.lang.reflect.*;\n\npublic class RunTests {\n    public static void main(String[] args) throws Exception {\n        int tests = 0;\n        int passed = 0;\n        Class<?> testClass = Class.forName(args[0]);\n        for (Method m : testClass.getDeclaredMethods()) {\n            if (m.isAnnotationPresent(Test.class)) {\n                tests++;\n                try {\n                    m.invoke(null);\n                    passed++;\n                } catch (InvocationTargetException wrappedExc) {\n                    Throwable exc = wrappedExc.getCause();\n                    System.out.println(m + " failed: " + exc);\n                } catch (Exception exc) {\n                    System.out.println("Invalid @Test: " + m);\n                }\n        }\n    }\n    System.out.printf("Passed: %d, Failed: %d%n",passed, tests - passed);\n    }\n}\n')),(0,o.kt)("p",null,"The test runner tool takes a fully qualified class name on the command line and runs all of the class\u2019s Test-annotated methods reflectively, by calling Method.invoke. The isAnnotationPresent method tells the tool which methods to run. If a test method throws an exception, the reflection facility wraps it in an InvocationTargetException. The tool catches this exception and prints a failure report containing the original exception thrown by the test method, which is extracted from the InvocationTargetException with the getCause method."),(0,o.kt)("p",null,"test runner \u5de5\u5177\u4ee5\u547d\u4ee4\u884c\u65b9\u5f0f\u63a5\u53d7\u4e00\u4e2a\u5b8c\u5168\u9650\u5b9a\u7684\u7c7b\u540d\uff0c\u5e76\u901a\u8fc7\u8c03\u7528 ",(0,o.kt)("inlineCode",{parentName:"p"},"Method.invoke")," \u4ee5\u53cd\u5c04\u65b9\u5f0f\u8fd0\u884c\u7c7b\u7684\u6240\u6709\u5e26\u6d4b\u8bd5\u6ce8\u89e3\u7684\u65b9\u6cd5\u3002isAnnotationPresent \u65b9\u6cd5\u544a\u8bc9\u5de5\u5177\u8981\u8fd0\u884c\u54ea\u4e9b\u65b9\u6cd5\u3002\u5982\u679c\u6d4b\u8bd5\u65b9\u6cd5\u629b\u51fa\u5f02\u5e38\uff0c\u53cd\u5c04\u5de5\u5177\u5c06\u5176\u5c01\u88c5\u5728 InvocationTargetException \u4e2d\u3002\u8be5\u5de5\u5177\u6355\u83b7\u8fd9\u4e2a\u5f02\u5e38\u5e76\u6253\u5370\u4e00\u4e2a\u5931\u8d25\u62a5\u544a\uff0c\u5176\u4e2d\u5305\u542b\u6d4b\u8bd5\u65b9\u6cd5\u629b\u51fa\u7684\u539f\u59cb\u5f02\u5e38\uff0c\u8be5\u5f02\u5e38\u662f\u7528 getCause \u65b9\u6cd5\u4ece InvocationTargetException \u63d0\u53d6\u7684\u3002"),(0,o.kt)("p",null,"If an attempt to invoke a test method by reflection throws any exception other than InvocationTargetException, it indicates an invalid use of the Test annotation that was not caught at compile time. Such uses include annotation of an instance method, of a method with one or more parameters, or of an inaccessible method. The second catch block in the test runner catches these Test usage errors and prints an appropriate error message. Here is the output that is printed if RunTests is run on Sample:"),(0,o.kt)("p",null,"\u5982\u679c\u901a\u8fc7\u53cd\u5c04\u8c03\u7528\u6d4b\u8bd5\u65b9\u6cd5\u65f6\u629b\u51fa\u9664 InvocationTargetException \u4e4b\u5916\u7684\u4efb\u4f55\u5f02\u5e38\uff0c\u5219\u8868\u660e\u5728\u7f16\u8bd1\u65f6\u5b58\u5728\u672a\u6355\u83b7\u7684 Test \u6ce8\u89e3\u7684\u65e0\u6548\u7528\u6cd5\u3002\u8fd9\u4e9b\u7528\u9014\u5305\u62ec\u5b9e\u4f8b\u65b9\u6cd5\u7684\u6ce8\u89e3\u3001\u5e26\u6709\u4e00\u4e2a\u6216\u591a\u4e2a\u53c2\u6570\u7684\u65b9\u6cd5\u7684\u6ce8\u89e3\u6216\u4e0d\u53ef\u8bbf\u95ee\u65b9\u6cd5\u7684\u6ce8\u89e3\u3002\u6d4b\u8bd5\u8fd0\u884c\u7a0b\u5e8f\u4e2d\u7684\u7b2c\u4e8c\u4e2a catch \u5757\u6355\u83b7\u8fd9\u4e9b Test \u4f7f\u7528\u9519\u8bef\u5e76\u6253\u5370\u5bf9\u5e94\u7684\u9519\u8bef\u6d88\u606f\u3002\u5982\u679c\u5728 Sample \u4e0a\u8fd0\u884c RunTests\uff0c\u8f93\u51fa\u5982\u4e0b\uff1a"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"public static void Sample.m3() failed: RuntimeException: Boom\nInvalid @Test: public void Sample.m5()\npublic static void Sample.m7() failed: RuntimeException: Crash\nPassed: 1, Failed: 3\n")),(0,o.kt)("p",null,"Now let\u2019s add support for tests that succeed only if they throw a particular exception. We\u2019ll need a new annotation type for this:"),(0,o.kt)("p",null,"\u73b0\u5728\u8ba9\u6211\u4eec\u6dfb\u52a0\u4e00\u4e2a\u53ea\u5728\u629b\u51fa\u7279\u5b9a\u5f02\u5e38\u65f6\u624d\u6210\u529f\u7684\u6d4b\u8bd5\u652f\u6301\u3002\u6211\u4eec\u9700\u8981\u4e00\u4e2a\u65b0\u7684\u6ce8\u89e3\u7c7b\u578b\uff1a"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"// Annotation type with a parameter\nimport java.lang.annotation.*;\n\n/**\n* Indicates that the annotated method is a test method that\n* must throw the designated exception to succeed.\n*/\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface ExceptionTest {\n    Class<? extends Throwable> value();\n}\n")),(0,o.kt)("p",null,"The type of the parameter for this annotation is ",(0,o.kt)("inlineCode",{parentName:"p"},"Class<? extends Throwable>"),". This wildcard type is, admittedly, a mouthful. In English, it means \u201cthe Class object for some class that extends Throwable,\u201d and it allows the user of the annotation to specify any exception (or error) type. This usage is an example of a bounded type token (Item 33). Here\u2019s how the annotation looks in practice. Note that class literals are used as the values for the annotation parameter:"),(0,o.kt)("p",null,"\u8fd9\u4e2a\u6ce8\u89e3\u7684\u53c2\u6570\u7c7b\u578b\u662f ",(0,o.kt)("inlineCode",{parentName:"p"},"Class<? extends Throwable>"),"\uff0c\u8fd9\u4e2a\u901a\u914d\u7b26\u7c7b\u578b\u786e\u5b9e\u5f88\u590d\u6742\u3002\u5728\u82f1\u8bed\u4e2d\uff0c\u5b83\u7684\u610f\u601d\u662f\u300c\u67d0\u4e2a\u6269\u5c55\u81ea Throwable \u7684\u7c7b\u7684 Class \u5bf9\u8c61\u300d\uff0c\u5b83\u5141\u8bb8\u6ce8\u89e3\u7684\u7528\u6237\u6307\u5b9a\u4efb\u4f55\u5f02\u5e38\uff08\u6216\u9519\u8bef\uff09\u7c7b\u578b\u3002\u8fd9\u79cd\u7528\u6cd5\u662f\u6709\u754c\u7c7b\u578b\u4ee4\u724c\uff08",(0,o.kt)("a",{parentName:"p",href:"./Chapter-5-Item-33-Consider-typesafe-heterogeneous-containers"},"Item-33"),"\uff09\u7684\u4e00\u4e2a\u793a\u4f8b\u3002\u4e0b\u9762\u662f\u8fd9\u4e2a\u6ce8\u89e3\u5728\u5b9e\u9645\u5e94\u7528\u65f6\u7684\u6837\u5b50\u3002\u6ce8\u610f\uff0c\u7c7b\u7684\u5b57\u9762\u91cf\u88ab\u7528\u4f5c\u6ce8\u89e3\u53c2\u6570\u7684\u503c\uff1a"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"// Program containing annotations with a parameter\npublic class Sample2 {\n    @ExceptionTest(ArithmeticException.class)\n    public static void m1() { // Test should pass\n        int i = 0;\n        i = i / i;\n    }\n\n    @ExceptionTest(ArithmeticException.class)\n    public static void m2() { // Should fail (wrong exception)\n        int[] a = new int[0];\n        int i = a[1];\n    }\n\n    @ExceptionTest(ArithmeticException.class)\n    public static void m3() { } // Should fail (no exception)\n}\n")),(0,o.kt)("p",null,"Now let\u2019s modify the test runner tool to process the new annotation. Doing so consists of adding the following code to the main method:"),(0,o.kt)("p",null,"\u73b0\u5728\u8ba9\u6211\u4eec\u4fee\u6539 test runner \u5de5\u5177\u6765\u5904\u7406\u65b0\u7684\u6ce8\u89e3\u3002\u5411 main \u65b9\u6cd5\u6dfb\u52a0\u4ee5\u4e0b\u4ee3\u7801\uff1a"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'if (m.isAnnotationPresent(ExceptionTest.class)) {\n    tests++;\n    try {\n        m.invoke(null);\n        System.out.printf("Test %s failed: no exception%n", m);\n    } catch (InvocationTargetException wrappedEx) {\n        Throwable exc = wrappedEx.getCause();\n        Class<? extends Throwable> excType =m.getAnnotation(ExceptionTest.class).value();\n        if (excType.isInstance(exc)) {\n            passed++;\n        } else {\n            System.out.printf("Test %s failed: expected %s, got %s%n",m, excType.getName(), exc);\n        }\n    }\n    catch (Exception exc) {\n        System.out.println("Invalid @Test: " + m);\n    }\n}\n')),(0,o.kt)("p",null,"This code is similar to the code we used to process Test annotations, with one exception: this code extracts the value of the annotation parameter and uses it to check if the exception thrown by the test is of the right type. There are no explicit casts, and hence no danger of a ClassCastException. The fact that the test program compiled guarantees that its annotation parameters represent valid exception types, with one caveat: if the annotation parameters were valid at compile time but the class file representing a specified exception type is no longer present at runtime, the test runner will throw TypeNotPresentException."),(0,o.kt)("p",null,"\u8fd9\u6bb5\u4ee3\u7801\u4e0e\u6211\u4eec\u7528\u6765\u5904\u7406 Test \u6ce8\u89e3\u7684\u4ee3\u7801\u7c7b\u4f3c\uff0c\u53ea\u6709\u4e00\u4e2a\u4e0d\u540c\uff1a\u8fd9\u6bb5\u4ee3\u7801\u63d0\u53d6\u6ce8\u89e3\u53c2\u6570\u7684\u503c\uff0c\u5e76\u4f7f\u7528\u5b83\u6765\u68c0\u67e5\u6d4b\u8bd5\u629b\u51fa\u7684\u5f02\u5e38\u662f\u5426\u662f\u6b63\u786e\u7684\u7c7b\u578b\u3002\u8fd9\u91cc\u6ca1\u6709\u663e\u5f0f\u7684\u5f3a\u5236\u7c7b\u578b\u8f6c\u6362\uff0c\u56e0\u6b64\u6ca1\u6709 ClassCastException \u7684\u5371\u9669\u3002\u7f16\u8bd1\u7684\u6d4b\u8bd5\u7a0b\u5e8f\u4fdd\u8bc1\u5176\u6ce8\u89e3\u53c2\u6570\u8868\u793a\u6709\u6548\u7684\u5f02\u5e38\u7c7b\u578b\uff0c\u4f46\u6709\u4e00\u70b9\u9700\u8981\u6ce8\u610f\uff1a\u5982\u679c\u6ce8\u89e3\u53c2\u6570\u5728\u7f16\u8bd1\u65f6\u6709\u6548\uff0c\u4f46\u8868\u793a\u6307\u5b9a\u5f02\u5e38\u7c7b\u578b\u7684\u7c7b\u6587\u4ef6\u5728\u8fd0\u884c\u65f6\u4e0d\u518d\u5b58\u5728\uff0c\u90a3\u4e48\u6d4b\u8bd5\u8fd0\u884c\u7a0b\u5e8f\u5c06\u629b\u51fa TypeNotPresentException\u3002"),(0,o.kt)("p",null,"Taking our exception testing example one step further, it is possible to envision a test that passes if it throws any one of several specified exceptions. The annotation mechanism has a facility that makes it easy to support this usage. Suppose we change the parameter type of the ExceptionTest annotation to be an array of Class objects:"),(0,o.kt)("p",null,"\u8fdb\u4e00\u6b65\u4fee\u6539\u6211\u4eec\u7684\u5f02\u5e38\u6d4b\u8bd5\u793a\u4f8b\uff0c\u5982\u679c\u5b83\u629b\u51fa\u51e0\u4e2a\u6307\u5b9a\u5f02\u5e38\u4e2d\u7684\u4efb\u610f\u4e00\u4e2a\uff0c\u90a3\u4e48\u53ef\u4ee5\u8ba4\u4e3a\u6d4b\u8bd5\u901a\u8fc7\u4e86\u3002\u6ce8\u89e3\u673a\u5236\u5177\u6709\u4e00\u79cd\u5de5\u5177\uff0c\u53ef\u4ee5\u8f7b\u677e\u5730\u652f\u6301\u8fd9\u79cd\u7528\u6cd5\u3002\u5047\u8bbe\u6211\u4eec\u5c06 ExceptionTest \u6ce8\u89e3\u7684\u53c2\u6570\u7c7b\u578b\u66f4\u6539\u4e3a\u4e00\u4e2a Class \u5bf9\u8c61\u6570\u7ec4\uff1a"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"// Annotation type with an array parameter\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface ExceptionTest {\n    Class<? extends Exception>[] value();\n}\n")),(0,o.kt)("p",null,"The syntax for array parameters in annotations is flexible. It is optimized for single-element arrays. All of the previous ExceptionTest annotations are still valid with the new array-parameter version of ExceptionTest and result in single-element arrays. To specify a multiple-element array, surround the elements with curly braces and separate them with commas:"),(0,o.kt)("p",null,"\u6ce8\u89e3\u4e2d\u6570\u7ec4\u53c2\u6570\u7684\u8bed\u6cd5\u662f\u7075\u6d3b\u7684\u3002\u5b83\u9488\u5bf9\u5355\u5143\u7d20\u6570\u7ec4\u8fdb\u884c\u4e86\u4f18\u5316\u3002\u524d\u9762\u7684 ExceptionTest \u6ce8\u89e3\u5bf9\u4e8e ExceptionTest \u7684\u65b0\u6570\u7ec4\u53c2\u6570\u7248\u672c\u4ecd\u7136\u6709\u6548\uff0c\u5e76\u4e14\u53ef\u4ee5\u751f\u6210\u5355\u5143\u7d20\u6570\u7ec4\u3002\u8981\u6307\u5b9a\u4e00\u4e2a\u591a\u5143\u7d20\u6570\u7ec4\uff0c\u7528\u82b1\u62ec\u53f7\u5305\u56f4\u5143\u7d20\uff0c\u5e76\u7528\u9017\u53f7\u5206\u9694\u5b83\u4eec\uff1a"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"// Code containing an annotation with an array parameter\n@ExceptionTest({ IndexOutOfBoundsException.class,NullPointerException.class })\npublic static void doublyBad() {\n    List<String> list = new ArrayList<>();\n    // The spec permits this method to throw either\n    // IndexOutOfBoundsException or NullPointerException\n    list.addAll(5, null);\n}\n")),(0,o.kt)("p",null,"It is reasonably straightforward to modify the test runner tool to process the new version of ExceptionTest. This code replaces the original version:"),(0,o.kt)("p",null,"\u4fee\u6539\u6d4b\u8bd5\u8fd0\u884c\u5668\u5de5\u5177\u6765\u5904\u7406 ExceptionTest \u7684\u65b0\u7248\u672c\u662f\u76f8\u5f53\u7b80\u5355\u7684\u3002\u8fd9\u6bb5\u4ee3\u7801\u66ff\u6362\u4e86\u539f\u6765\u7684\u7248\u672c\uff1a"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'if (m.isAnnotationPresent(ExceptionTest.class)) {\n    tests++;\n    try {\n        m.invoke(null);\n        System.out.printf("Test %s failed: no exception%n", m);\n    } catch (Throwable wrappedExc) {\n        Throwable exc = wrappedExc.getCause();\n        int oldPassed = passed;\n        Class<? extends Exception>[] excTypes =m.getAnnotation(ExceptionTest.class).value();\n        for (Class<? extends Exception> excType : excTypes) {\n            if (excType.isInstance(exc)) {\n                passed++;\n                break;\n            }\n        }\n        if (passed == oldPassed)\n            System.out.printf("Test %s failed: %s %n", m, exc);\n    }\n}\n')),(0,o.kt)("p",null,"As of Java 8, there is another way to do multivalued annotations. Instead of declaring an annotation type with an array parameter, you can annotate the declaration of an annotation with the @Repeatable meta-annotation, to indicate that the annotation may be applied repeatedly to a single element. This meta-annotation takes a single parameter, which is the class object of a containing annotation type, whose sole parameter is an array of the annotation type ","[JLS, 9.6.3]",". Here\u2019s how the annotation declarations look if we take this approach with our ExceptionTest annotation. Note that the containing annotation type must be annotated with an appropriate retention policy and target, or the declarations won\u2019t compile:"),(0,o.kt)("p",null,"\u5728 Java 8 \u4e2d\uff0c\u8fd8\u6709\u53e6\u4e00\u79cd\u65b9\u6cd5\u53ef\u4ee5\u6267\u884c\u591a\u503c\u6ce8\u89e3\u3002\u4f60\u53ef\u4ee5\u5728\u6ce8\u89e3\u58f0\u660e\u4e0a\u4f7f\u7528 ",(0,o.kt)("inlineCode",{parentName:"p"},"@Repeatable")," \u5143\u6ce8\u89e3\uff0c\u4ee5\u8868\u660e\u6ce8\u89e3\u53ef\u4ee5\u91cd\u590d\u5730\u5e94\u7528\u4e8e\u5355\u4e2a\u5143\u7d20\uff0c\u800c\u4e0d\u662f\u4f7f\u7528\u6570\u7ec4\u53c2\u6570\u6765\u58f0\u660e\u6ce8\u89e3\u7c7b\u578b\u3002\u8fd9\u4e2a\u5143\u6ce8\u89e3\u53ea\u63a5\u53d7\u4e00\u4e2a\u53c2\u6570\uff0c\u8fd9\u4e2a\u53c2\u6570\u662f\u5305\u542b\u6ce8\u89e3\u7c7b\u578b\u7684\u7c7b\u5bf9\u8c61\uff0c\u5b83\u7684\u552f\u4e00\u53c2\u6570\u662f\u6ce8\u89e3\u7c7b\u578b\u7684\u6570\u7ec4 ","[JLS, 9.6.3]","\u3002\u5982\u679c\u6211\u4eec\u5bf9 ExceptionTest \u6ce8\u89e3\u91c7\u7528\u8fd9\u79cd\u65b9\u6cd5\uff0c\u90a3\u4e48\u6ce8\u89e3\u58f0\u660e\u662f\u8fd9\u6837\u7684\u3002\u6ce8\u610f\uff0c\u5305\u542b\u7684\u6ce8\u89e3\u7c7b\u578b\u5fc5\u987b\u4f7f\u7528\u9002\u5f53\u7684 Retention \u6ce8\u89e3\u548c Target \u6ce8\u89e3\uff0c\u5426\u5219\u58f0\u660e\u5c06\u65e0\u6cd5\u7f16\u8bd1\uff1a"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"// Repeatable annotation type\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\n@Repeatable(ExceptionTestContainer.class)\npublic @interface ExceptionTest {\n    Class<? extends Exception> value();\n}\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface ExceptionTestContainer {\n    ExceptionTest[] value();\n}\n")),(0,o.kt)("p",null,"Here\u2019s how our doublyBad test looks with a repeated annotation in place of an array-valued annotation:"),(0,o.kt)("p",null,"\u4e0b\u9762\u662f\u4f7f\u7528\u91cd\u590d\u6ce8\u89e3\u4ee3\u66ff\u6570\u7ec4\u503c\u6ce8\u89e3\u7684 doublyBad \u6d4b\u8bd5\uff1a"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"// Code containing a repeated annotation\n@ExceptionTest(IndexOutOfBoundsException.class)\n@ExceptionTest(NullPointerException.class)\npublic static void doublyBad() { ... }\n")),(0,o.kt)("p",null,"Processing repeatable annotations requires care. A repeated annotation generates a synthetic annotation of the containing annotation type. The getAnnotationsByType method glosses over this fact, and can be used to access both repeated and non-repeated annotations of a repeatable annotation type. But isAnnotationPresent makes it explicit that repeated annotations are not of the annotation type, but of the containing annotation type. If an element has a repeated annotation of some type and you use the isAnnotationPresent method to check if the element has an annotation of that type, you\u2019ll find that it does not. Using this method to check for the presence of an annotation type will therefore cause your program to silently ignore repeated annotations. Similarly, using this method to check for the containing annotation type will cause the program to silently ignore non-repeated annotations. To detect repeated and non-repeated annotations with isAnnotationPresent, you much check for both the annotation type and its containing annotation type. Here\u2019s how the relevant part of our RunTests program looks when modified to use the repeatable version of the ExceptionTest annotation:"),(0,o.kt)("p",null,"\u5904\u7406\u53ef\u91cd\u590d\u6ce8\u89e3\u9700\u8981\u5c0f\u5fc3\u3002\u300c\u91cd\u590d\u72b6\u6001\u300d\u4f1a\u751f\u6210\u540d\u4e3a\u300c\u5bb9\u5668\u6ce8\u89e3\u7c7b\u578b\u300d\u7684\u5408\u6210\u6ce8\u89e3\u3002getAnnotationsByType \u65b9\u6cd5\u53ef\u5ffd\u7565\u8fd9\u4e00\u533a\u522b\uff0c\u5b83\u53ef\u4ee5\u7528\u4e8e\u8bbf\u95ee\u53ef\u91cd\u590d\u6ce8\u89e3\u7c7b\u578b\u7684\u300c\u91cd\u590d\u72b6\u6001\u300d\u548c\u300c\u975e\u91cd\u590d\u72b6\u6001\u300d\u3002\u4f46\u662f isAnnotationPresent \u660e\u786e\u6307\u51fa\uff0c\u300c\u91cd\u590d\u72b6\u6001\u300d\u7684\u60c5\u51b5\u4e0d\u5c5e\u4e8e\u6ce8\u89e3\u7c7b\u578b\uff0c\u800c\u662f\u300c\u5bb9\u5668\u6ce8\u89e3\u7c7b\u578b\u300d\u3002\u5982\u679c\u4e00\u4e2a\u5143\u7d20\u662f\u67d0\u79cd\u7c7b\u578b\u7684\u300c\u91cd\u590d\u72b6\u6001\u300d\u6ce8\u89e3\uff0c\u5e76\u4e14\u4f60\u4f7f\u7528 isAnnotationPresent \u65b9\u6cd5\u68c0\u67e5\u8be5\u5143\u7d20\u662f\u5426\u5177\u6709\u8be5\u7c7b\u578b\u7684\u6ce8\u89e3\uff0c\u4f60\u5c06\u53d1\u73b0\u5b83\u63d0\u793a\u4e0d\u5b58\u5728\u3002\u56e0\u6b64\uff0c\u4f7f\u7528\u6b64\u65b9\u6cd5\u68c0\u67e5\u6ce8\u89e3\u7c7b\u578b\u7684\u5b58\u5728\u4e0e\u5426\uff0c\u5c06\u5bfc\u81f4\u4f60\u7684\u7a0b\u5e8f\u5ffd\u7565\u300c\u91cd\u590d\u72b6\u6001\u300d\u3002\u7c7b\u4f3c\u5730\uff0c\u4f7f\u7528\u6b64\u65b9\u6cd5\u68c0\u67e5\u300c\u5bb9\u5668\u6ce8\u89e3\u7c7b\u578b\u300d\u5c06\u5bfc\u81f4\u7a0b\u5e8f\u5ffd\u7565\u300c\u975e\u91cd\u590d\u72b6\u6001\u300d\u3002\u8981\u4f7f\u7528 isAnnotationPresent \u68c0\u6d4b\u300c\u91cd\u590d\u72b6\u6001\u300d\u548c\u300c\u975e\u91cd\u590d\u72b6\u6001\u300d\uff0c\u9700\u8981\u540c\u65f6\u68c0\u67e5\u6ce8\u89e3\u7c7b\u578b\u53ca\u5176\u300c\u5bb9\u5668\u6ce8\u89e3\u7c7b\u578b\u300d\u3002\u4e0b\u9762\u662f\u6211\u4eec\u7684 RunTests \u7a0b\u5e8f\u7684\u76f8\u5173\u90e8\u5206\u4fee\u6539\u4e3a\u4f7f\u7528 ExceptionTest \u6ce8\u89e3\u7684\u53ef\u91cd\u590d\u7248\u672c\u65f6\u7684\u6837\u5b50\uff1a"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'// Processing repeatable annotations\nif (m.isAnnotationPresent(ExceptionTest.class)|| m.isAnnotationPresent(ExceptionTestContainer.class)) {\n    tests++;\n    try {\n        m.invoke(null);\n        System.out.printf("Test %s failed: no exception%n", m);\n    } catch (Throwable wrappedExc) {\n        Throwable exc = wrappedExc.getCause();\n        int oldPassed = passed;\n        ExceptionTest[] excTests =m.getAnnotationsByType(ExceptionTest.class);\n        for (ExceptionTest excTest : excTests) {\n            if (excTest.value().isInstance(exc)) {\n                passed++;\n                break;\n            }\n        }\n        if (passed == oldPassed)\n            System.out.printf("Test %s failed: %s %n", m, exc);\n    }\n}\n')),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"\u8bd1\u6ce8\uff1a\u6bd4\u8f83\u539f\u6587\u4e2d\u63d0\u53ca\u7684 getAnnotationsByType \u4e0e isAnnotationPresent \u5728\u53ef\u91cd\u590d\u6ce8\u89e3\u7684\u300c\u91cd\u590d\u72b6\u6001\u300d\u548c\u300c\u975e\u91cd\u590d\u72b6\u6001\u300d\u4e0b\u7684\u4f7f\u7528\u5dee\u522b\uff1a")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"\u539f doublyBad \u65b9\u6cd5\u4e0d\u53d8\uff0c\u5c5e\u4e8e\u300c\u91cd\u590d\u72b6\u6001\u300d\uff08\u91cd\u590d\u6ce8\u89e3\u5927\u4e8e\u7b49\u4e8e\u4e24\u4e2a\u7684\uff0c\u90fd\u5c5e\u4e8e\u300c\u91cd\u590d\u72b6\u6001\u300d\uff09\uff1b\u65b0\u589e\u4e00\u4e2a doublyBad2 \u65b9\u6cd5\uff0c\u4ec5\u4f7f\u7528\u4e00\u4e2a\u91cd\u590d\u6ce8\u89e3\uff0c\u5c5e\u4e8e\u300c\u975e\u91cd\u590d\u72b6\u6001\u300d")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"class Simple4 {\n    // Code containing a repeated annotation\n    @ExceptionTest(IndexOutOfBoundsException.class)\n    @ExceptionTest(NullPointerException.class)\n    public static void doublyBad() {\n    }\n\n    @ExceptionTest(ArithmeticException.class)\n    public static void doublyBad2() {\n    }\n}\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"\u6d4b\u8bd5\u4ee3\u7801")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'public static void main(String[] args) throws NoSuchMethodException {\n    Class<?> testClass = Simple4.class;\n    for (int count = 1; count <= 2; count++) {\n        Method m = testClass.getMethod(count == 1 ? "doublyBad" : "doublyBad" + count);\n        System.out.println(m.getName() + "\u300c\u91cd\u590d\u72b6\u6001\u300d\uff1a" + m.isAnnotationPresent(ExceptionTest.class));\n        System.out.println(m.getName() + "\u300c\u5bb9\u5668\u6ce8\u89e3\u7c7b\u578b\u300d\uff1a" + m.isAnnotationPresent(ExceptionTestContainer.class));\n        System.out.println(m.getName() + "\u300c\u975e\u91cd\u590d\u72b6\u6001\u300d\uff1a" + m.isAnnotationPresent(ExceptionTest.class));\n        System.out.println(m.getName() + "\u300c\u91cd\u590d\u72b6\u6001\u300d\uff1a" + m.getAnnotationsByType(ExceptionTest.class));\n        System.out.println(m.getName() + "\u300c\u5bb9\u5668\u6ce8\u89e3\u7c7b\u578b\u300d\uff1a" + m.getAnnotationsByType(ExceptionTestContainer.class));\n        System.out.println(m.getName() + "\u300c\u975e\u91cd\u590d\u72b6\u6001\u300d\uff1a" + m.getAnnotationsByType(ExceptionTest.class));\n    }\n}\n')),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"\u7ed3\u679c")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"doublyBad\u300c\u91cd\u590d\u72b6\u6001\u300d\uff1afalse\ndoublyBad\u300c\u5bb9\u5668\u6ce8\u89e3\u7c7b\u578b\u300d\uff1atrue\ndoublyBad\u300c\u975e\u91cd\u590d\u72b6\u6001\u300d\uff1afalse\ndoublyBad\u300c\u91cd\u590d\u72b6\u6001\u300d\uff1a[LItem_39.ExceptionTest;@1593948d\ndoublyBad\u300c\u5bb9\u5668\u6ce8\u89e3\u7c7b\u578b\u300d\uff1a[LItem_39.ExceptionTestContainer;@1b604f19\ndoublyBad\u300c\u975e\u91cd\u590d\u72b6\u6001\u300d\uff1a[LItem_39.ExceptionTest;@7823a2f9\n\ndoublyBad2\u300c\u91cd\u590d\u72b6\u6001\u300d\uff1atrue\ndoublyBad2\u300c\u5bb9\u5668\u6ce8\u89e3\u7c7b\u578b\u300d\uff1afalse\ndoublyBad2\u300c\u975e\u91cd\u590d\u72b6\u6001\u300d\uff1atrue\ndoublyBad2\u300c\u91cd\u590d\u72b6\u6001\u300d\uff1a[LItem_39.ExceptionTest;@cb5822\ndoublyBad2\u300c\u5bb9\u5668\u6ce8\u89e3\u7c7b\u578b\u300d\uff1a[LItem_39.ExceptionTestContainer;@4b9e13df\ndoublyBad2\u300c\u975e\u91cd\u590d\u72b6\u6001\u300d\uff1a[LItem_39.ExceptionTest;@2b98378d\n")),(0,o.kt)("p",null,"Repeatable annotations were added to improve the readability of source code that logically applies multiple instances of the same annotation type to a given program element. If you feel they enhance the readability of your source code, use them, but remember that there is more boilerplate in declaring and processing repeatable annotations, and that processing repeatable annotations is error-prone."),(0,o.kt)("p",null,"\u6dfb\u52a0\u53ef\u91cd\u590d\u6ce8\u89e3\u662f\u4e3a\u4e86\u63d0\u9ad8\u6e90\u4ee3\u7801\u7684\u53ef\u8bfb\u6027\uff0c\u6e90\u4ee3\u7801\u5728\u903b\u8f91\u4e0a\u5c06\u540c\u4e00\u6ce8\u89e3\u7c7b\u578b\u7684\u591a\u4e2a\u5b9e\u4f8b\u5e94\u7528\u4e8e\u7ed9\u5b9a\u7684\u7a0b\u5e8f\u5143\u7d20\u3002\u5982\u679c\u4f60\u89c9\u5f97\u5b83\u4eec\u589e\u5f3a\u4e86\u6e90\u4ee3\u7801\u7684\u53ef\u8bfb\u6027\uff0c\u90a3\u4e48\u5c31\u4f7f\u7528\u5b83\u4eec\uff0c\u4f46\u662f\u8bf7\u8bb0\u4f4f\uff0c\u5728\u58f0\u660e\u548c\u5904\u7406\u53ef\u91cd\u590d\u6ce8\u89e3\u65b9\u9762\u6709\u66f4\u591a\u7684\u6837\u677f\uff0c\u5e76\u4e14\u5904\u7406\u53ef\u91cd\u590d\u6ce8\u89e3\u5f88\u5bb9\u6613\u51fa\u9519\u3002"),(0,o.kt)("p",null,"The testing framework in this item is just a toy, but it clearly demonstrates the superiority of annotations over naming patterns, and it only scratches the surface of what you can do with them. If you write a tool that requires programmers to add information to source code, define appropriate annotation types. ",(0,o.kt)("strong",{parentName:"p"},"There is simply no reason to use naming patterns when you can use annotations instead.")),(0,o.kt)("p",null,"\u672c\u6761\u76ee\u4e2d\u7684\u6d4b\u8bd5\u6846\u67b6\u53ea\u662f\u4e00\u4e2a\u793a\u4f8b\uff0c\u4f46\u662f\u5b83\u6e05\u695a\u5730\u5c55\u793a\u4e86\u6ce8\u89e3\u76f8\u5bf9\u4e8e\u547d\u540d\u6a21\u5f0f\u7684\u4f18\u52bf\uff0c\u5e76\u4e14\u5b83\u53ea\u6d89\u53ca\u5230\u4f60\u53ef\u4ee5\u4f7f\u7528\u5b83\u4eec\u505a\u4ec0\u4e48\u3002\u5982\u679c\u4f60\u7f16\u5199\u7684\u5de5\u5177\u8981\u6c42\u7a0b\u5e8f\u5458\u5411\u6e90\u4ee3\u7801\u4e2d\u6dfb\u52a0\u4fe1\u606f\uff0c\u8bf7\u5b9a\u4e49\u9002\u5f53\u7684\u6ce8\u89e3\u7c7b\u578b\u3002",(0,o.kt)("strong",{parentName:"p"},"\u5982\u679c\u53ef\u4ee5\u4f7f\u7528\u6ce8\u89e3\uff0c\u90a3\u4e48\u5c31\u6ca1\u6709\u7406\u7531\u4f7f\u7528\u547d\u540d\u6a21\u5f0f\u3002")),(0,o.kt)("p",null,"That said, with the exception of toolsmiths, most programmers will have no need to define annotation types. But ",(0,o.kt)("strong",{parentName:"p"},"all programmers should use the predefined annotation types that Java provides")," (Items 40, 27). Also, consider using the annotations provided by your IDE or static analysis tools. Such annotations can improve the quality of the diagnostic information provided by these tools. Note, however, that these annotations have yet to be standardized, so you may have some work to do if you switch tools or if a standard emerges."),(0,o.kt)("p",null,"\u4e5f\u5c31\u662f\u8bf4\uff0c\u9664\u4e86 toolsmiths \u4e4b\u5916\uff0c\u5927\u591a\u6570\u7a0b\u5e8f\u5458\u4e0d\u9700\u8981\u5b9a\u4e49\u6ce8\u89e3\u7c7b\u578b\u3002\u4f46\u662f\u6240\u6709\u7a0b\u5e8f\u5458\u90fd\u5e94\u8be5\u4f7f\u7528 Java \u63d0\u4f9b\u7684\u9884\u5b9a\u4e49\u6ce8\u89e3\u7c7b\u578b\uff08",(0,o.kt)("a",{parentName:"p",href:"./Chapter-6-Item-40-Consistently-use-the-Override-annotation"},"Item-40")," \u548c ",(0,o.kt)("a",{parentName:"p",href:"./Chapter-5-Item-27-Eliminate-unchecked-warnings"},"Item-27"),"\uff09\u3002\u53e6\u5916\uff0c\u8003\u8651\u4f7f\u7528 IDE \u6216\u9759\u6001\u5206\u6790\u5de5\u5177\u63d0\u4f9b\u7684\u6ce8\u89e3\u3002\u8fd9\u4e9b\u6ce8\u89e3\u53ef\u4ee5\u63d0\u9ad8\u8fd9\u4e9b\u5de5\u5177\u63d0\u4f9b\u7684\u8bca\u65ad\u4fe1\u606f\u7684\u8d28\u91cf\u3002\u4f46\u662f\uff0c\u8bf7\u6ce8\u610f\uff0c\u8fd9\u4e9b\u6ce8\u89e3\u8fd8\u6ca1\u6709\u6807\u51c6\u5316\uff0c\u56e0\u6b64\uff0c\u5982\u679c\u4f60\u5207\u6362\u4e86\u5de5\u5177\u6216\u51fa\u73b0\u4e86\u6807\u51c6\uff0c\u90a3\u4e48\u4f60\u53ef\u80fd\u9700\u8981\u505a\u4e00\u4e9b\u5de5\u4f5c\u3002"),(0,o.kt)("hr",null),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("a",{parentName:"strong",href:"./Chapter-6-Introduction"},"Back to contents of the chapter\uff08\u8fd4\u56de\u7ae0\u8282\u76ee\u5f55\uff09"))),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Previous Item\uff08\u4e0a\u4e00\u6761\u76ee\uff09\uff1a",(0,o.kt)("a",{parentName:"strong",href:"./Chapter-6-Item-38-Emulate-extensible-enums-with-interfaces"},"Item 38: Emulate extensible enums with interfaces\uff08\u4f7f\u7528\u63a5\u53e3\u6a21\u62df\u53ef\u6269\u5c55\u679a\u4e3e\uff09"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Next Item\uff08\u4e0b\u4e00\u6761\u76ee\uff09\uff1a",(0,o.kt)("a",{parentName:"strong",href:"./Chapter-6-Item-40-Consistently-use-the-Override-annotation"},"Item 40: Consistently use the Override annotation\uff08\u575a\u6301\u4f7f\u7528 @Override \u6ce8\u89e3\uff09")))))}m.isMDXComponent=!0}}]);